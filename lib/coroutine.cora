(@import "cora/lib/queue" queue)
(@import "cora/lib/rand" rand)

(set '.task-queue (queue.make))

(defun .spawn (thunk)
  (queue.enqueue .task-queue thunk))

;; schedule take a task out and execute it
;; return false if no more tasks
(defun schedule (thunk)
  (if (queue.empty .task-queue)
      false
      (let task (queue.dequeue .task-queue)
	   (begin (task) true))))

(defun schedule-loop ()
  (if (= false (schedule))
      ()
      (schedule-loop)))

(defun .main ()
  (try schedule-loop 
       (lambda (v k)
	 (v k))))

;; channel is a sendq and recvq
;; sendq represent the coroutines blocked sending msg to the channel.
;; recvq represent the coroutines blocked recving msg from the channel.
(defun make-chan ()
  [(queue.make) (queue.make)])

(func recv-try
      [sendq recvq] => (if (queue.empty? sendq)
			   false
			   (match (queue.dequeue sendq)
				  [state resume val]
				  (if (= 'Done (value state))
				      (recv-try [sendq recvq]) ;; ignore stale item and continue
				      (begin
				       (queue.enqueue .task-queue resume)
				       (set state 'Done)
				       val)))))

(defun recv-block (recvq k)
  (let state (gensym 'state)
       (begin
	(set state 'Wait)
	(queue.enqueue recvq [state k]))))

;; recv on channel is an operation
(defun recv (ch)
  (let try (lambda () (recv-try ch))
       block (lambda (k) (recv-block (cadr ch) k))
       [try block]))

(func send-try
      [sendq recvq] => (if (queue.empty? recvq)
			   false
			   (match (queue.dequeue recvq)
				  [state resume]
				  (if (= 'Done (value state))
				      (send-try [sendq recvq]) ;; ignore stale
				      (begin
				       (queue.enqueue .task-queue resume)
				       (set state 'Done)
				       ())))))

(defun send-block (sendq k val)
  (let state (gensym 'state)
       (begin
	(set state 'Wait)
	(queue.enqueue sendq [state k val]))))

;; send on channel is an operation
(defun send (ch val)
  (let try (lambda () (send-try ch))
       block (lambda (k) (send-block (car ch) k val))
       [try block]))

;; ;; wrap an operation to get another operation.
;; ;; fn receive the value of the operation.
;; ;; (func wrap
;; ;;       [try block wrap] fn => [(lambda ()
;; ;; 			   (let val (try)
;; ;; 				(if (= false val)
;; ;; 				    false
;; ;; 				    (fn val))))
;; ;;       (lambda (k) (block k))])

;; (func choice-ops-try
;;       [] => false
;;       [[try1 block1] . remain] => (match (try1)
;; 					 false (choice-ops-try remain)
;; 					 v v))

;; (defun choice-op (ops)
;;   (let try (lambda () (choice-ops-try ops))
;;        block (lambda (k)
;; 	       (for-each (lambda (op)
;; 			   (match op
;; 				  [try1 block1]
;; 				  (block1 k)))))
;;        [try block]))

(func random-split
      [] to1 to2 => (cons to1 to2)
      [hd . tl] to1 to2 => (if (= (rand.N 2) 0)
			       (random-split tl (cons hd to1) to2)
			       (random-split tl to1 (cons hd to2))))

(func random-merge
      [] from to => (append from to)
      from [] to => (append from to)
      from1 from2 to => (if (= (rand.N 2) 0)
			    (random-merge (cdr from1) from2 (cons (car from1) to))
			    (random-merge from1 (cdr from2) (cons (car from2) to))))

(func shuffle-h
      l 0 => l
      l n => (let tmp (random-split l [] [])
		  (let res (random-merge (car tmp) (cdr tmp) [])
		       (shuffle-h res (- n 1)))))
			  
(defun shuffle (arr)
  (shuffle-h arr (/ (+ 1 (length arr)) 2)))

;; (defmacro choice (input)
;;   ['choice-op ['shuffle (cdr input)]])

;; ;; perform performs an operation.
;; ;; an operation consistent of [try block wrap]
;; ;; Usage example:
;; ;; (perform (choice
;; ;; 	  (wrap (recv ch1)
;; ;; 		   (lambda (v) ...))
;; ;; 	  (wrap (send ch2)
;; ;; 		   (lambda (v) ...))))
;; (func perform
;;       [try block] => (match (try)
;; 			    false (throw (lambda (k)
;; 					   (begin
;; 					    (block k)
;; 					    (schedule))))
;; 			    v v))

