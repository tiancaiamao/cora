(import "cora/lib/sys")
(@import "cora/lib/io" io)

(set '*tvar* 1000)
(defun tvar ()
  (let ret *tvar*
    (do (set '*tvar* (+ ret 1))
	ret)))

(defun unify (x y s)
  (unify1 (apply-subst x s) (apply-subst y s) s))

(func bind-s
      ['succ s] f => (f s)
	  ['fail . msg] f => ['fail . msg])

(func unify1
      x y s => ['succ s] where (= x y)
      x y s => ['succ [[x . y] . s]] where (and (number? x) (not (occur? x y)))
      x y s => ['succ [[y . x] . s]] where (and (number? y) (not (occur? y x)))
      [a '-> b] [c '-> d] s => (bind-s (unify a c s)
								 (lambda (s1) (unify b d s1)))
      ['list a] ['list b] s => (unify a b s)
	  _ _ s => ['fail])

(func occur?
      'int _ => false
      'bool _ => false
      'symbol _ => false
      [a '-> b] t => (or (occur? a t) (occur? b t))
	  x [a '-> b] => (or (occur? x a) (occur? x b)) where (number? x)
      ['list a] t => (occure? a t)
      v t => (= v t))

(func apply-subst
      'int s => 'int
      'bool s => 'bool
      'symbol _ => 'symbol
      [a '-> b] s => [(apply-subst a s) '-> (apply-subst b s)]
      ['list a] s => ['list (apply-subst a s)]
      v s => (let find (assq v s)
		  (if (null? find)
		      v
		      (apply-subst (cdr find) s))))

(defun extend (env v x)
  (cons (cons v x) env))
	
(func check-type-core
      x t env s => (unify 'int t s) where (number? x)
      x t env s => (unify 'bool t s) where (boolean? x)
      ['quote s] t env s => (unify 'symbol t s)
      x t env s => (let find (assq x env)
			(if (null? find)
			    ['fail "variable not bound" x]
			    (unify (cdr find) t s))) where (symbol? x)
	  ['if e1 e2 e3] t env s => (bind-s (check-type-core e1 'bool env s)
			  (lambda (s1)
			   (bind-s (check-type e2 t env s1)
				(lambda (_)
				 (check-type e3 t env s1)))))
      ['lambda [x] e] [a '-> b] env s => (check-type e b (extend env x a) s)
	  ['lambda [x] e] any env s => (let tx (tvar)
									  te (tvar)
									  (bind-s (check-type e te (extend env x tx) s)
									   (lambda (s1)
										(unify any [tx '-> te] s1)))) where (number? any)
      ['lambda [x . more] e] t env s => (check-type ['lambda [x] ['lambda more e]] t env s) where (not (= () more))
	  ['let a b c] t env s => (let tb (tvar)
								(bind-s (check-type b tb env s)
										(lambda (s1)
										(check-type c t (extend env a tb) s1))))
      [f x] t env s => (let a (tvar) b (tvar)
						(bind-s (check-type-core f [a '-> b] env s)
						    (lambda (s1)
							(bind-s (check-type x (apply-subst a s1) env s1)
								(lambda (s2)
								(bind-s (unify t b s2)
										(lambda (s3)
										 ['succ (filter (lambda (x)
														 (let k (car x)
														  (not (or (= k a) (= k b)))))
												 s3)])))))))
	  [f x . more] b env s => (check-type [[f x] . more] b env s)
	  _ _ env s => ['fail])

(set '*type-rule* ())

(defun check-type (exp typ env subst)
 (if (pair? typ)	
  (let find (assq (car typ) *type-rule*)
   (if (null? find)
	(check-type-core exp typ env subst)
	(match ((cdr find) exp typ env subst)
	 ['fail] (check-type-core exp typ env subst)
	 succ succ)))
  (check-type-core exp typ env subst)))

(func type-check-for-list
 [] ['list a] env s => ['succ s]
 ['cons x y] ['list a] env s => (bind-s (check-type x a env s)
		 (lambda (s1)
		  (check-type y ['list a] env s1)))
 exp typ env s => ['fail])
(set '*type-rule* (cons (cons 'list type-check-for-list) *type-rule*))

(func type-check-for-tuple
  ['cons x y] ['tuple a b] env s => (bind-s (check-type x a env s)
										(lambda (s1) 
												(check-type y b env s1))))
(set '*type-rule* (cons (cons 'tuple type-check-for-tuple) *type-rule*))

(func type-check-for-maybe
  [] ['maybe t] env s => ['succ s]
  exp ['maybe t] env s => (check-type exp t env s))
(set '*type-rule* (cons (cons 'maybe type-check-for-maybe) *type-rule*))

(func type-check-for-monad
 [retrn . x] ['monad a] env s => ['succ s]
 [bind ma f] ['monad a] env s => (bind-s (check-type ma ['monad a] env s)
										(lambda (s1)
										(check-type f (let b (tvar) [a '-> ['monad b]]) env s1))))
(set '*type-rule* (cons (cons 'monad type-check-for-monad) *type-rule*))


(set '*type-env* ())
(set '*type-env* (cons (cons 'car (let a (tvar) b (tvar) [a '-> b])) *type-env*))
(set '*type-env* (cons (cons 'hd (let a (tvar) [['list a] '-> a])) *type-env*))
(set '*type-env* (cons (cons 'tl (let a (tvar) [['list a] '-> ['list a]])) *type-env*))
(set '*type-env* (cons (cons '+ `(int -> (int -> int))) *type-env*))
(set '*type-env* (cons (cons '- `(int -> (int -> int))) *type-env*))
(set '*type-env* (cons (cons '* `(int -> (int -> int))) *type-env*))
(set '*type-env* (cons (cons '= (let a (tvar) b (tvar) `(,a -> (,b -> bool)))) *type-env*))
(set '*type-env* (cons (cons 'set (let a (tvar) ['synbol '-> a])) *type-env*))
(set '*type-env* (cons (cons 'null? [(tvar) '-> 'bool]) *type-env*))
(set '*type-env* (cons (cons 'cons? [(tvar) '-> 'bool]) *type-env*))


;; (func type-check-for-fruit
;;       x ['fruit] env s => s where (elem? x ['apple 'orange 'banana]))
;; 
;; (func type-check-for-struct
;;       [a b] ['struct 'int 'bool] env s => (let s1 (check-type a 'int env s)
;;       						(check-type b 'bool env s)))
;; 
;; (func type-check-for-option
;;       ['ok x] ['option a b] env s => (check-type x a env s)
;;       ['err y] ['option a b] env s => (check-type y b env s))
;; 	
;; 
;; (set '*type-rule* (cons (cons 'fruit type-check-for-fruit) *type-rule*))
;; (set '*type-rule* (cons (cons 'option type-check-for-option) *type-rule*))


;; (check-type 'apple '(fruit) () ())
;; (check-type ['ok 3] '(option int a) () ())


;; (check-type '(lambda (f g) (f (g 1)))
;; 	    '((0 -> 1) -> ((int -> 0) -> 1))
;; 	    () ())

;; HM cannot infer high rank polymorphic, but it can check that with annotation.
;; (check-type
;;  '(lambda (f)
;; 		 (if (f true) (f 42) false))
;;  '((1 -> bool) -> bool)
;;  () ())

;; This case is invalid for HM to infer 
;; x : a -> b
;; f : b -> b -> c
;; (check-type '(lambda (f x)
;; 			  (f (x 1) (x true)))
;; 		'((2 -> (2 -> 3)) -> (1 -> 2))
;; 		() ())

;; This case should fail, because x is unify with both int and bool
;; (check-type
;;  '(lambda (x)
;; 		 (h (f x) (g x)))
;;  '(6 -> 7)
;;  [(cons 'f '(int -> 1))
;;  (cons 'g '(bool -> 2))
;;  (cons 'h '(3 -> (4 -> 5)))] ())


;; (infer '(lambda (x) (if true (x 1) (x true))) () ())  => fail
;; (check-type '(lambda (x) (if true (x 1) (x true)))
;; 	    '((1 -> 2) -> 2)
;; 	    () ())                                 => ok


;; type check reverse function
;; (check-type  '(lambda (x y)
;; 			   (if (null? x) y
;; 				(if (cons? x)
;; 				 (reverse-h (tl x) (cons (hd x) y))
;; 				 ())))
;;  '((list 1) -> ((list 1) -> (list 1)))
;;  (extend *type-env*
;;   'reverse-h '((list 1) -> ((list 1) -> (list 1))))
;;  ())
