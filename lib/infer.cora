(@import "cora/lib/sys")
;; (@import "cora/lib/io")

(set '*tvar* 1000)
(defun tvar ()
  (let ret *tvar*
    (do (set '*tvar* (+ ret 1))
	ret)))

(defun extend (env v x)
  (cons (cons v x) env))

(defun lookupsig (x)
  (let find (assq x *sigf*)
       (if (null? find)
	   (error "unbound variable ")
	   (cdr find))))

(set '*sigf* ())
(defun declare (sym type)
  (set '*sigf* (cons (cons sym type) *sigf*)))

(declare '+ '(int -> (int -> int)))
(declare '- '(int -> (int -> int)))
(declare '* '(int -> (int -> int)))
(declare '/ '(int -> (int -> int)))
(declare '= '(int -> (int -> bool)))

(let t (tvar)
    (begin (declare 'nil ['list t])
	   (declare 'cons [t '-> [['list t] '-> ['list t]]])))

(declare 'hd (let t (tvar) [['list t] '-> t]))
(declare 'tl (let t (tvar) [['list t] '-> ['list t]]))
(declare 'null? (let t (tvar) [['list t] '-> 'bool]))
(declare 'map (let t1 (tvar)
		   t2 (tvar)
		   [[t1 '-> t2] '-> [['list t1] '-> ['list t2]]]))

(declare 'not '(bool -> bool))

(func annotate
      [] _ => []
      [arg1 . arg2] [x '-> y] => [[arg1 ': x] . (annotate arg2 y)])

(func infer
      tctx [] [] s => ['unit s]
      tctx [] x s => ['int s] where (integer? x)
      tctx [] x s => ['bool s] where (boolean? x)
      tctx [] x s => ['string s] where (string? x)
      tctx actx x s => (let find (assq x tctx)
			 (if (null? find)
			     (app-subtype actx (lookupsig x) s)
			     (app-subtype actx (cdr find) s))) where (symbol? x)
      tctx actx ['quote x] s => ['symbol s]
      tctx actx ['if x y z] s => (match (infer tctx actx x s)
					[t s1]
					(let s2 (unify t 'bool s1)
					     (match (infer tctx actx y s2)
						    [tx s3]
						    (match (infer tctx actx z s3)
							   [tz s4]
							   (let s5 (unify tx tz s4)
								[tx s5])))))
      tctx actx ['do x y] s => (do (infer tctx actx x s)
				   (infer tctx actx y s))
      tctx actx ['set ['quote x] v] s => (let find (assq x *sigf*)
					      (if (not (null? find))
						  ;; rewrite the lambda with annotation
						  (match v
							 ['lambda arg body]
							 (infer tctx actx ['lambda (annotate arg (cdr find)) body] s)
							 _ (infer tctx actx v s))
						  (infer tctx actx v s)))
      tctx actx ['let x v body] s => (match (infer tctx [] v s)
					    [A s1]
					    (infer (extend tctx x A) actx body s1))
      tctx actx ['lambda [arg] body] s => (infer tctx actx ['/. arg body] s)
      tctx actx ['lambda [arg . more] body] s => (infer tctx actx ['/. arg ['lambda more body]] s)
      tctx [C . actx] ['/. [x ': A] e] s => (match (infer (extend tctx x A) actx e (subtype C A s))
					      [B s1]
					      [[C '-> B] s1])
      tctx [A . actx] ['/. x e] s => (match (infer (extend tctx x A) actx e s)
				       [B s1]
				       [[A '-> B] s1])
      tctx actx ['/. [x ': A] e] s => (match (infer (extend tctx x A) actx e s)
					[B s1]
					[[A '-> B] s1])
      tctx actx ['/. x e] s => (let tx (tvar)
				 (match (infer (extend tctx x tx) actx e s)
				   [B s1]
				   [[tx '-> B] s1]))
      tctx actx [e1 e2] s => (match (infer tctx [] e2 s)
			       [A s1]
			       (let B (generalize A s1)
				 (match (infer tctx [B . actx] e1 s1)
				   [[b '-> C] s2]
				   [C s2])))
      tctx actx [e1 e2 . more] s => (infer tctx actx [[e1 e2] . more] s))

;; (set 'infer-raw infer)
;; (defun infer (tctx actx x s)
;;   (begin
;;     (display "trace infer execute ========>")
;;     (display tctx)
;;     (display actx)
;;     (display x)
;;     (display s)
;;     (display "\n")
;;     (infer-raw tctx actx x s)))

(func app-subtype
      [] a s => [a s]
      actx ['forall a B] s => (app-subtype actx (alpha B (foldl (lambda (env x)
								  (extend env x (tvar)))
								[]
								a)) s)
      [c . actx1] tv s => (let a (tvar)
			   (let b (tvar)
			     (let s1 (subtype c a (unify tv [a '-> b] s))
			       (match (app-subtype actx1 b s1)
				 [d s2]
				 [[c '-> d] s2])))))

(defun subtype (t1 t2 s)
  (subtype1 (apply-subst t1 s) (apply-subst t2 s) s))

(func subtype1
      t1 t2 s => s where (= t1 t2)
      t1 t2 s => [[t2 . t1] . s] where (integer? t2)
      A ['forall a B] s => (subtype A B s)
      ['forall a A] B s => (let t (tvar)
			     (subtype (alpha A (foldl (lambda (env x) (extend env x (tvar)))
						      []
						      a)) B s))
      ['list A] ['list B] s => (subtype A B s)
      [A '-> B] [C '-> D] s => (let s1 (subtype C A s)
				 (subtype B D s1)))

(func alpha
      'int s => 'int
      'bool s => 'bool
      'string s => 'string
      ['list A] s => ['list (alpha A s)]
      [A '-> B] s => [(alpha A s) '-> (alpha B s)]
      ['forall a A] s => (alpha A (extend a (tvar) s))
      t s => (let find (assq t s)
	       (if (null? find)
		   t
		   (cdr find))))

(func generalize
      A s => A where (integer? A)
      A s => (let fv (free-vars A [] [])
	       (let fv1 (filter (lambda (x) (null? (assq x s))) fv)
		 (if (null? fv1) A
		     ['forall fv1 A]))))

;; (generalize [1 '-> 1] []) => ['forall [2] 2 '-> 2]

(func free-vars
      'int bind res => res
      'bool bind res => res
      'string bind res => res
      tv bind res => (if (or (elem? tv bind) (elem? tv res))
			 res
			 (cons tv res)) where (integer? tv)
      [a '-> b] bind res => (let res1 (free-vars a bind res)
			      (free-vars b bind res1))
      ['forall a b] bind res => (free-vars b (cons a bind) res)
      ['list x] bind res => (free-vars x bind res))
      

(func apply-subst
      'int s => 'int
      'bool s => 'bool
      'string s => 'string
      [a '-> b] s => [(apply-subst a s) '-> (apply-subst b s)]
      ['list a] s => ['list (apply-subst a s)]
      v s => (let find (assq v s)
		  (if (null? find)
		      v
		      (cdr find))))

;; (apply-subst '(4 -> int) '[[1 . int] [2 . bool] [3 . [int -> int]]])
;; (apply-subst '6 '())
;; (apply-subst '1 '())

(func occur?
      'int _ => false
      'bool _ => false
      'string _ => false
      [a '-> b] t => (or (occur? a t) (occur? b t))
      v t => (= v t))

(defun unify (x y s)
  (unify1 (apply-subst x s) (apply-subst y s) s))

(func unify1
      x y s => s where (= x y)
      x y s => [[x . y] . s] where (and (integer? x) (not (occur? x y)))
      x y s => [[y . x] . s] where (and (integer? y) (not (occur? y x)))
      ['list a] ['list b] s => [[a . b] . s]
      [a '-> b] [c '-> d] s => (let s1 (unify a c s)
				 (unify b d s1)))




;; (infer [] [] '42 [])
;; (infer [] [] '(/. x x) [])
;; (infer [] [] '((/. x x) 1) [])
;; (infer [] [] '((/. f f) (/. x x)) [])
;; (infer [] [] '((/. f (f 42)) (/. x x)) [])

;; (infer [] [] '((/. x (/. y x)) 1) [])
;; (infer [] [] '((/. x (/. y y)) 1) [])

;; (infer [] [] '(/. f (/. g (f (g 1)))) [])

;; Need annotation in other algorithm but not in this one
;; (infer [] [] '((/. f ((f true) (f 1))) (/. x (/. y y))) [])

;; This case is invalid for HM to infer 
;; (infer [] [] '(/. f (/. (g : (forall (2000) (2000 -> 2001))) ((f (g 1)) (g true)))) [])
;; (infer [] [] '(/. f (/. g ((f (g (/. z z))) (g (/. u (/. v u)))))) [])


;; (declare map (let t1 (tvar) t2 (tvar)
;; 		  [[t1 '-> t2] '-> [['list t1] '-> ['list t2]]]))
;; '(set 'map (lambda (f l) (if (null? l) nil (cons (f (hd l)) (map f (tl l))))))
