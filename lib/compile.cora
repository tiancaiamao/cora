(package "cora/lib/compile"
	 (import "cora/lib/sys")
	 (export cc)

	 (defun const? (x)
	   (or (null? x)
	       (boolean? x)
	       (integer? x)
	       (string? x)))

	 (func index-h
	       x [] pos res => res
	       x [hd . tl] pos res => (index-h x tl (+ pos 1) (if (= x hd) pos res)))

	 (defun index (x l)
	   (index-h x l 0 -1))

	 (func exist-in-env
	       x [] => false
	       x [hd . tl] => (if (< (index x hd) 0)
				  (exist-in-env x tl)
				  true))
	 (func member
	       x [] => false
	       x [y . z] => (or (= x y)
				(member x z)))

	 (defun set-diff (s exclude)
	   (filter (lambda (v) (not (member v exclude))) s))

	 (func closure-convert-list
	       [] locals env frees nlets res => [(reverse res) frees nlets]
	       [x . more] locals env frees nlets res => (match (closure-convert x locals env frees nlets)
							       [x1 frees1 nlets1]
							       (closure-convert-list more locals env frees1 nlets1 (cons x1 res))))

	 (def *builtin-prims*
	     [['set . 2] ['car . 1] ['cdr . 1] ['cons . 2] ['cons? . 1] ['+ . 2] ['- . 2] ['* . 2] ['/ . 2]
	     ['= . 2] ['> . 2] ['< . 2] ['gensym . 0] ['symbol? . 1] ['not . 1] ['integer? . 1] ['string? . 1]])

	 (func temp-list
	       0 res => res
	       n res => (temp-list (- n 1) (cons (gensym) res)))

	 (defun closure-convert (exp locals env frees nlets)
	   (cond
	     ((const? exp) [exp frees nlets])
	     ((symbol? exp) (let idx (index exp locals)
				 (if (< idx 0)
				     (if (exist-in-env exp env)
					 [exp (cons exp frees) nlets]    ;; free variable
					 [exp frees nlets])               ;; global variable
				     [exp frees nlets]    ;; local variable
				     )))
	     ((not (cons? exp)) (error "assert fail"))
	     ((= 'quote (car exp)) [exp frees nlets])
	     ((= 'lambda (car exp)) (let args (cadr exp)
					 body (caddr exp)
					 (match (closure-convert body args (cons locals env) () 0)
						[body1 frees1 nlets1]
						[['lambda args frees1 nlets1 body1] (append (set-diff frees1 locals) frees) nlets])))
	     ((= 'let (car exp)) (let var (cadr exp)
				      val (caddr exp)
				      exp (cadddr exp)
				      (match (closure-convert val locals env frees nlets)
					     [val1 frees1 nlets1]
					     (let nlets2 (if (> (+ nlets 1) nlets1) (+ nlets 1) nlets1)
						  (match (closure-convert exp (cons var locals) env frees1 nlets2)
							 [exp1 frees2 nlets3]
							 [['let var val1 exp1] frees2 nlets3])))))
	     ((symbol? (car exp)) (let f (car exp)
				       args (cdr exp)
				       (let find (cora/init#assq f *builtin-prims*)
					    (if (and (not (null? find))
						     (< (length args) (cdr find)))
						;; rewrite partial apply of primitives
						;; (+ x) => (lambda (tmp) (+ x tmp))
						(let tmp (temp-list (- (cdr find) (length args)) ())
						     (closure-convert ['lambda tmp (append [f . args] tmp)] locals env frees nlets))
						(closure-convert-list [f . args] locals env frees nlets ())))))
	     (true (let f (car exp)
			args (cdr exp)
			(closure-convert-list [f . args] locals env frees nlets ())))))

	(defun update-max-tos (tos max-tos)
	    (let max (vector-ref max-tos 0)
			(if (> tos max)
		    	(begin (vector-set! max-tos 0 tos) tos)
			    tos)))

	 (func compile
	       exp locals frees tos max-tos next => (cons ['const (update-max-tos tos max-tos) exp] next) where (const? exp)
	       exp locals frees tos max-tos next => (let idx (index exp locals)
						 (if (< idx 0)
						     (let idx1 (index exp frees)
							  (if (< idx1 0)
							      (cons ['global-ref tos exp] next)
							      (cons ['closure-ref (update-max-tos tos max-tos) idx1] next)))
						     (cons ['local-ref (update-max-tos tos max-tos) idx] next)))
	       where (symbol? exp)
	       ['quote x] locals frees tos max-tos next => (cons ['const (update-max-tos tos max-tos) x] next)
	       ['if x y z] locals frees tos max-tos next => (let succ (compile y locals frees (update-max-tos tos max-tos) next)
						        fail (compile z locals frees (update-max-tos tos max-tos) next)
						        (compile x locals frees (update-max-tos tos max-tos) [['if tos succ fail]]))
	       ['do x y] locals frees tos max-tos next => (compile x locals frees (update-max-tos tos max-tos)
						   (compile y locals frees (update-max-tos tos max-tos) next))
	       ['let var val exp] locals frees tos max-tos next =>
								(let body (compile exp (append locals [var]) frees tos max-tos next)
	       							(compile val locals frees (length locals) max-tos body))
	       ['lambda args frees1 nlets body] locals frees tos max-tos next =>
				(let max-tos-body (vector 1)
				    (begin
						(vector-set! max-tos-body 0 0)
						(let nargs (length args)
				             nfrees1 (length frees1)
							 tos-body (+ 1 (+ nargs nlets))
							 code (compile body (cons () args) frees1 tos-body max-tos-body [['exit tos-body]])
							 (compile-list frees1 locals frees tos max-tos
								(cons ['make-closure tos nargs nfrees1 (vector-ref max-tos-body 0) code] next)))))
	       [f . args] locals frees tos max-tos next => (compile-call [f . args] locals frees tos max-tos next))

	 (func compile-call
	       [f . args] locals frees tos max-tos next => (compile-list args locals frees tos max-tos (cons ['primitive tos f] next))
	       where (and (symbol? f) (not (null? (assq f *builtin-prims*))))
	       exp locals frees tos max-tos [['exit _]] => (compile-list exp locals frees tos max-tos [['tailcall tos (length exp)]])
	       exp locals frees tos max-tos next => (compile-list exp locals frees tos max-tos (cons ['call tos (length exp)] next)))

	 (func compile-list
	       [] locals frees tos max-tos next => next
	       [hd . tl] locals frees tos max-tos next => (compile hd locals frees tos max-tos
						   (compile-list tl locals frees (+ tos 1) max-tos next)))

	 (defun cc (exp)
	   (match (closure-convert exp () () () 0)
		  [e1 _ nlets]
		  (let max-tos (vector 1)
			   (begin
					(vector-set! max-tos 0 0)
			        (let code (compile e1 () () nlets max-tos [['exit nlets]])
						code)))))
)
