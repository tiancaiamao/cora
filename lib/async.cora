(import "cora/lib/sys")
(@import "cora/lib/io" io)
(@import "cora/lib/net" net)
(@import "cora/lib/queue" queue)
(@import "cora/lib/hash" hash)

(set '.task-queue (queue.make))
(set '.enqueue (lambda (x) (queue.enqueue .task-queue x)))
(set '.dequeue (lambda () (queue.dequeue .task-queue)))

(set '.block-queue (hash.make 64))
(defun .add-blocked-queue (fd val)
  (hash.set! .block-queue fd val))
(defun .remove-blocked-queue (fd)
  (hash.set! .block-queue fd Nil))
(defun .blocked-queue-empty? ()
  (= 0 (hash.count .block-queue)))
(defun .find-blocked-by-fd (fd)
  (hash.get .block-queue fd))

(func .recv-handler
      [fd buf pos] k => (begin
			 ;; (display "run in recv-handler")
			 (match (net.recv fd buf pos)
				[block pos] (begin
					     (.add-blocked-queue fd ['Blocked ['Recv fd buf pos] k])
					     ;; (display "recv-handler block and go to scheduler\n")
					     (.schedule))
				;; (display "finish schedule in recv-handler")
				res (k res))))

(func .send-handler
      [fd buf pos] k => (match (net.send fd buf pos)
			       [block pos] (begin
					    (.add-blocked-queue fd ['Blocked ['Send fd buf pos] k])
					    ;; (display "send-handler block and go to schedule\n")
					    (.schedule)
					    ;; (display "finish send-handler")
					    ))
      _ k => (io.display "wrong argument for send-handler\n"))

(defun .accept-handler (ln k)
  (begin
   (net.accept-1 ln)
   ;; (display "before accept handle go to schedule")
   ;; (display ln)
   (schedule)
   (io.display "finish schedule\n")))

(defun .yield-handler (cc)
  (begin
   (.enqueue cc)
   (let task (.dequeue)
	(task ()))))

(defun .spawn-handler (fn k)
  (begin
   (.enqueue k)
   (run fn)))

(defun run (main)
  (begin
   (try main .trap-in-handler)
   (.schedule)))

(func .trap-in-handler
      ['Spawn . data] k =>  (.spawn-handler data k)
      ['Yield] k => (.yield-handler k)
      ['Send . data] k =>  (.send-handler data k)
      ['Accept . data] k =>  (.accept-handler data k)
      ['Recv . data] k => (.recv-handler data k)
      _ k => (error "wrong type of trap in"))

(defun .schedule ()
  (if (not (queue.empty? .task-queue)) ;; running-queue
      (begin
       ;; (display "handle running queue...")
       (let task (.dequeue)
	    (task ())))
      (if (.blocked-queue-empty?)
	  (io.display "no more task, exit!\n") ;; no more task
	  (let ready-fds (net.poll)
	       (if (null? ready-fds)
		   (io.display "no more task, exit!\n") ;; no more task
		   (begin
		    (for-each (lambda (fd)
				(begin
				 (match (.find-blocked-by-fd fd)
					['Send fd buf pos k] (.send-handler [fd buf pos] k)
					['Recv fd buf pos k] (.recv-handler [fd buf pos] k)
					['Accept fd k] (k (net.accept-2 fd))
					_ (error "don't know how to handle task?"))
				 (.remove-blocked-queue fd)))
			      ready-tasks)
		    (.schedule)))))))

;; (defun accept-loop (ln)
;;   (yield fd (eff 'Accept ln)
;;          (yield _ (eff 'Spawn (lambda (_)
;;                                 (handle-conn fd)))
;;                 (accept-loop ln))))

;; (defun handle-conn (fd)
;;   (yield v (eff 'Send [fd "hello world" 0])
;;          (let buf (make-buffer 11)
;;               (yield _ (eff 'Recv [fd buf 0])
;;                      (begin
;;                       (display buf)
;;                       (net.close fd))))))

;; (defun client-main (_)
;;   (let fd (net.dial "127.0.0.1:8080")
;;        buf (make-buffer 11)
;;        (yield v (eff 'Recv [fd buf 0])
;;               (begin
;;                (display buf)
;;                (yield v (eff 'Send [fd "hello arthur" 0])
;;                       (net.close fd))))))

;; (defun server-main (_)
;;   (let ln (net.listen "127.0.0.1:8080")
;;        (accept-loop ln)))

;; (run server-main)
;; (run client-main)
