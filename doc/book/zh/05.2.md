# 柯里化

cora 是会执行自动柯里化(curryping)的语言。

也就是说，当我们定义 (lambda (a b c) ...) 和 (lambda (a) (lambda (b) (lambda (c) ...)，两者是完全等价的。

柯里化的好处是代码不用关心参数多一个少一个，写起来更自由。像 Haskell 就是自动柯里化的。而 scheme 由是需要精确的参数匹配。

经常有一些递归函数，会引入一些辅助参数。一个约定俗成的写法是，把辅助参数放在函数参数的最前面的位置。

比如前面的 filter 函数

```
(func filter-h
	acc fn [] => (reverse acc)
	acc fn [hd . tl] => (if (fn hd)
						(filter-h [hd . acc] fn tl)
						(filter-h acc fn tl)))
```

使用 (filter-h ()) 就可以自动当 filter 函数使用。因为 cora 支持了柯里化，可以不必

```
(defun filter (fn l)
	(filter-h () fn l))
```

而是直接

```
(set 'filter (filter-h ()))
```

柯里化这个选择也有代价，比如说，一门语言如果支持了自动柯里化，那么它就无法支持可变参数了。背后的原因是如果同时支持自动柯里化和可变长参数，则语法的解释就会出现歧义。像 scheme 和 clojure 都是选择了支持可变参数。在 scheme 语言中，可以

```
(+ 1 2 3 4 5)
```

而 cora 中，则只能

```
(+ 1 (+ 2 (+ 3 (+ 4 5))))
(+ (+ (+ (+ 1 2) 3) 4) 5)
```

另外一个缺点是，支持自动柯里化会带来一定的性能开销，每次函数调用都需要增加额外的检测，判断参数数量是否匹配。如果匹配则是执行函数体，如果不匹配则是自动生成一个闭包。

如果从性能的角度出发，一门语言选择不自动柯里化其实是更好的。原因是，真实的代码场景，绝大多数情况下函数的参数都是匹配的，于是可以避开不必要的检查而提升性能。对于需要柯里化的场景，由用户去手动处理一下，比如 (curry f)，虽然便利程度降低，但是是完全可接受的。


## links
   * [目录](<SUMMARY.md>)
   * 下一节: [partial apply](<05.3.md>)
