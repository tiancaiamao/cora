# 尾递归

上一节中我们的 fact 函数的实现，它不是尾递归形式的。

```
fact(5)
	=> fact(4)
		=> fact(3)
			=> fact(2)
				=> fact(1)
					=> fact(0)
					fact(1) <=
				fact(2) <=
			fact(3) <=
		fact(4) <=
	fact(5) <=
```

=> 表示调用，<= 表示返回。为了计算 fact(5)，fact 函数会调用 fact(4)，然后 fact(4) 会调用 fact(3)，一直会调用到 fact(0)，之后 fact(0) 会把结果返回到 fact(1)，然后 fact(1) 会把结果返回到 fact(2) ... 最终到 fact(5) 之后程序返回。

尾递归的函数，只会调用，而不会返回到调用者。将 fact 写成尾递归写法：

```
(defun fact (n)
	(fact-h n 1))
	
(func fact-h
	0 acc => acc
	n acc => (fact-h (- n 1) (* acc n)))
```

这种写法中 fact(5) 的计算过程如下：

```
fact(5)
	=> fact-h(5, 1)
		=> fact-h(4, 5)
			=> fact-h(3, 20)
				=> fact-h(2, 60)
					=> fact-h(1, 120)
						=> 120
```

在新的写法中，我们引入了一个额外和参数 acc，它即是参数又是返回值，它的初始值是 1，中间的计算结果都会放在 acc 里面，直到最终返回 120。

尾递归的写法通常会更高效，它是直接等效于迭代写法的，在支持尾递归优化的语言中，尾递归的写法不会导致调用栈的增长。cora 语言是支持了尾递归优化的。

再看一个例子：

```
(func plus
	x 0 => x
	x y => (+ 1 (plus x (- y 1))))
```

这是一个非尾递归的函数，如果我们传入很大的 x y，在有些语言中程序会出现栈溢出。
读者可以试着把它改成一个尾递归的实现作为练习。

## links
   * [目录](<SUMMARY.md>)
   * 下一节: [树型递归](<03.3.md>)
