# 求值规则

reader 在读取 (a b c) 之后，得到的就是 (a b c) 这样的 sexp，它是数据而不是代码。

接下来，eval 过程会把这个数据当作代码，来解释它的语义。求值的方式是先求值 a，再求值 b，再求值 c，把 b 和 c 的求值结果当作参数应用到函数 a。

如果我们要执行后生成 (a b c) 这样的链表，该怎么写？应该写成 ['a 'b 'c]。

[] 会用于生成链表，'a 'b 'c 求值后生成符号 a b c。于是整个 ['a 'b 'c] 求值后的结果就正好是 (a b c)，跟 reader 读取字面值 (a b c) 得到的链表是一样的。

这个链表的规范型 [(* 8 9) (+ 46 89) (- 67 43)] 是什么样的？

首先，我们要对 (* 8 9) 求值，得到链表的第一个元素：

(* 8 9) => 72

然后是对 (+ 46 89) 求值:

(+ 46 89) => 135

最后是对 (- 67 43) 求值:

(- 67 43) => 24

于是最终的结果是 [72 135 24]

再看一些例子:

[[1]] => ((1))
['tom 'dick 'harry] => (tom dick harry)
[(+ 1 2) [(+ 2 3)]] => (3 (5))
[(+ 34 34) [(* 7 8) "foobar" [(- 9 8)]]] => (72 (56 "foobar" (1)))
(let a 3 b 5 c 7 [a b c]) => (3 5 7)

小括号 () 是要被求值的，而大括号 [] 在 cora 中是用于表示链表，当两者混合使用时，需要区分哪些地方求值，哪些不用。

除了 [] 写法之后，还有另外一种写法是使用反引号 `，这也是一个 reader 宏，会被转换成 backquote。

`(a b c) 等价于 (backquote (a b c))

backquote 相当于对被引用的链表中的每个符号，自动加上 quote，让它是表示 symbol 而不是变量。

`(a b c) => (a b c)
['a 'b 'c] => (a b c)
[a b c] => 对 a b c 变量求值出错

backquote 可以和 unquote 结合一起使用：

(let a 3 `(a ,a)) => (a 3)

在 backquote 里面的 unquote 会抵消掉 quote 效果，于是后面的那个 a 会求值得到 3。

当 backquote 和 unquote 嵌套多层之后，代码会很乱很难读，看不清到底哪些是求值，哪些是不求值的。所以写代码时要注意克制地使用。
[] 和 () 混用则更不容易破坏可读性，因为求值规则更明确，() 里面的就是求值的。这种混用不受 "它是第几次被 backquote 和 unquote" 的影响。然而 [] 里面的符号需要加上 quote，又会让写法繁杂一些。最终用户需要取舍去决定怎么样的写法更合适。

一般在实现宏的时候，会使用到 backquote，而平时 [] 是使用更多的。

## links
   * [目录](<SUMMARY.md>)
   * 下一节: [构建链表](<04.2.md>)
