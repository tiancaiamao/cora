(set '*macros* ())

(defun add-to-*macros* (n v)
  (set '*macros* (cons (cons n v) *macros*)))

(defun undef-macro (x)
  (set '*macros* (undef-macro-h () *macros* x)))

(func undef-macro-h
      res [(cons m y) . macros] x => (undef-macro-h res macros x) where (= m x)
      res [macro . macros] x => (undef-macro-h (cons macro res) macros x)
      res [] x => res)

(set '*protect-symbol* (gensym 'protect))

(defun protect (x)
  (cons *protect-symbol* x))

(func macroexpand
      (cons x y) => y where (= x *protect-symbol*)
      (cons x y) => (let exp1 (macroexpand1 (cons x y))
                      (if (= exp1 (cons x y))
                          (map macroexpand exp1)
                          (macroexpand exp1)))
      x => x)

(defun macroexpand1 (exp)
  (macroexpand1-h exp *macros*))

(func macroexpand1-h
      [x . y] [(cons m fn) . macros] => (fn [x . y]) where (= m x)
      input [_ . macros] => (macroexpand1-h input macros)
      input [] => input)

(func defmacro-macro
  ['defmacro name arg body] => ['add-to-*macros* ['quote name] ['lambda (protect arg) body]])

(add-to-*macros* 'defmacro defmacro-macro)

(defmacro defun (exp)
  (list 'set (list 'quote (cadr exp))
        (list 'lambda (caddr exp)
              (cadddr exp))))

(defmacro or (exp)
  (cond
   ((= (cadr exp) true) true)
   ((= (caddr exp) true) true)
   ((not (null? (cdddr exp))) (list '#or (cadr exp) (cons 'or (cddr exp))))
   (true (cons '#or (cdr exp)))))

(defmacro let (exp)
  (rewrite-let () () (cdr exp)))

(defmacro list (exp)
  (rcons (cdr exp)))

(defmacro list-rest (exp)
  (rcons1 (cdr exp)))

(defmacro match (exp)
  (match-helper (cadr exp) (cddr exp)))

(defmacro func (exp)
  (let body (extract-rules (cddr exp))
    (let nargs (rules-arg-count body)
      (let args (gen-parameters nargs)
        (list 'defun (cadr exp) args
              (cons 'match (cons (cons 'list args)
                                 body)))))))

(macroexpand '(func fact
      0 => 1
      n => (* n (fact (- n 1)))))
