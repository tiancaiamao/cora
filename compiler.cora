(defun builtin? (x)
  (elem? x '(+ - * / = set halt)))

(defun cps-protect? (x)
  (or (number? x) (string? x) (boolean? x) (symbol? x)
      (and (pair? x) (= (car x) 'quote))))

(func cps
      lit cc => [cc lit] where (cps-protect? lit)
      ['if a b c] cc => (let va (gensym 'r)
                          (cps a ['lambda [va]
                                   ['if va
                                        (cps b cc)
                                        (cps c cc)]]))
      ['do x y] cc => (cps x ['lambda ['_] (cps y cc)])
      ['lambda args body] cc => (let k (gensym 'k)
                                  [cc ['lambda (cons k args)
                                        (cps body k)]])
      [['lambda [] body] []] cc =>  (cps body cc)
      [['lambda [x] body] a] cc => (cps a ['lambda [x] (cps body cc)])
      [['lambda [x y] body] a b] cc => (cps a ['lambda [x]
                                                (cps b ['lambda [y]
                                                         (cps body cc)])])
      [op . args] cc => (cps-args []
                                  (lambda (nargs) [cc (cons op nargs)])
                                  args) where (builtin? op)
      [f . args] cc => (if (symbol? f)
                           (cps-args []
                                     (lambda (nargs) (cons f (cons cc nargs)))
                                     args)
                           (let f0 (gensym 'f)
                             (let cc1 (cps-args []
                                                (lambda (nargs) (cons f0 (cons cc nargs)))
                                                args)
                               (cps f ['lambda [f0]
                                        cc1])))))

(func cps-args
      res fn [] => (fn (reverse res))
      res fn [x . y] => (cps-args (cons x res) fn y) where (cps-protect? x)
      res fn [x . y] => (let x0 (gensym 'arg)
                             (cps x ['lambda [x0]
                                  (cps-args (cons x0 res)
                                            fn y)])))

(defun cps-convert (ast)
  (cps ast '(lambda (x) (halt x))))

(func parse
      _ x => ['%const x] where (or (number? x) (string? x) (boolean? x))
      _ ['quote x] => ['quote x]
      env x => (if (elem? x env) x ['%global x]) where (symbol? x)
      env ['lambda args body] => ['lambda args (parse (append args env) body)]
      env ['if . args] => ['if . (map (parse env) args)]
      env [op . args] => [['%builtin op] . (map (parse env) args)] where (builtin? op)
      env ls => (map (parse env) ls))

(func union
      [] s2 => s2
      [x . y] s2 => (union y s2) where (elem? x s2)
      [x . y] s2 => (cons x (union y s2)))

(func diff
      [] _ => []
      [x . y] s2 => (diff y s2) where (elem? x s2)
      [x . y] s2 => (cons x (diff y s2)))

(func foldl
      f acc [] => acc
      f acc [x . y] => (foldl f (f acc x) y))

(func convert-protect?
      ['%const x] => true
      ['%global x] => true
      ['%builtin op] => true
      ['quote x] => true
      x => false)

(func free-vars
      x => [] where (convert-protect? x)
      x => [x] where (symbol? x)
      ['lambda args body] => (diff (free-vars body) args)
      [if x y z] => (foldl union [] (map free-vars [x y z]))
      [f . args] => (foldl union [] (map free-vars [f . args])))

(func pos-in-list0
      _ x [] => -1
      pos x [a . b] => pos where (= x a)
      pos x [a . b] => (pos-in-list0 (+ pos 1) x b))

(defun pos-in-list (x l)
  (pos-in-list0 0 x l))

(func convert
      _ _ x => x where (convert-protect? x)
      self fvs var => (let pos (pos-in-list var fvs)
                        (if (= -1 pos)
                            var
                            ['%closure-ref self pos])) where (symbol? var)
      self fvs ['if a b c] => (cons 'if (map (convert self fvs) [a b c]))
      self fvs ['lambda args body] =>
      (let fvs1 (free-vars ['lambda args body])
           self1 (gensym 'clo)
           ['%closure ['lambda (cons self1 args) (convert self1 fvs1 body)] . fvs1])
      self fvs [['lambda params body] . args] => [['lambda params (convert self fvs body)] . (map (convert self fvs) args)]
      self fvs [['%builtin f] . args] => [['%builtin f] . (map (convert self fvs) args)]
      self fvs [f . args] => (let f0 (convert self fvs f)
                                  args0 (map (convert self fvs) args)
                                  [['%closure-func f0] f0 . args0]))

(func collect-lambda
      res ['if a b c] return => (collect-lambda-list [] res [a b c]
                                                     (lambda (res ls)
                                                       (return res (cons 'if ls))))
      res ['lambda params body] return =>
      (let name (gensym 'clofun)
        (collect-lambda res body
                        (lambda (res1 body1)
                          (return (cons [name ['lambda params body1]] res1)
                                  name))))
      res [['lambda params body] . args] return =>
      (collect-lambda res body (lambda (res1 body1)
                                 (collect-lambda-list [] res1 args
                                                      (lambda (res2 args1)
                                                        (return res2 [['lambda params body1] . args1])))))
      res ['%closure lam . fvs] return => (collect-lambda res lam
                                                          (lambda (res1 name)
                                                            (return res1 ['%closure name . fvs])))
      res [f . args] return => (collect-lambda-list [] res args
                                                    (lambda (res1 args1)
                                                      (return res1 (cons f args1))))
      res x return => (return res x))

(func collect-lambda-list
      res init [] return => (return init (reverse res))
      res init [x . y] return => (collect-lambda init x
                                                 (lambda (init1 x1)
                                                   (collect-lambda-list (cons x1 res) init1 y return))))

(defun closure-convert-debug (ast)
  (convert '_ [] (parse [] ast)))

(defun closure-convert (ast)
  (let res (convert '_ [] (parse [] ast))
    (collect-lambda [] res
                    (lambda (res1 ast1)
                      (cons [(gensym 'clofun) ['lambda () ast1]] res1)))))

(func assq
      var [] => ()
      var [(cons x y) . _] => (cons x y) where (= var x)
      var [_ . y] => (assq var y))

(func code-gen
      bc mp ['%const x] return => (let reg (gensym 'reg)
                          (return (cons ['const x reg] bc)
                                  (cons (cons x reg) mp)
                                  reg)) where (number? x)
      bc mp var return => (let find (assq var mp)
                            (if (null? find)
                                (let reg (gensym 'reg)
                                  (return (cons ['mov var reg] bc)
                                          (cons (cons var reg) mp)
                                          reg))
                                (return bc mp (cdr find)))) where (symbol? var)
      bc mp ['if x y z] return =>
      (code-gen bc mp x
                (lambda (bc1 mp1 r1)
                  (code-gen [] mp1 y
                            (lambda (bcy mp2 r2)
                              (code-gen [] mp2 z
                                        (lambda (bcz mp3 r3)
                                          (let reg (gensym 'reg)
                                            (return (cons ['if r1 (reverse bcy)
                                                               (reverse bcz)] bc) mp3 reg))))))))
      bc mp [['lambda params body] . args] return =>
      (code-gen-args [] bc mp args
                     (lambda (bc1 mp1 reg-list)
                       (code-gen bc1
                                 (code-gen-prepare params reg-list mp1) body return)))
      bc mp ['lambda params body] return =>
      (code-gen-params 0 bc mp params
                       (lambda (bc1 mp1)
                         (code-gen bc1 mp1 body return)))
      bc mp ['halt x] return => (code-gen bc mp x
                                          (lambda (bc1 mp1 reg)
                                            (return (cons ['halt] (cons ['stack-set 0 reg] bc1))
                                                    mp1
                                                    reg)))
      bc mp ['quote x] return => (let reg (gensym 'reg)
                                   (return (cons ['intern x reg] bc) mp reg))
      bc mp ['%global x] return => (let reg (gensym 'reg)
                                     (return (cons ['global x reg] bc) mp reg))
      bc mp [['%builtin op] x] return => (code-gen bc mp x
                                                   (lambda (bc1 mp1 x1)
                                                     (let reg (gensym 'reg)
                                                       (return (cons ['builtin [op x1] reg] bc1)
                                                               mp1 reg))))
      bc mp [['%builtin op] x y] return =>
      (code-gen bc mp x
                (lambda (bc1 mp1 r1)
                  (code-gen bc1 mp1 y
                            (lambda (bc2 mp2 r2)
                              (let reg (gensym 'reg)
                                (return (cons ['builtin [op r1 r2] reg] bc2) mp2
                                        reg))))))
      bc mp ['%closure func . args] return =>
      (code-gen-args [] bc mp args
                     (lambda (bc1 mp1 reg-list)
                       (let reg (gensym 'reg)
                         (return (cons ['closure [func . reg-list] reg] bc1)
                                 mp1
                                 reg))))
      bc mp ['%closure-func clo] return => (code-gen bc mp clo
                                              (lambda (bc1 mp1 reg)
                                                (return (cons ['savepc reg] bc1) mp1 reg)))
      bc mp ['%closure-ref clo n] return => (code-gen bc mp clo
                                                      (lambda (bc1 mp1 r1)
                                                        (let reg (gensym 'reg)
                                                          (return
                                                           (cons ['closure-get r1 n reg] bc1)
                                                           mp1
                                                           reg))))
      bc mp [f . args] return =>
      (code-gen-args [] bc mp [f . args]
                     (lambda (bc1 mp1 reg-list)
                       (code-gen-call 0 (cdr reg-list) bc1 mp1
                                      (lambda (bc2 mp2)
                                        (return (cons ['jump] bc2) mp2 (gensym 'reg)))))))

(func code-gen-call
      idx [] bc mp return => (return bc mp)
      idx [x . y] bc mp return => (code-gen-call (+ idx 1)
                                                 y
                                                 (cons ['stack-set idx x] bc)
                                                 mp
                                                 return))

(func code-gen-prepare
      [] [] mp => mp
      [var . vars] [reg . regs] mp => (code-gen-prepare vars regs (cons (cons var reg) mp)))

(func code-gen-args
      regs bc mp [] return => (return bc mp (reverse regs))
      regs bc mp [x . y] return => (code-gen bc mp x
                                             (lambda (bc1 mp1 r1)
                                               (code-gen-args (cons r1 regs) bc1 mp y return))))

(func code-gen-params
      idx bc mp [] return => (return bc mp)
      idx bc mp [x . y] return => (let reg (gensym 'reg)
                                    (code-gen-params (+ idx 1)
                                                     (cons ['stack-get idx reg] bc)
                                                     (cons [x . reg] mp)
                                                     y return)))

(defun code-generate-debug (ast)
  (code-gen [] [] ast
            (lambda (bc mp reg)
              (reverse bc))))

(defun code-generate (inputs)
  (map (lambda (x)
         (let bc (code-generate-debug (cadr x))
           (cons ['label (car x)] bc)))
       inputs))



;; (code-gen [] [] 42 (lambda (bc mp reg) 444))
;; (code-gen [] [] 'a (lambda (bc mp reg) bc))
;; (code-gen [] [] '(if a 4 c) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(+ a 3) (lambda (bc mp reg) bc))
;; (code-gen [] [] '((lambda (a b) (+ a b)) 3 5) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(lambda (a b) (+ a b)) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(f a b) (lambda (bc mp reg) bc))


;; (cps-convert '(do
;;                   (set 'square (lambda (x) (* x x)))
;;                   (+ (square 5) 1)))


;; (set '%closure list)
;; (defun %closure-func (x) (list-ref x 0))
;; (defun %closure-ref (x n) (list-ref x (+ n 1)))
;; (defun %global (x) x)
;; (defun %builtin (x) x)
;; (defun %const (x) x)

;; (closure-convert '((lambda (#arg4118) ((lambda (_) ((lambda (#f4065) (#f4065 (lambda (#arg4038) (halt (+ #arg4038 1))) 5)) square)) (set (quote square) #arg4118))) (lambda (#k4138 x) (#k4138 (* x x)))))


;; (code-generate '((#clofun35259 (lambda () ((lambda (#arg4118) ((lambda (_) ((lambda (#f4065) ((%closure-func #f4065) #f4065 (%closure #clofun35155) 5)) square)) (set (quote square) #arg4118))) (%closure #clofun35255)))) (#clofun35255 (lambda (#clo34911 #k4138 x) ((%closure-func #k4138) #k4138 (* x x)))) (#clofun35155 (lambda (#clo34666 #arg4038) (halt (+ #arg4038 1))))))
