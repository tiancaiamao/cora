(defun builtin? (x)
  (elem? x '(+ - * / = set halt)))

(defun non-evaluate? (lit)
  (or (symbol? lit) (string? lit) (number? lit) (boolean? lit)))

(func cps
      lit cc => [cc lit] where (non-evaluate? lit)
      ['quote x] cc => [cc ['quote x]]
      ['if a b c] cc => (let va (gensym 'r)
                             (cps a ['lambda [va]
                                             ['if va
                                                 (cps b cc)
                                                 (cps c cc)]]))
      ['do x y] cc => (cps x ['lambda ['_] (cps y cc)])
      ['lambda args body] cc => (let k (gensym 'k)
                                     [cc ['lambda (cons k args)
                                                  (cps body k)]])
      [['lambda [] body] []] cc =>  (cps body cc)
      [['lambda [x] body] a] cc => (cps a ['lambda [x] (cps body cc)])
      [['lambda [x y] body] a b] cc => (cps a ['lambda [x]
                                                (cps b ['lambda [y]
                                                                (cps body cc)])])
      [op . args] cc => (cps-args []
                                  (lambda (nargs) [cc (cons op nargs)])
                                  args) where (builtin? op)
      [f . args] cc => (let f0 (gensym 'f)
                            (let cc1 (cps-args []
                                               (lambda (nargs) (cons f0 (cons cc nargs)))
                                               args)
                                 (cps f ['lambda [f0]
                                                 cc1]))))

(func cps-args
      res fn [] => (fn (reverse res))
      res fn [x . y] => (cps-args (cons x res) fn y) where (or (symbol? x) (non-evaluate? x))
      res fn [['quote x] . y] => (cps-args (cons ['quote x] res) fn y)
      res fn [x . y] => (let x0 (gensym 'arg)
                             (cps x ['lambda [x0]
                                  (cps-args (cons x0 res)
                                            fn y)])))

(defun cps-convert (ast)
  (cps ast 'halt))

(func union
      [] s2 => s2
      [x . y] s2 => (union y s2) where (elem? x s2)
      [x . y] s2 => (cons x (union y s2)))

(func diff
      [] _ => []
      [x . y] s2 => (diff y s2) where (elem? x s2)
      [x . y] s2 => (cons x (diff y s2)))

(func foldl
      f acc [] => acc
      f acc [x . y] => (foldl f (f acc x) y))

(func free-vars
      x => [] where (or (number? x) (string? x) (boolean? x))
      x => [] where (builtin? x)
      x => [x] where (symbol? x)
      ['lambda args body] => (diff (free-vars body) args)
      [f . args] => (foldl union [] (map free-vars [f . args])))

(func pos-in-list0
      _ x [] => -1
      pos x [a . b] => pos where (= x a)
      pos x [a . b] => (pos-in-list0 (+ pos 1) x b))

(defun pos-in-list (x l)
  (pos-in-list0 0 x l))

(func convert
      self fvs x => x where (or (number? x) (string? x) (boolean? x))
      _ _ ['quote x] => ['quote x]
      self fvs var => (let pos (pos-in-list var fvs)
                           (if (= -1 pos)
                               var
                             ['%closure-ref self pos])) where (symbol? var)
      self fvs ['if a b c] => (cons 'if (map (convert self fvs) [a b c]))
      self fvs ['lambda args body] =>
      (let fvs1 (free-vars ['lambda args body])
           self1 (gensym 'clo)
           ['%closure ['lambda (cons self1 args) (convert self1 fvs1 body)] . fvs1])
      self fvs [['lambda params body] . args] => [['lambda params (convert self fvs body)] . (map (convert self fvs) args)]
      self fvs [f . args] => [f . (map (convert self fvs) args)] where (builtin? f)
      self fvs [f . args] => (let f0 (convert self fvs f)
                                  args0 (map (convert self fvs) args)
                                  [['%closure-func f0] f0 . args0]))

(defun closure-convert (ast)
  (convert '_ [] ast))

;; (cps-convert '(do
;;                   (set 'square (lambda (x) (* x x)))
;;                   (+ (square 5) 1)))


;; (set '%closure list)
;; (defun %closure-func (x) (list-ref x 0))

;; (closure-convert '((lambda (#arg4118) ((lambda (_) ((lambda (#f4065) (#f4065 (lambda (#arg4038) (halt (+ #arg4038 1))) 5)) square)) (set (quote square) #arg4118))) (lambda (#k4138 x) (#k4138 (* x x)))))

(func assq
      var [] => ()
      var [(cons x y) . _] => (cons x y) where (= var x)
      var [_ . y] => (assq var y))

(func code-gen
      bc mp x return => (let reg (gensym 'reg)
                          (return (cons ['<- reg x] bc)
                                  (cons (cons x reg) mp)
                                  reg)) where (number? x)
      bc mp var return => (let find (assq var mp)
                                    reg (gensym 'reg)
                                    (if (null? find)
                                        (return (cons ['<- reg var] bc)
                                                (cons (cons var reg) mp)
                                                reg)
                                        (return bc mp reg))) where (symbol? var)
      bc mp ['if x y z] return =>
      (code-gen bc mp x
                (lambda (bc1 mp1 r1)
                  (code-gen bc1 mp1 y
                            (lambda (bc2 mp2 r2)
                              (code-gen bc2 mp2 z
                                        (lambda (bc3 mp3 r3)
                                          (let reg (gensym 'reg)
                                            (return (cons ['<- reg 'if r1 r2 r3] bc3) mp3 reg))))))))
      bc mp [['lambda params body] . args] return =>
      (code-gen-args [] bc mp args
                     (lambda (bc1 mp1 reg-list)
                       (code-gen bc1
                                 (code-gen-prepare params reg-list mp1) body return)))
      bc mp ['lambda params body] return =>
      (code-gen-params 0 bc mp params
                       (lambda (bc1 mp1)
                         (code-gen bc1 mp1 body return)))
      bc mp [op x y] return =>
      (code-gen bc mp x
                (lambda (bc1 mp1 r1)
                  (code-gen bc1 mp1 y
                            (lambda (bc2 mp2 r2)
                              (let reg (gensym 'reg)
                                (return (cons ['<- reg [op r1 r2]] bc2) mp2
                                        reg)))))) where (builtin? op)
      bc mp [f . args] return =>
      (code-gen-args [] bc mp args
                     (lambda (bc1 mp1 reg-list)
                       (code-gen-call 0 reg-list bc1 mp1
                                      (lambda (bc2 mp2)
                                        (return (cons 'jump bc2) mp2 (gensym 'reg)))))))

(func code-gen-call
      idx [] bc mp return => (return bc mp)
      idx [x . y] bc mp return => (code-gen-call (+ idx 1)
                                                 y
                                                 (cons ['<- 'stack idx x] bc)
                                                 mp
                                                 return))

(func code-gen-prepare
      [] [] mp => mp
      [var . vars] [reg . regs] mp => (code-gen-prepare vars regs (cons (cons var reg) mp)))

(func code-gen-args
      regs bc mp [] return => (return bc mp regs)
      regs bc mp [x . y] return => (code-gen bc mp x
                                             (lambda (bc1 mp1 r1)
                                               (code-gen-args (cons r1 regs) bc1 mp y return))))

(func code-gen-params
      idx bc mp [] return => (return bc mp)
      idx bc mp [x . y] return => (let reg (gensym 'reg)
                                    (code-gen-params (+ idx 1)
                                                     (cons ['<- 'stack idx reg] bc)
                                                     (cons [x . reg] mp)
                                                     y return)))

(defun code-generate (ast)
  (code-gen [] [] '_ ast
            (lambda (bc mp reg)
              bc)))

;; (code-gen [] [] 42 (lambda (bc mp reg) 444))
;; (code-gen [] [] 'a (lambda (bc mp reg) bc))
;; (code-gen [] [] '(if a 4 c) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(+ a 3) (lambda (bc mp reg) bc))
;; (code-gen [] [] '((lambda (a b) (+ a b)) 3 5) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(lambda (a b) (+ a b)) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(f a b) (lambda (bc mp reg) bc))
