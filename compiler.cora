(func assq
      var [] => ()
      var [(cons x y) . _] => (cons x y) where (= var x)
      var [_ . y] => (assq var y))

(func beta-replace
      env s => (let find (assq s env)
                 (if (= () find) s (cdr find))) where (symbol? s)
      env [['lambda [v] body] x] => (beta-replace (cons (cons v x) env) body) where (symbol? x)
      env ['lambda args body] => (let nenv (filter (lambda (x) (elem? (car x) args)) env)
                                  ['lambda args (beta-replace env body)])
      env ['if x y z] => (cons 'if (map (beta-replace env) [x y z]))
      env ['quote x] => ['quote x]
      env [x . y] => (map (beta-replace env) [x . y])
      env x => x)

(defun simplify (exp)
  (beta-replace () (propagate-boolean exp)))

;; update the macroexpand function, add the simplify phase
(defun macroexpand (exp)
  (simplify (propagate-boolean (macroexpand-boot exp))))

;; (defmacro cond (exp)
;;   (if (= () (cdr exp))
;;       ['error "no cond match"]
;;       (let curr (cadr exp)
;;            ['if (car curr)
;;            (cadr curr)
;;            (cons 'cond (cddr exp))])))

;; (func and-macro
;;       ['and true true] => true
;;       ['and false _] => false
;;       ['and _ false] => false
;;       ['and x y] => ['if x y false])

;; (defmacro and (exp)
;;   (and-macro exp))

;; begin x y z ...
;; (do x (do y z))
(func rewrite-begin
      [x] => x
      [x y] => ['do x y]
      [x . y] => ['do x (rewrite-begin y)])

(defmacro begin (exp)
  (rewrite-begin (cdr exp)))

(defun builtin? (x)
  (elem? x '(+ - * / = set halt car cdr cons cons?)))

(func parse
      _ x => ['%const x] where (or (number? x) (string? x) (boolean? x) (null? x))
      _ ['quote x] => ['%const x]
      env x => (if (elem? x env) x ['%global x]) where (symbol? x)
      env ['lambda args body] => ['lambda args (parse (append args env) body)]
      env ['if . args] => ['if . (map (parse env) args)]
      env [op . args] => [['%builtin op] . (map (parse env) args)] where (builtin? op)
      env ls => (map (parse env) ls))

(func union
      [] s2 => s2
      [x . y] s2 => (union y s2) where (elem? x s2)
      [x . y] s2 => (cons x (union y s2)))

(func diff
      [] _ => []
      [x . y] s2 => (diff y s2) where (elem? x s2)
      [x . y] s2 => (cons x (diff y s2)))

(func foldl
      f acc [] => acc
      f acc [x . y] => (foldl f (f acc x) y))

(func convert-protect?
      ['%const x] => true
      ['%global x] => true
      ['%builtin op] => true
      ['quote x] => true
      x => false)

(func free-vars
      x => [] where (convert-protect? x)
      x => [x] where (symbol? x)
      ['lambda args body] => (diff (free-vars body) args)
      [if x y z] => (foldl union [] (map free-vars [x y z]))
      [f . args] => (foldl union [] (map free-vars [f . args])))

(func pos-in-list0
      _ x [] => -1
      pos x [a . b] => pos where (= x a)
      pos x [a . b] => (pos-in-list0 (+ pos 1) x b))

(defun pos-in-list (x l)
  (pos-in-list0 0 x l))

(func convert
      _ _ x => x where (convert-protect? x)
      self fvs var => (let pos (pos-in-list var fvs)
                           (if (= -1 pos)
                               var
                               ['%closure-ref self pos])) where (symbol? var)
      self fvs ['if a b c] => (cons 'if (map (convert self fvs) [a b c]))
      self fvs ['lambda args body] =>
      (let fvs1 (free-vars ['lambda args body])
           self1 (gensym 'clo)
           ['%closure ['lambda (cons self1 args) (convert self1 fvs1 body)] .
          (map (convert self fvs) fvs1)])
      self fvs [['lambda params body] . args] => [['lambda params (convert self fvs body)] . (map (convert self fvs) args)]
      self fvs [['%builtin f] . args] => [['%builtin f] . (map (convert self fvs) args)]
      self fvs [f . args] => (let f0 (convert self fvs f)
                                  args0 (map (convert self fvs) args)
                                  [f0 . args0]))

(func collect-lambda
      res ['if a b c] return => (collect-lambda-list [] res [a b c]
                                                     (lambda (res1 ls)
                                                       (return res1 (cons 'if ls))))
      res ['lambda params body] return =>
      (let name (gensym 'clofun)
           (collect-lambda res body
                           (lambda (res1 body1)
                             (return (cons [name ['lambda params body1]] res1)
                                     name))))
      res [['lambda params body] . args] return =>
      (collect-lambda res body (lambda (res1 body1)
                                 (collect-lambda-list [] res1 args
                                                      (lambda (res2 args1)
                                                        (return res2 [['lambda params body1] . args1])))))
      res ['%closure lam . fvs] return => (collect-lambda res lam
                                                          (lambda (res1 name)
                                                            (return res1 ['%closure name . fvs])))
      res [f . args] return => (collect-lambda-list [] res args
                                                    (lambda (res1 args1)
                                                      (return res1 (cons f args1))))
      res x return => (return res x))

(func collect-lambda-list
      res init [] return => (return init (reverse res))
      res init [x . y] return => (collect-lambda init x
                                                 (lambda (init1 x1)
                                                   (collect-lambda-list (cons x1 res) init1 y return))))

(defun closure-convert-debug (ast)
  (convert '_ [] (parse [] ast)))

(defun closure-convert (ast)
  (let res (convert '_ [] (parse [] ast))
       (collect-lambda [] res
                       (lambda (res1 ast1)
                         (cons [(gensym 'clofun) ['lambda () ast1]] res1)))))

(func return
      false bc reg cc => (cc bc reg)
      true bc reg cc => (cc (cons ['%return reg] bc) '_))

(func code-gen
      bc tail ['%const x] cc => (let reg (gensym 'reg)
                                     (return tail (cons ['%const x reg] bc) reg cc))
      bc tail ['%closure fn . captured] cc => (let reg (gensym 'reg)
                                                   (return tail (cons ['%closure reg fn . captured] bc) reg cc))
      bc tail ['%closure-ref clo idx] cc => (let reg (gensym 'reg)
                                              (return tail (cons ['%closure-ref reg clo idx] bc) reg cc))
      bc tail x cc => (return tail bc x cc) where (symbol? x)
      bc tail ['if x y z] cc =>
      (code-gen bc false x (lambda (bc1 r1)
                             (code-gen [] tail y (lambda (bcy r2)
                                                   (code-gen [] tail z (lambda (bcz r3)
                                                                         (if tail
                                                                             (cc (cons ['if r1 (reverse bcy) (reverse bcz)] bc1) '_)
                                                                           (let reg (gensym 'reg)
                                                                                (let bc2 (cons [$declare Reg] bc1)
                                                                                     (let bcy1 (reverse (cons ['mov r2 reg] bcy))
                                                                                          (let bcz1 (reverse (cons ['mov r3 reg] bcz))
                                                                                               (let bc3 (cons ['if r1 bcy1 bcz1] bc2)
                                                                                                    (cc bc3 reg)))))))))))))
      bc tail ['do x y] cc => (code-gen bc false x (lambda (bc1 x1)
                                                     (code-gen (cons ['mov x1 _] bc1) tail y cc)))
      bc tail [f . args] cc => (code-gen-list [] bc args (lambda (bc1 reglist)
                                                           (let reg (gensym 'reg)
                                                                (let bc2 (code-gen-call bc1 tail f reglist reg)
                                                                     (cc bc2 (if tail '_ reg)))))))

(func code-gen-list
      regs bc [] cc => (cc bc (reverse regs))
      regs bc [x . y] cc => (code-gen bc false x (lambda (bc1 r1)
                                                   (code-gen-list [r1 . regs] bc1 y cc))))

;; (code-gen-list [] [] '(x (%const 0)))

(func code-gen-call
  bc tail ['%builtin f] args reg => (let x (cons ['%builtin f args reg] bc)
                                         (if tail (cons ['%return reg] x) x))
  bc false ['%global f] args reg => (cons ['%call-def f args reg] bc)
  bc true ['%global f] args reg => (cons ['%tailcall-def f args] bc)
  bc false f args reg => (cons ['%call f args reg] bc)
  bc true f args reg => (cons ['%tailcall f args] bc))

(func code-gen-lambda
      ['lambda args body] => (code-gen [] true body
                                       (lambda (bc reg)
                                         (reverse (if (= '_ reg) bc (cons ['%return reg] bc))))))

(defun code-generate (inputs)
  (map (lambda (x)
         (let lmd (cadr x)
              (let args (cadr lmd)
                   (let bc (code-gen-lambda lmd)
                        ['label (car x) args . bc]))))
       inputs))

;; (code-gen [] [] 42 (lambda (bc mp reg) 444))
;; (code-gen [] [] 'a (lambda (bc mp reg) bc))
;; (code-gen [] [] '(if a 4 c) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(+ a 3) (lambda (bc mp reg) bc))
;; (code-gen [] [] '((lambda (a b) (+ a b)) 3 5) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(lambda (a b) (+ a b)) (lambda (bc mp reg) bc))
;; (code-gen [] [] '(f a b) (lambda (bc mp reg) bc))

;; (closure-convert '(set 'fact (lambda (n)
;;                                (if (= n 0)
;;                                    1
;;                                  (* n (fact (- n 1)))))))

;; (code-generate '((#clofun35259 (lambda () ((lambda (#arg4118) ((lambda (_) ((lambda (#f4065) ((%closure-func #f4065) #f4065 (%closure #clofun35155) 5)) square)) (set (quote square) #arg4118))) (%closure #clofun35255)))) (#clofun35255 (lambda (#clo34911 #k4138 x) ((%closure-func #k4138) #k4138 (* x x)))) (#clofun35155 (lambda (#clo34666 #arg4038) (halt (+ #arg4038 1))))))

;; (code-generate '((#clofun340 (lambda () ((%builtin set) (%const fact) (%closure #clofun339)))) (#clofun339 (lambda (#clo338 n) (if ((%builtin =) n (%const 0)) (%const 1) ((%builtin *) n ((%global fact) ((%builtin -) n (%const 1)))))))))

(defun compile (x)
  (let lam (closure-convert x)
       (let bc (code-generate lam)
            bc)))

(defun compile-file (file)
  (let sexp (read-file-as-sexp file)
       (let bc (compile sexp)
            (generate-c "gen.c" bc))))

