(func cps
      lit cc => [cc lit] where (or (symbol? lit) (string? lit) (number? lit) (boolean? lit))
      ['if a b c] cc => (let va (gensym 'r)
                             (cps a ['lambda [va]
                                             ['if va
                                                 (cps b cc)
                                                 (cps c cc)]]))
      ['do x y] cc => (cps x ['lambda ['_] (cps y cc)])
      ['lambda args body] cc => (let k (gensym 'k)
                                     [cc ['lambda (cons k args)
                                                  (cps body k)]])
      [['lambda [] body] []] cc =>  (cps body cc)
      [['lambda [x] body] a] cc => (cps a ['lambda [x] (cps body cc)])
      [['lambda [x y] body] a b] cc => (cps a ['lambda [x]
                                                (cps b ['lambda [y]
                                                                (cps body cc)])])
      [op . args] cc => (cps-args []
                                  (lambda (nargs) [cc (cons op nargs)])
                                  args) where (elem? op ['+ '- '* '/ '=])
      [f . args] cc => (let f0 (gensym 'f)
                            (let cc1 (cps-args []
                                               (lambda (nargs) (cons f0 (cons cc args)))
                                               args)
                                 (cps f ['lambda [f0]
                                                 cc1]))))

(func cps-args
      res fn [] => (fn (reverse res))
      res fn [x . y] => (let x0 (gensym 'arg)
                                (cps x ['lambda [x0]
                                       (cps-args (cons x0 res)
                                                 fn y)])))

(defun cps-convert (ast)
  (cps ast 'halt))

(func union
      [] s2 => s2
      [x . y] s2 => (union y s2) where (elem? x s2)
      [x . y] s2 => (cons x (union y s2)))

(func diff
      [] _ => []
      [x . y] s2 => (diff y s2) where (elem? x s2)
      [x . y] s2 => (cons x (diff y s2)))

(func foldl
      f acc [] => acc
      f acc [x . y] => (foldl f (f acc x) y))

(func free-vars
      x => [] where (or (number? x) (string? x) (boolean? x))
      x => [] where (elem? x '(+ - * / =))
      x => [x] where (symbol? x)
      ['lambda args body] => (diff (free-vars body) args)
      [f . args] => (foldl union [] (map free-vars [f . args])))

(func pos-in-list0
      _ x [] => -1
      pos x [a . b] => pos where (= x a)
      pos x [a . b] => (pos-in-list0 (+ pos 1) x b))

(defun pos-in-list (x l)
  (pos-in-list0 0 x l))

(func convert
      self fvs x => x where (or (number? x) (string? x) (boolean? x))
      self fvs var => (let pos (pos-in-list var fvs)
                           (if (= -1 pos)
                               var
                             ['%closure-ref self pos])) where (symbol? var)
      self fvs ['if a b c] => (cons 'if (map (convert self fvs) [a b c]))
      self fvs ['lambda args body] =>
      (let fvs1 (free-vars ['lambda args body])
           self1 (gensym 'clo)
           ['closure ['lambda (cons self1 args) (convert self1 fvs1 body)] . fvs1])
      self fvs [f . args] => (map (convert self fvs) [f . args]))

(defun closure-convert (ast)
  (convert '_ [] ast))


(closure-convert '(lambda (x) (lambda (y) (+ x y))))
