(defun shen.shen () (do (shen.credits) (shen.loop)))

(set shen.*continue-repl-loop* true)

(defun exit (V305) (set shen.*continue-repl-loop* false))

(defun shen.loop () (do (shen.initialise_environment) (do (shen.prompt) (do (trap-error (shen.read-evaluate-print) (lambda E (pr (error-to-string E) (stoutput)))) (if (value shen.*continue-repl-loop*) (shen.loop) exit)))))

(defun shen.credits () (do (shen.prhush "Cora, my own lisp!
" (stoutput)) (do (shen.prhush "Inspired by the awesome Shen language.
" (stoutput)) (shen.prhush "Copyright (C) 2018 Arthur Mao <tiancaiamao@gmail.com>
" (stoutput)))))

(defun shen.initialise_environment () (shen.multiple-set (cons shen.*call* (cons 0 (cons shen.*infs* (cons 0 (cons shen.*process-counter* (cons 0 (cons shen.*catch* (cons 0 ()))))))))))

(defun shen.multiple-set (V307) (cond ((= () V307) ()) ((and (cons? V307) (cons? (tl V307))) (do (set (hd V307) (hd (tl V307))) (shen.multiple-set (tl (tl V307))))) (true (shen.f_error shen.multiple-set))))

(defun destroy (V309) (declare V309 symbol))

(set shen.*history* ())

(defun shen.read-evaluate-print () (let Lineread (shen.toplineread) (let History (value shen.*history*) (let NewLineread (shen.retrieve-from-history-if-needed Lineread History) (let NewHistory (shen.update_history NewLineread History) (let Parsed (fst NewLineread) (shen.toplevel Parsed)))))))

(defun shen.retrieve-from-history-if-needed (V321 V322) (cond ((and (tuple? V321) (and (cons? (snd V321)) (element? (hd (snd V321)) (cons (shen.space) (cons (shen.newline) ()))))) (shen.retrieve-from-history-if-needed (@p (fst V321) (tl (snd V321))) V322)) ((and (tuple? V321) (and (cons? (snd V321)) (and (cons? (tl (snd V321))) (and (= () (tl (tl (snd V321)))) (and (cons? V322) (and (= (hd (snd V321)) (shen.exclamation)) (= (hd (tl (snd V321))) (shen.exclamation)))))))) (let PastPrint (shen.prbytes (snd (hd V322))) (hd V322))) ((and (tuple? V321) (and (cons? (snd V321)) (= (hd (snd V321)) (shen.exclamation)))) (let Key? (shen.make-key (tl (snd V321)) V322) (let Find (head (shen.find-past-inputs Key? V322)) (let PastPrint (shen.prbytes (snd Find)) Find)))) ((and (tuple? V321) (and (cons? (snd V321)) (and (= () (tl (snd V321))) (= (hd (snd V321)) (shen.percent))))) (do (shen.print-past-inputs (lambda X true) (reverse V322) 0) (abort))) ((and (tuple? V321) (and (cons? (snd V321)) (= (hd (snd V321)) (shen.percent)))) (let Key? (shen.make-key (tl (snd V321)) V322) (let Pastprint (shen.print-past-inputs Key? (reverse V322) 0) (abort)))) (true V321)))

(defun shen.percent () 37)

(defun shen.exclamation () 33)

(defun shen.prbytes (V324) (do (for-each (lambda Byte (pr (n->string Byte) (stoutput))) V324) (nl 1)))

(defun shen.update_history (V327 V328) (set shen.*history* (cons V327 V328)))

(defun shen.toplineread () (shen.toplineread_loop (read-char-code (stinput)) ()))

(defun shen.toplineread_loop (V332 V333) (cond ((and (= -1 V332) (= () V333)) (exit 0)) ((= V332 (shen.hat)) (simple-error "line read aborted")) ((element? V332 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X (shen.<st_input> X)) V333 (lambda E shen.nextline)) (let It (shen.record-it V333) (if (or (= Line shen.nextline) (empty? Line)) (shen.toplineread_loop (read-char-code (stinput)) (append V333 (cons V332 ()))) (@p Line V333))))) (true (shen.toplineread_loop (read-char-code (stinput)) (if (= V332 -1) V333 (append V333 (cons V332 ())))))))

(defun shen.hat () 94)

(defun shen.newline () 10)

(defun shen.carriage-return () 13)

(defun tc (V339) (cond ((= + V339) (set shen.*tc* true)) ((= - V339) (set shen.*tc* false)) (true (simple-error "tc expects a + or -"))))

(defun shen.prompt () (if (value shen.*tc*) (shen.prhush (cn "

(" (shen.app (length (value shen.*history*)) "+) " shen.a)) (stoutput)) (shen.prhush (cn "

(" (shen.app (length (value shen.*history*)) "-) " shen.a)) (stoutput))))

(defun shen.toplevel (V341) (shen.toplevel_evaluate V341 (value shen.*tc*)))

(defun shen.find-past-inputs (V344 V345) (let F (shen.find V344 V345) (if (empty? F) (simple-error "input not found
") F)))

(defun shen.make-key (V348 V349) (let Atom (hd (compile (lambda X (shen.<st_input> X)) V348 (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
"))))) (if (integer? Atom) (lambda X (= X (nth (+ Atom 1) (reverse V349)))) (lambda X (shen.prefix? V348 (shen.trim-gubbins (snd X)))))))

(defun shen.trim-gubbins (V351) (cond ((and (cons? V351) (= (hd V351) (shen.space))) (shen.trim-gubbins (tl V351))) ((and (cons? V351) (= (hd V351) (shen.newline))) (shen.trim-gubbins (tl V351))) ((and (cons? V351) (= (hd V351) (shen.carriage-return))) (shen.trim-gubbins (tl V351))) ((and (cons? V351) (= (hd V351) (shen.tab))) (shen.trim-gubbins (tl V351))) ((and (cons? V351) (= (hd V351) (shen.left-round))) (shen.trim-gubbins (tl V351))) (true V351)))

(defun shen.space () 32)

(defun shen.tab () 9)

(defun shen.left-round () 40)

(defun shen.find (V360 V361) (cond ((= () V361) ()) ((and (cons? V361) (V360 (hd V361))) (cons (hd V361) (shen.find V360 (tl V361)))) ((cons? V361) (shen.find V360 (tl V361))) (true (shen.f_error shen.find))))

(defun shen.prefix? (V375 V376) (cond ((= () V375) true) ((and (cons? V375) (and (cons? V376) (= (hd V376) (hd V375)))) (shen.prefix? (tl V375) (tl V376))) (true false)))

(defun shen.print-past-inputs (V388 V389 V390) (cond ((= () V389) _) ((and (cons? V389) (not (V388 (hd V389)))) (shen.print-past-inputs V388 (tl V389) (+ V390 1))) ((and (cons? V389) (tuple? (hd V389))) (do (shen.prhush (shen.app V390 ". " shen.a) (stoutput)) (do (shen.prbytes (snd (hd V389))) (shen.print-past-inputs V388 (tl V389) (+ V390 1))))) (true (shen.f_error shen.print-past-inputs))))

(defun shen.toplevel_evaluate (V393 V394) (cond ((and (cons? V393) (and (cons? (tl V393)) (and (= : (hd (tl V393))) (and (cons? (tl (tl V393))) (and (= () (tl (tl (tl V393)))) (= true V394)))))) (shen.typecheck-and-evaluate (hd V393) (hd (tl (tl V393))))) ((and (cons? V393) (cons? (tl V393))) (do (shen.toplevel_evaluate (cons (hd V393) ()) V394) (do (nl 1) (shen.toplevel_evaluate (tl V393) V394)))) ((and (cons? V393) (and (= () (tl V393)) (= true V394))) (shen.typecheck-and-evaluate (hd V393) (gensym A))) ((and (cons? V393) (and (= () (tl V393)) (= false V394))) (let Eval (shen.eval-without-macros (hd V393)) (print Eval))) (true (shen.f_error shen.toplevel_evaluate))))

(defun shen.typecheck-and-evaluate (V397 V398) (let Typecheck (shen.typecheck V397 V398) (if (= Typecheck false) (simple-error "type error
") (let Eval (shen.eval-without-macros V397) (let Type (shen.pretty-type Typecheck) (shen.prhush (shen.app Eval (cn " : " (shen.app Type "" shen.r)) shen.s) (stoutput)))))))

(defun shen.pretty-type (V400) (shen.mult_subst (value shen.*alphabet*) (shen.extract-pvars V400) V400))

(defun shen.extract-pvars (V406) (cond ((shen.pvar? V406) (cons V406 ())) ((cons? V406) (union (shen.extract-pvars (hd V406)) (shen.extract-pvars (tl V406)))) (true ())))

(defun shen.mult_subst (V414 V415 V416) (cond ((= () V414) V416) ((= () V415) V416) ((and (cons? V414) (cons? V415)) (shen.mult_subst (tl V414) (tl V415) (subst (hd V414) (hd V415) V416))) (true (shen.f_error shen.mult_subst))))

