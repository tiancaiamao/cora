(defun shen.shen->kl (V419 V420) (compile (lambda X (shen.<define> X)) (cons V419 V420) (lambda X (shen.shen-syntax-error V419 X))))

(defun shen.shen-syntax-error (V427 V428) (cond ((cons? V428) (simple-error (cn "syntax error in " (shen.app V427 (cn " here:

 " (shen.app (shen.next-50 50 (hd V428)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V427 "
" shen.a))))))

(defun shen.<define> (V430) (let YaccParse (let Parse_shen.<name> (shen.<name> V430) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V430) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V432) (if (cons? (hd V432)) (let Parse_X (hd (hd V432)) (shen.pair (hd (shen.pair (tl (hd V432)) (shen.hdtl V432))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V434) (element? V434 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V436) (if (and (cons? (hd V436)) (= { (hd (hd V436)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V436)) (shen.hdtl V436))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V438) (cond ((and (cons? V438) (and (cons? (tl V438)) (and (= --> (hd (tl V438))) (and (cons? (tl (tl V438))) (and (cons? (tl (tl (tl V438)))) (= --> (hd (tl (tl (tl V438)))))))))) (shen.curry-type (cons (hd V438) (cons --> (cons (tl (tl V438)) ()))))) ((and (cons? V438) (and (cons? (tl V438)) (and (= * (hd (tl V438))) (and (cons? (tl (tl V438))) (and (cons? (tl (tl (tl V438)))) (= * (hd (tl (tl (tl V438)))))))))) (shen.curry-type (cons (hd V438) (cons * (cons (tl (tl V438)) ()))))) ((cons? V438) (map (lambda Z (shen.curry-type Z)) V438)) (true V438)))

(defun shen.<signature-help> (V440) (let YaccParse (if (cons? (hd V440)) (let Parse_X (hd (hd V440)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V440)) (shen.hdtl V440))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V440) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V442) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V442) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V442) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V444) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V444) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V444) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V444) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V444) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V447 V448) (if (V447 V448) (fail) V448))

(defun shen.succeeds? (V454) (cond ((= V454 (fail)) false) (true true)))

(defun shen.<patterns> (V456) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V456) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V456) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V463) (let YaccParse (if (and (cons? (hd V463)) (cons? (hd (hd V463)))) (if (and (cons? (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (= @p (hd (hd (shen.pair (hd (hd V463)) (hd (tl V463))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (shen.hdtl (shen.pair (hd (hd V463)) (hd (tl V463)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V463)) (hd (tl V463)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V463)) (cons? (hd (hd V463)))) (if (and (cons? (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (= cons (hd (hd (shen.pair (hd (hd V463)) (hd (tl V463))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (shen.hdtl (shen.pair (hd (hd V463)) (hd (tl V463)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V463)) (hd (tl V463)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V463)) (cons? (hd (hd V463)))) (if (and (cons? (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (= @v (hd (hd (shen.pair (hd (hd V463)) (hd (tl V463))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (shen.hdtl (shen.pair (hd (hd V463)) (hd (tl V463)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V463)) (hd (tl V463)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V463)) (cons? (hd (hd V463)))) (if (and (cons? (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (= @s (hd (hd (shen.pair (hd (hd V463)) (hd (tl V463))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (shen.hdtl (shen.pair (hd (hd V463)) (hd (tl V463)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V463)) (hd (tl V463)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V463)) (cons? (hd (hd V463)))) (if (and (cons? (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (= vector (hd (hd (shen.pair (hd (hd V463)) (hd (tl V463))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (shen.hdtl (shen.pair (hd (hd V463)) (hd (tl V463))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V463)) (hd (tl V463))))) (shen.hdtl (shen.pair (hd (hd V463)) (hd (tl V463))))))))) (shen.pair (hd (shen.pair (tl (hd V463)) (hd (tl V463)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V463)) (let Parse_X (hd (hd V463)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V463)) (shen.hdtl V463))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V463) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V465) (simple-error (shen.app V465 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V467) (let YaccParse (if (cons? (hd V467)) (let Parse_X (hd (hd V467)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V467)) (shen.hdtl V467))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V467)) (let Parse_X (hd (hd V467)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V467)) (shen.hdtl V467))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V469) (let Parse_shen.<pattern> (shen.<pattern> V469) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V471) (let Parse_shen.<pattern> (shen.<pattern> V471) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V473) (if (cons? (hd V473)) (let Parse_X (hd (hd V473)) (shen.pair (hd (shen.pair (tl (hd V473)) (shen.hdtl V473))) Parse_X)) (fail)))

(defun shen.<guard> (V475) (if (cons? (hd V475)) (let Parse_X (hd (hd V475)) (shen.pair (hd (shen.pair (tl (hd V475)) (shen.hdtl V475))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V478 V479) (let Lambda+ (shen.compile_to_lambda+ V478 V479) (let KL (shen.compile_to_kl V478 Lambda+) (let Record (shen.record-source V478 KL) KL))))

(defun shen.record-source (V484 V485) (cond ((value shen.*installing-kl*) shen.skip) (true (put V484 shen.source V485 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V488 V489) (let Arity (shen.aritycheck V488 V489) (let UpDateSymbolTable (shen.update-symbol-table V488 Arity) (let Free (for-each (lambda Rule (shen.free_variable_check V488 Rule)) V489) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V489) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V492 V493) (cond ((= 0 V493) shen.skip) (true (put V492 shen.lambda-form (eval-kl (shen.lambda-form V492 V493)) (value *property-vector*)))))

(defun shen.free_variable_check (V496 V497) (cond ((and (cons? V497) (and (cons? (tl V497)) (= () (tl (tl V497))))) (let Bound (shen.extract_vars (hd V497)) (let Free (shen.extract_free_vars Bound (hd (tl V497))) (shen.free_variable_warnings V496 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V499) (cond ((variable? V499) (cons V499 ())) ((cons? V499) (union (shen.extract_vars (hd V499)) (shen.extract_vars (tl V499)))) (true ())))

(defun shen.extract_free_vars (V511 V512) (cond ((and (cons? V512) (and (cons? (tl V512)) (and (= () (tl (tl V512))) (= (hd V512) protect)))) ()) ((and (variable? V512) (not (element? V512 V511))) (cons V512 ())) ((and (cons? V512) (and (= lambda (hd V512)) (and (cons? (tl V512)) (and (cons? (tl (tl V512))) (= () (tl (tl (tl V512)))))))) (shen.extract_free_vars (cons (hd (tl V512)) V511) (hd (tl (tl V512))))) ((and (cons? V512) (and (= let (hd V512)) (and (cons? (tl V512)) (and (cons? (tl (tl V512))) (and (cons? (tl (tl (tl V512)))) (= () (tl (tl (tl (tl V512)))))))))) (union (shen.extract_free_vars V511 (hd (tl (tl V512)))) (shen.extract_free_vars (cons (hd (tl V512)) V511) (hd (tl (tl (tl V512))))))) ((cons? V512) (union (shen.extract_free_vars V511 (hd V512)) (shen.extract_free_vars V511 (tl V512)))) (true ())))

(defun shen.free_variable_warnings (V517 V518) (cond ((= () V518) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V517 (cn ": " (shen.app (shen.list_variables V518) "" shen.a)) shen.a))))))

(defun shen.list_variables (V520) (cond ((and (cons? V520) (= () (tl V520))) (cn (str (hd V520)) ".")) ((cons? V520) (cn (str (hd V520)) (cn ", " (shen.list_variables (tl V520))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V522) (cond ((and (cons? V522) (and (cons? (tl V522)) (and (= () (tl (tl V522))) (= (hd V522) protect)))) (shen.strip-protect (hd (tl V522)))) ((cons? V522) (map (lambda Z (shen.strip-protect Z)) V522)) (true V522)))

(defun shen.linearise (V524) (cond ((and (cons? V524) (and (cons? (tl V524)) (= () (tl (tl V524))))) (shen.linearise_help (shen.flatten (hd V524)) (hd V524) (hd (tl V524)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V526) (cond ((= () V526) ()) ((cons? V526) (append (shen.flatten (hd V526)) (shen.flatten (tl V526)))) (true (cons V526 ()))))

(defun shen.linearise_help (V530 V531 V532) (cond ((= () V530) (cons V531 (cons V532 ()))) ((cons? V530) (if (and (variable? (hd V530)) (element? (hd V530) (tl V530))) (let Var (gensym (hd V530)) (let NewAction (cons where (cons (cons = (cons (hd V530) (cons Var ()))) (cons V532 ()))) (let NewPatts (shen.linearise_X (hd V530) Var V531) (shen.linearise_help (tl V530) NewPatts NewAction)))) (shen.linearise_help (tl V530) V531 V532))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V545 V546 V547) (cond ((= V547 V545) V546) ((cons? V547) (let L (shen.linearise_X V545 V546 (hd V547)) (if (= L (hd V547)) (cons (hd V547) (shen.linearise_X V545 V546 (tl V547))) (cons L (tl V547))))) (true V547)))

(defun shen.aritycheck (V550 V551) (cond ((and (cons? V551) (and (cons? (hd V551)) (and (cons? (tl (hd V551))) (and (= () (tl (tl (hd V551)))) (= () (tl V551)))))) (do (shen.aritycheck-action (hd (tl (hd V551)))) (shen.aritycheck-name V550 (arity V550) (length (hd (hd V551)))))) ((and (cons? V551) (and (cons? (hd V551)) (and (cons? (tl (hd V551))) (and (= () (tl (tl (hd V551)))) (and (cons? (tl V551)) (and (cons? (hd (tl V551))) (and (cons? (tl (hd (tl V551)))) (= () (tl (tl (hd (tl V551)))))))))))) (if (= (length (hd (hd V551))) (length (hd (hd (tl V551))))) (do (shen.aritycheck-action (hd (tl (hd V551)))) (shen.aritycheck V550 (tl V551))) (simple-error (cn "arity error in " (shen.app V550 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V564 V565 V566) (cond ((= -1 V565) V566) ((= V566 V565) V566) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V564 " can cause errors.
" shen.a)) (stoutput)) V566))))

(defun shen.aritycheck-action (V572) (cond ((cons? V572) (do (shen.aah (hd V572) (tl V572)) (for-each (lambda Y (shen.aritycheck-action Y)) V572))) (true shen.skip)))

(defun shen.aah (V575 V576) (let Arity (arity V575) (let Len (length V576) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V575 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V578) (cond ((and (cons? V578) (and (cons? (tl V578)) (= () (tl (tl V578))))) (shen.abstraction_build (hd V578) (hd (tl V578)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V581 V582) (cond ((= () V581) V582) ((cons? V581) (cons /. (cons (hd V581) (cons (shen.abstraction_build (tl V581) V582) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V584) (cond ((= 0 V584) ()) (true (cons (gensym V) (shen.parameters (- V584 1))))))

(defun shen.application_build (V587 V588) (cond ((= () V587) V588) ((cons? V587) (shen.application_build (tl V587) (cons V588 (cons (hd V587) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V591 V592) (cond ((and (cons? V592) (and (cons? (tl V592)) (= () (tl (tl V592))))) (let Arity (shen.store-arity V591 (length (hd V592))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V592))) (let CondExpression (shen.cond-expression V591 (hd V592) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V591) (hd V592)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V592) TypeTable CondExpression) CondExpression) (cons defun (cons V591 (cons (hd V592) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V598) (cond ((cons? V598) shen.skip) (true (let FType (assoc V598 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V609 V610) (cond ((and (cons? V609) (and (cons? (tl V609)) (and (= --> (hd (tl V609))) (and (cons? (tl (tl V609))) (and (= () (tl (tl (tl V609)))) (cons? V610)))))) (if (variable? (hd V609)) (shen.typextable (hd (tl (tl V609))) (tl V610)) (cons (cons (hd V610) (hd V609)) (shen.typextable (hd (tl (tl V609))) (tl V610))))) (true ())))

(defun shen.assign-types (V614 V615 V616) (cond ((and (cons? V616) (and (= let (hd V616)) (and (cons? (tl V616)) (and (cons? (tl (tl V616))) (and (cons? (tl (tl (tl V616)))) (= () (tl (tl (tl (tl V616)))))))))) (cons let (cons (hd (tl V616)) (cons (shen.assign-types V614 V615 (hd (tl (tl V616)))) (cons (shen.assign-types (cons (hd (tl V616)) V614) V615 (hd (tl (tl (tl V616))))) ()))))) ((and (cons? V616) (and (= lambda (hd V616)) (and (cons? (tl V616)) (and (cons? (tl (tl V616))) (= () (tl (tl (tl V616)))))))) (cons lambda (cons (hd (tl V616)) (cons (shen.assign-types (cons (hd (tl V616)) V614) V615 (hd (tl (tl V616)))) ())))) ((and (cons? V616) (= cond (hd V616))) (cons cond (map (lambda Y (cons (shen.assign-types V614 V615 (hd Y)) (cons (shen.assign-types V614 V615 (hd (tl Y))) ()))) (tl V616)))) ((cons? V616) (let NewTable (shen.typextable (shen.get-type (hd V616)) (tl V616)) (cons (hd V616) (map (lambda Y (shen.assign-types V614 (append V615 NewTable) Y)) (tl V616))))) (true (let AtomType (assoc V616 V615) (if (cons? AtomType) (cons type (cons V616 (cons (tl AtomType) ()))) (if (element? V616 V614) V616 (shen.atom-type V616)))))))

(defun shen.atom-type (V618) (if (string? V618) (cons type (cons V618 (cons string ()))) (if (number? V618) (cons type (cons V618 (cons number ()))) (if (boolean? V618) (cons type (cons V618 (cons boolean ()))) (if (symbol? V618) (cons type (cons V618 (cons symbol ()))) V618)))))

(defun shen.store-arity (V623 V624) (cond ((value shen.*installing-kl*) shen.skip) (true (put V623 arity V624 (value *property-vector*)))))

(defun shen.reduce (V626) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V626) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V628) (cond ((and (cons? V628) (and (cons? (hd V628)) (and (= /. (hd (hd V628))) (and (cons? (tl (hd V628))) (and (cons? (hd (tl (hd V628)))) (and (= cons (hd (hd (tl (hd V628))))) (and (cons? (tl (hd (tl (hd V628))))) (and (cons? (tl (tl (hd (tl (hd V628)))))) (and (= () (tl (tl (tl (hd (tl (hd V628))))))) (and (cons? (tl (tl (hd V628)))) (and (= () (tl (tl (tl (hd V628))))) (and (cons? (tl V628)) (= () (tl (tl V628))))))))))))))) (do (shen.add_test (cons cons? (tl V628))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V628))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V628)))))) (cons (shen.ebr (hd (tl V628)) (hd (tl (hd V628))) (hd (tl (tl (hd V628))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V628)) ())) (cons (cons tl (tl V628)) ())) (shen.reduce_help Application))))) ((and (cons? V628) (and (cons? (hd V628)) (and (= /. (hd (hd V628))) (and (cons? (tl (hd V628))) (and (cons? (hd (tl (hd V628)))) (and (= @p (hd (hd (tl (hd V628))))) (and (cons? (tl (hd (tl (hd V628))))) (and (cons? (tl (tl (hd (tl (hd V628)))))) (and (= () (tl (tl (tl (hd (tl (hd V628))))))) (and (cons? (tl (tl (hd V628)))) (and (= () (tl (tl (tl (hd V628))))) (and (cons? (tl V628)) (= () (tl (tl V628))))))))))))))) (do (shen.add_test (cons tuple? (tl V628))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V628))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V628)))))) (cons (shen.ebr (hd (tl V628)) (hd (tl (hd V628))) (hd (tl (tl (hd V628))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V628)) ())) (cons (cons snd (tl V628)) ())) (shen.reduce_help Application))))) ((and (cons? V628) (and (cons? (hd V628)) (and (= /. (hd (hd V628))) (and (cons? (tl (hd V628))) (and (cons? (hd (tl (hd V628)))) (and (= @v (hd (hd (tl (hd V628))))) (and (cons? (tl (hd (tl (hd V628))))) (and (cons? (tl (tl (hd (tl (hd V628)))))) (and (= () (tl (tl (tl (hd (tl (hd V628))))))) (and (cons? (tl (tl (hd V628)))) (and (= () (tl (tl (tl (hd V628))))) (and (cons? (tl V628)) (= () (tl (tl V628))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V628))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V628))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V628)))))) (cons (shen.ebr (hd (tl V628)) (hd (tl (hd V628))) (hd (tl (tl (hd V628))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V628)) ())) (cons (cons tlv (tl V628)) ())) (shen.reduce_help Application))))) ((and (cons? V628) (and (cons? (hd V628)) (and (= /. (hd (hd V628))) (and (cons? (tl (hd V628))) (and (cons? (hd (tl (hd V628)))) (and (= @s (hd (hd (tl (hd V628))))) (and (cons? (tl (hd (tl (hd V628))))) (and (cons? (tl (tl (hd (tl (hd V628)))))) (and (= () (tl (tl (tl (hd (tl (hd V628))))))) (and (cons? (tl (tl (hd V628)))) (and (= () (tl (tl (tl (hd V628))))) (and (cons? (tl V628)) (= () (tl (tl V628))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V628))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V628))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V628)))))) (cons (shen.ebr (hd (tl V628)) (hd (tl (hd V628))) (hd (tl (tl (hd V628))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V628)) (cons 0 ()))) ())) (cons (cons tlstr (tl V628)) ())) (shen.reduce_help Application))))) ((and (cons? V628) (and (cons? (hd V628)) (and (= /. (hd (hd V628))) (and (cons? (tl (hd V628))) (and (cons? (tl (tl (hd V628)))) (and (= () (tl (tl (tl (hd V628))))) (and (cons? (tl V628)) (and (= () (tl (tl V628))) (not (variable? (hd (tl (hd V628))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V628))) (tl V628)))) (shen.reduce_help (hd (tl (tl (hd V628))))))) ((and (cons? V628) (and (cons? (hd V628)) (and (= /. (hd (hd V628))) (and (cons? (tl (hd V628))) (and (cons? (tl (tl (hd V628)))) (and (= () (tl (tl (tl (hd V628))))) (and (cons? (tl V628)) (= () (tl (tl V628)))))))))) (shen.reduce_help (shen.ebr (hd (tl V628)) (hd (tl (hd V628))) (hd (tl (tl (hd V628))))))) ((and (cons? V628) (and (= where (hd V628)) (and (cons? (tl V628)) (and (cons? (tl (tl V628))) (= () (tl (tl (tl V628)))))))) (do (shen.add_test (hd (tl V628))) (shen.reduce_help (hd (tl (tl V628)))))) ((and (cons? V628) (and (cons? (tl V628)) (= () (tl (tl V628))))) (let Z (shen.reduce_help (hd V628)) (if (= (hd V628) Z) V628 (shen.reduce_help (cons Z (tl V628)))))) (true V628)))

(defun shen.+string? (V630) (cond ((= "" V630) false) (true (string? V630))))

(defun shen.+vector? (V632) (and (absvector? V632) (> (<-address V632 0) 0)))

(defun shen.ebr (V646 V647 V648) (cond ((= V648 V647) V646) ((and (cons? V648) (and (= /. (hd V648)) (and (cons? (tl V648)) (and (cons? (tl (tl V648))) (and (= () (tl (tl (tl V648)))) (> (occurrences V647 (hd (tl V648))) 0)))))) V648) ((and (cons? V648) (and (= lambda (hd V648)) (and (cons? (tl V648)) (and (cons? (tl (tl V648))) (and (= () (tl (tl (tl V648)))) (> (occurrences V647 (hd (tl V648))) 0)))))) V648) ((and (cons? V648) (and (= let (hd V648)) (and (cons? (tl V648)) (and (cons? (tl (tl V648))) (and (cons? (tl (tl (tl V648)))) (and (= () (tl (tl (tl (tl V648))))) (= (hd (tl V648)) V647))))))) (cons let (cons (hd (tl V648)) (cons (shen.ebr V646 (hd (tl V648)) (hd (tl (tl V648)))) (tl (tl (tl V648))))))) ((cons? V648) (cons (shen.ebr V646 V647 (hd V648)) (shen.ebr V646 V647 (tl V648)))) (true V648)))

(defun shen.add_test (V650) (set shen.*teststack* (cons V650 (value shen.*teststack*))))

(defun shen.cond-expression (V654 V655 V656) (let Err (shen.err-condition V654) (let Cases (shen.case-form V656 Err) (let EncodeChoices (shen.encode-choices Cases V654) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V660) (cond ((and (cons? V660) (and (cons? (hd V660)) (and (= true (hd (hd V660))) (and (cons? (tl (hd V660))) (= () (tl (tl (hd V660)))))))) (hd (tl (hd V660)))) (true (cons cond V660))))

(defun shen.encode-choices (V665 V666) (cond ((= () V665) ()) ((and (cons? V665) (and (cons? (hd V665)) (and (= true (hd (hd V665))) (and (cons? (tl (hd V665))) (and (cons? (hd (tl (hd V665)))) (and (= shen.choicepoint! (hd (hd (tl (hd V665))))) (and (cons? (tl (hd (tl (hd V665))))) (and (= () (tl (tl (hd (tl (hd V665)))))) (and (= () (tl (tl (hd V665)))) (= () (tl V665))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V665))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V666 ())) (cons shen.f_error (cons V666 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V665) (and (cons? (hd V665)) (and (= true (hd (hd V665))) (and (cons? (tl (hd V665))) (and (cons? (hd (tl (hd V665)))) (and (= shen.choicepoint! (hd (hd (tl (hd V665))))) (and (cons? (tl (hd (tl (hd V665))))) (and (= () (tl (tl (hd (tl (hd V665)))))) (= () (tl (tl (hd V665)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V665))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V665) V666)) (cons Result ())))) ())))) ())) ())) ((and (cons? V665) (and (cons? (hd V665)) (and (cons? (tl (hd V665))) (and (cons? (hd (tl (hd V665)))) (and (= shen.choicepoint! (hd (hd (tl (hd V665))))) (and (cons? (tl (hd (tl (hd V665))))) (and (= () (tl (tl (hd (tl (hd V665)))))) (= () (tl (tl (hd V665))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V665) V666)) ())) (cons (cons if (cons (hd (hd V665)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V665))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V665) (and (cons? (hd V665)) (and (cons? (tl (hd V665))) (= () (tl (tl (hd V665))))))) (cons (hd V665) (shen.encode-choices (tl V665) V666))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V673 V674) (cond ((= () V673) (cons V674 ())) ((and (cons? V673) (and (cons? (hd V673)) (and (cons? (hd (hd V673))) (and (= : (hd (hd (hd V673)))) (and (cons? (tl (hd (hd V673)))) (and (= shen.tests (hd (tl (hd (hd V673))))) (and (= () (tl (tl (hd (hd V673))))) (and (cons? (tl (hd V673))) (and (cons? (hd (tl (hd V673)))) (and (= shen.choicepoint! (hd (hd (tl (hd V673))))) (and (cons? (tl (hd (tl (hd V673))))) (and (= () (tl (tl (hd (tl (hd V673)))))) (= () (tl (tl (hd V673)))))))))))))))) (cons (cons true (tl (hd V673))) (shen.case-form (tl V673) V674))) ((and (cons? V673) (and (cons? (hd V673)) (and (cons? (hd (hd V673))) (and (= : (hd (hd (hd V673)))) (and (cons? (tl (hd (hd V673)))) (and (= shen.tests (hd (tl (hd (hd V673))))) (and (= () (tl (tl (hd (hd V673))))) (and (cons? (tl (hd V673))) (= () (tl (tl (hd V673)))))))))))) (cons (cons true (tl (hd V673))) ())) ((and (cons? V673) (and (cons? (hd V673)) (and (cons? (hd (hd V673))) (and (= : (hd (hd (hd V673)))) (and (cons? (tl (hd (hd V673)))) (and (= shen.tests (hd (tl (hd (hd V673))))) (and (cons? (tl (hd V673))) (= () (tl (tl (hd V673))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V673))))) (tl (hd V673))) (shen.case-form (tl V673) V674))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V676) (cond ((and (cons? V676) (= () (tl V676))) (hd V676)) ((cons? V676) (cons and (cons (hd V676) (cons (shen.embed-and (tl V676)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V678) (cons true (cons (cons shen.f_error (cons V678 ())) ())))

(defun shen.sys-error (V680) (simple-error (cn "system function " (shen.app V680 ": unexpected argument
" shen.a))))

