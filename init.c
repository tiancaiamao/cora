#include "types.h"
#include "runtime.h"

void entry(struct Cora* co);
void _35clofun5052(struct Cora* co);
void _35clofun5071(struct Cora* co);
void _35clofun5073(struct Cora* co);
void _35clofun5078(struct Cora* co);
void _35clofun5087(struct Cora* co);
void _35clofun5092(struct Cora* co);
void _35clofun5096(struct Cora* co);
void _35clofun5100(struct Cora* co);
void _35clofun5106(struct Cora* co);
void _35clofun5163(struct Cora* co);
void _35clofun5197(struct Cora* co);
void _35clofun5241(struct Cora* co);
void _35clofun5248(struct Cora* co);
void _35clofun5249(struct Cora* co);
void _35clofun5242(struct Cora* co);
void _35clofun5243(struct Cora* co);
void _35clofun5244(struct Cora* co);
void _35clofun5247(struct Cora* co);
void _35clofun5245(struct Cora* co);
void _35clofun5246(struct Cora* co);
void _35clofun5240(struct Cora* co);
void _35clofun5235(struct Cora* co);
void _35clofun5236(struct Cora* co);
void _35clofun5237(struct Cora* co);
void _35clofun5239(struct Cora* co);
void _35clofun5238(struct Cora* co);
void _35clofun5233(struct Cora* co);
void _35clofun5234(struct Cora* co);
void _35clofun5210(struct Cora* co);
void _35clofun5211(struct Cora* co);
void _35clofun5232(struct Cora* co);
void _35clofun5212(struct Cora* co);
void _35clofun5231(struct Cora* co);
void _35clofun5213(struct Cora* co);
void _35clofun5230(struct Cora* co);
void _35clofun5214(struct Cora* co);
void _35clofun5228(struct Cora* co);
void _35clofun5229(struct Cora* co);
void _35clofun5215(struct Cora* co);
void _35clofun5227(struct Cora* co);
void _35clofun5216(struct Cora* co);
void _35clofun5226(struct Cora* co);
void _35clofun5217(struct Cora* co);
void _35clofun5223(struct Cora* co);
void _35clofun5224(struct Cora* co);
void _35clofun5225(struct Cora* co);
void _35clofun5218(struct Cora* co);
void _35clofun5222(struct Cora* co);
void _35clofun5219(struct Cora* co);
void _35clofun5220(struct Cora* co);
void _35clofun5221(struct Cora* co);
void _35clofun5198(struct Cora* co);
void _35clofun5199(struct Cora* co);
void _35clofun5200(struct Cora* co);
void _35clofun5201(struct Cora* co);
void _35clofun5202(struct Cora* co);
void _35clofun5203(struct Cora* co);
void _35clofun5204(struct Cora* co);
void _35clofun5205(struct Cora* co);
void _35clofun5206(struct Cora* co);
void _35clofun5207(struct Cora* co);
void _35clofun5208(struct Cora* co);
void _35clofun5209(struct Cora* co);
void _35clofun5191(struct Cora* co);
void _35clofun5192(struct Cora* co);
void _35clofun5193(struct Cora* co);
void _35clofun5194(struct Cora* co);
void _35clofun5195(struct Cora* co);
void _35clofun5196(struct Cora* co);
void _35clofun5189(struct Cora* co);
void _35clofun5190(struct Cora* co);
void _35clofun5182(struct Cora* co);
void _35clofun5183(struct Cora* co);
void _35clofun5185(struct Cora* co);
void _35clofun5187(struct Cora* co);
void _35clofun5188(struct Cora* co);
void _35clofun5186(struct Cora* co);
void _35clofun5184(struct Cora* co);
void _35clofun5180(struct Cora* co);
void _35clofun5181(struct Cora* co);
void _35clofun5179(struct Cora* co);
void _35clofun5177(struct Cora* co);
void _35clofun5178(struct Cora* co);
void _35clofun5176(struct Cora* co);
void _35clofun5175(struct Cora* co);
void _35clofun5172(struct Cora* co);
void _35clofun5173(struct Cora* co);
void _35clofun5174(struct Cora* co);
void _35clofun5171(struct Cora* co);
void _35clofun5164(struct Cora* co);
void _35clofun5165(struct Cora* co);
void _35clofun5170(struct Cora* co);
void _35clofun5166(struct Cora* co);
void _35clofun5169(struct Cora* co);
void _35clofun5167(struct Cora* co);
void _35clofun5168(struct Cora* co);
void _35clofun5162(struct Cora* co);
void _35clofun5155(struct Cora* co);
void _35clofun5156(struct Cora* co);
void _35clofun5157(struct Cora* co);
void _35clofun5158(struct Cora* co);
void _35clofun5161(struct Cora* co);
void _35clofun5160(struct Cora* co);
void _35clofun5159(struct Cora* co);
void _35clofun5139(struct Cora* co);
void _35clofun5140(struct Cora* co);
void _35clofun5141(struct Cora* co);
void _35clofun5151(struct Cora* co);
void _35clofun5152(struct Cora* co);
void _35clofun5153(struct Cora* co);
void _35clofun5154(struct Cora* co);
void _35clofun5142(struct Cora* co);
void _35clofun5147(struct Cora* co);
void _35clofun5148(struct Cora* co);
void _35clofun5149(struct Cora* co);
void _35clofun5150(struct Cora* co);
void _35clofun5143(struct Cora* co);
void _35clofun5144(struct Cora* co);
void _35clofun5145(struct Cora* co);
void _35clofun5146(struct Cora* co);
void _35clofun5131(struct Cora* co);
void _35clofun5132(struct Cora* co);
void _35clofun5137(struct Cora* co);
void _35clofun5138(struct Cora* co);
void _35clofun5135(struct Cora* co);
void _35clofun5136(struct Cora* co);
void _35clofun5133(struct Cora* co);
void _35clofun5134(struct Cora* co);
void _35clofun5125(struct Cora* co);
void _35clofun5128(struct Cora* co);
void _35clofun5129(struct Cora* co);
void _35clofun5130(struct Cora* co);
void _35clofun5126(struct Cora* co);
void _35clofun5127(struct Cora* co);
void _35clofun5107(struct Cora* co);
void _35clofun5108(struct Cora* co);
void _35clofun5109(struct Cora* co);
void _35clofun5123(struct Cora* co);
void _35clofun5124(struct Cora* co);
void _35clofun5120(struct Cora* co);
void _35clofun5121(struct Cora* co);
void _35clofun5122(struct Cora* co);
void _35clofun5118(struct Cora* co);
void _35clofun5119(struct Cora* co);
void _35clofun5115(struct Cora* co);
void _35clofun5116(struct Cora* co);
void _35clofun5117(struct Cora* co);
void _35clofun5113(struct Cora* co);
void _35clofun5114(struct Cora* co);
void _35clofun5110(struct Cora* co);
void _35clofun5111(struct Cora* co);
void _35clofun5112(struct Cora* co);
void _35clofun5105(struct Cora* co);
void _35clofun5102(struct Cora* co);
void _35clofun5103(struct Cora* co);
void _35clofun5104(struct Cora* co);
void _35clofun5101(struct Cora* co);
void _35clofun5099(struct Cora* co);
void _35clofun5097(struct Cora* co);
void _35clofun5098(struct Cora* co);
void _35clofun5095(struct Cora* co);
void _35clofun5093(struct Cora* co);
void _35clofun5094(struct Cora* co);
void _35clofun5088(struct Cora* co);
void _35clofun5089(struct Cora* co);
void _35clofun5090(struct Cora* co);
void _35clofun5091(struct Cora* co);
void _35clofun5086(struct Cora* co);
void _35clofun5081(struct Cora* co);
void _35clofun5082(struct Cora* co);
void _35clofun5083(struct Cora* co);
void _35clofun5084(struct Cora* co);
void _35clofun5085(struct Cora* co);
void _35clofun5080(struct Cora* co);
void _35clofun5079(struct Cora* co);
void _35clofun5074(struct Cora* co);
void _35clofun5075(struct Cora* co);
void _35clofun5076(struct Cora* co);
void _35clofun5077(struct Cora* co);
void _35clofun5072(struct Cora* co);
void _35clofun5067(struct Cora* co);
void _35clofun5068(struct Cora* co);
void _35clofun5069(struct Cora* co);
void _35clofun5070(struct Cora* co);
void _35clofun5061(struct Cora* co);
void _35clofun5065(struct Cora* co);
void _35clofun5066(struct Cora* co);
void _35clofun5062(struct Cora* co);
void _35clofun5063(struct Cora* co);
void _35clofun5064(struct Cora* co);
void _35clofun5060(struct Cora* co);
void _35clofun5058(struct Cora* co);
void _35clofun5059(struct Cora* co);
void _35clofun5057(struct Cora* co);
void _35clofun5056(struct Cora* co);
void _35clofun5055(struct Cora* co);
void _35clofun5053(struct Cora* co);
void _35clofun5054(struct Cora* co);
void _35clofun5051(struct Cora* co);
void _35clofun5050(struct Cora* co);
void _35clofun5048(struct Cora* co);
void _35clofun5049(struct Cora* co);
void _35clofun5047(struct Cora* co);
void _35clofun5046(struct Cora* co);
void _35clofun5045(struct Cora* co);
void _35clofun5044(struct Cora* co);
void _35clofun5043(struct Cora* co);
void _35clofun5042(struct Cora* co);
void _35clofun5041(struct Cora* co);
void _35clofun5040(struct Cora* co);

void entry(struct Cora* co) {
Obj _35reg4073 = primSet(intern("null?"), makeNative(_35clofun5040, 1, 0));
Obj _35reg4076 = primSet(intern("cadr"), makeNative(_35clofun5041, 1, 0));
Obj _35reg4079 = primSet(intern("caar"), makeNative(_35clofun5042, 1, 0));
Obj _35reg4082 = primSet(intern("cdar"), makeNative(_35clofun5043, 1, 0));
Obj _35reg4085 = primSet(intern("cddr"), makeNative(_35clofun5044, 1, 0));
Obj _35reg4089 = primSet(intern("caddr"), makeNative(_35clofun5045, 1, 0));
Obj _35reg4094 = primSet(intern("cadddr"), makeNative(_35clofun5046, 1, 0));
Obj _35reg4098 = primSet(intern("cdddr"), makeNative(_35clofun5047, 1, 0));
Obj _35reg4106 = primSet(intern("rcons"), makeNative(_35clofun5048, 1, 0));
Obj _35reg4108 = primSet(intern("pair?"), makeNative(_35clofun5050, 1, 0));
Obj _35reg4113 = primSet(intern("cora/init.reverse-h"), makeNative(_35clofun5051, 2, 0));
pushCont(co, _35clofun5052, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.reverse-h"));
co->args[1] = Nil;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5052(struct Cora* co) {
Obj _35val4114 = co->args[1];
Obj _35reg4115 = primSet(intern("reverse"), _35val4114);
Obj _35reg4121 = primSet(intern("map-h"), makeNative(_35clofun5053, 3, 0));
Obj _35reg4122 = primSet(intern("map"), makeNative(_35clofun5055, 2, 0));
Obj _35reg4123 = primSet(intern("*macros*"), Nil);
Obj _35reg4124 = primGenSym(intern("protect"));
Obj _35reg4125 = primSet(intern("*protect-symbol*"), _35reg4124);
Obj _35reg4127 = primSet(intern("cora/init.protect"), makeNative(_35clofun5056, 1, 0));
Obj _35reg4131 = primSet(intern("cora/init.add-to-*macros*"), makeNative(_35clofun5057, 2, 0));
Obj _35reg4144 = primSet(intern("cora/init.macroexpand1-h"), makeNative(_35clofun5058, 2, 0));
Obj _35reg4145 = primSet(intern("cora/init.macroexpand1"), makeNative(_35clofun5060, 1, 0));
Obj _35reg4162 = primSet(intern("cora/init.macroexpand-boot"), makeNative(_35clofun5061, 1, 0));
Obj _35reg4163 = primSet(intern("macroexpand"), globalRef(intern("cora/init.macroexpand-boot")));
Obj _35reg4174 = primSet(intern("defmacro-macro"), makeNative(_35clofun5067, 1, 0));
pushCont(co, _35clofun5071, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("defmacro");
co->args[2] = globalRef(intern("defmacro-macro"));
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5071(struct Cora* co) {
Obj _35val4175 = co->args[1];
pushCont(co, _35clofun5073, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("list");
co->args[2] = makeNative(_35clofun5072, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5073(struct Cora* co) {
Obj _35val4177 = co->args[1];
pushCont(co, _35clofun5078, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("defun");
co->args[2] = makeNative(_35clofun5074, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5078(struct Cora* co) {
Obj _35val4189 = co->args[1];
Obj _35reg4194 = primSet(intern("elem?"), makeNative(_35clofun5079, 2, 0));
Obj _35reg4197 = primSet(intern("atom?"), makeNative(_35clofun5080, 1, 0));
Obj _35reg4209 = primSet(intern("cora/init.rewrite-let"), makeNative(_35clofun5081, 1, 0));
pushCont(co, _35clofun5087, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("let");
co->args[2] = makeNative(_35clofun5086, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5087(struct Cora* co) {
Obj _35val4211 = co->args[1];
pushCont(co, _35clofun5092, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("cond");
co->args[2] = makeNative(_35clofun5088, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5092(struct Cora* co) {
Obj _35val4225 = co->args[1];
Obj _35reg4237 = primSet(intern("cora/init.rewrite-or"), makeNative(_35clofun5093, 1, 0));
pushCont(co, _35clofun5096, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("or");
co->args[2] = makeNative(_35clofun5095, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5096(struct Cora* co) {
Obj _35val4239 = co->args[1];
Obj _35reg4251 = primSet(intern("cora/init.rewrite-and"), makeNative(_35clofun5097, 1, 0));
pushCont(co, _35clofun5100, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("and");
co->args[2] = makeNative(_35clofun5099, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5100(struct Cora* co) {
Obj _35val4253 = co->args[1];
Obj _35reg4256 = primSet(intern("boolean?"), makeNative(_35clofun5101, 1, 0));
Obj _35reg4266 = primSet(intern("cora/init.rcons1"), makeNative(_35clofun5102, 1, 0));
pushCont(co, _35clofun5106, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("list-rest");
co->args[2] = makeNative(_35clofun5105, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5106(struct Cora* co) {
Obj _35val4268 = co->args[1];
Obj _35reg4322 = primSet(intern("cora/init.match-cons-expander"), makeNative(_35clofun5107, 4, 0));
Obj _35reg4355 = primSet(intern("cora/init.match1"), makeNative(_35clofun5125, 4, 0));
Obj _35reg4382 = primSet(intern("cora/init.extract-rule-action"), makeNative(_35clofun5131, 2, 0));
Obj _35reg4434 = primSet(intern("cora/init.match-helper"), makeNative(_35clofun5139, 2, 0));
Obj _35reg4460 = primSet(intern("cora/init.rewrite-match"), makeNative(_35clofun5155, 1, 0));
pushCont(co, _35clofun5163, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("match");
co->args[2] = makeNative(_35clofun5162, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5163(struct Cora* co) {
Obj _35val4461 = co->args[1];
Obj _35reg4513 = primSet(intern("cora/init.extract-rules1"), makeNative(_35clofun5164, 3, 0));
Obj _35reg4514 = primSet(intern("cora/init.extract-rules"), makeNative(_35clofun5171, 1, 0));
Obj _35reg4519 = primSet(intern("cora/init.rules-patterns"), makeNative(_35clofun5172, 2, 0));
Obj _35reg4523 = primSet(intern("cora/init.length-h"), makeNative(_35clofun5175, 2, 0));
Obj _35reg4524 = primSet(intern("length"), makeNative(_35clofun5176, 1, 0));
Obj _35reg4532 = primSet(intern("cora/init.filter-h"), makeNative(_35clofun5177, 3, 0));
Obj _35reg4533 = primSet(intern("filter"), makeNative(_35clofun5179, 2, 0));
Obj _35reg4539 = primSet(intern("append"), makeNative(_35clofun5180, 2, 0));
Obj _35reg4550 = primSet(intern("cora/init.rules-arg-count"), makeNative(_35clofun5182, 1, 0));
Obj _35reg4556 = primSet(intern("cora/init.gen-parameters"), makeNative(_35clofun5189, 1, 0));
pushCont(co, _35clofun5197, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("func");
co->args[2] = makeNative(_35clofun5191, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5197(struct Cora* co) {
Obj _35val4569 = co->args[1];
Obj _35reg4832 = primSet(intern("cora/init.propagate-boolean0"), makeNative(_35clofun5198, 1, 0));
Obj _35reg4990 = primSet(intern("cora/init.propagate-boolean"), makeNative(_35clofun5210, 1, 0));
Obj _35reg4992 = primSet(intern("macroexpand"), makeNative(_35clofun5233, 1, 0));
Obj _35reg5016 = primSet(intern("cora/init.rewrite-begin"), makeNative(_35clofun5235, 1, 0));
pushCont(co, _35clofun5241, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("begin");
co->args[2] = makeNative(_35clofun5240, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5241(struct Cora* co) {
Obj _35val5018 = co->args[1];
Obj _35reg5038 = primSet(intern("cora/init.rewrite-backquote"), makeNative(_35clofun5242, 1, 0));
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("backquote");
co->args[2] = makeNative(_35clofun5248, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5248(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun5249, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5249(struct Cora* co) {
Obj _35val5039 = co->args[1];
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-backquote"));
co->args[1] = _35val5039;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5242(struct Cora* co) {
Obj _35p4067 = co->args[1];
Obj _35cc4068 = makeNative(_35clofun5243, 0, 1, _35p4067);
Obj x = _35p4067;
Obj _35reg5035 = primIsSymbol(x);
if (True == _35reg5035) {
Obj _35reg5036 = primCons(x, Nil);
Obj _35reg5037 = primCons(intern("quote"), _35reg5036);
co->nargs = 2;
co->args[1] = _35reg5037;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4068;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5243(struct Cora* co) {
Obj _35cc4069 = makeNative(_35clofun5244, 0, 1, closureRef(co, 0));
Obj _35reg5025 = primIsCons(closureRef(co, 0));
if (True == _35reg5025) {
Obj _35reg5026 = primCar(closureRef(co, 0));
Obj _35reg5027 = primEQ(intern("unquote"), _35reg5026);
if (True == _35reg5027) {
Obj _35reg5028 = primCdr(closureRef(co, 0));
Obj _35reg5029 = primIsCons(_35reg5028);
if (True == _35reg5029) {
Obj _35reg5030 = primCdr(closureRef(co, 0));
Obj _35reg5031 = primCar(_35reg5030);
Obj x = _35reg5031;
Obj _35reg5032 = primCdr(closureRef(co, 0));
Obj _35reg5033 = primCdr(_35reg5032);
Obj _35reg5034 = primEQ(Nil, _35reg5033);
if (True == _35reg5034) {
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4069;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4069;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4069;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4069;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5244(struct Cora* co) {
Obj _35cc4070 = makeNative(_35clofun5245, 0, 1, closureRef(co, 0));
Obj _35reg5019 = primIsCons(closureRef(co, 0));
if (True == _35reg5019) {
Obj _35reg5020 = primCar(closureRef(co, 0));
Obj x = _35reg5020;
Obj _35reg5021 = primCdr(closureRef(co, 0));
Obj more = _35reg5021;
Obj _35reg5022 = primCons(x, more);
pushCont(co, _35clofun5247, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/init.rewrite-backquote"));
co->args[2] = _35reg5022;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4070;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5247(struct Cora* co) {
Obj _35val5023 = co->args[1];
Obj _35reg5024 = primCons(intern("list"), _35val5023);
co->nargs = 2;
co->args[1] = _35reg5024;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5245(struct Cora* co) {
Obj _35cc4071 = makeNative(_35clofun5246, 0, 0);
Obj x = closureRef(co, 0);
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5246(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5240(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg5017 = primCdr(exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-begin"));
co->args[1] = _35reg5017;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5235(struct Cora* co) {
Obj _35p4063 = co->args[1];
Obj _35cc4064 = makeNative(_35clofun5236, 0, 1, _35p4063);
Obj _35reg5012 = primIsCons(_35p4063);
if (True == _35reg5012) {
Obj _35reg5013 = primCar(_35p4063);
Obj x = _35reg5013;
Obj _35reg5014 = primCdr(_35p4063);
Obj _35reg5015 = primEQ(Nil, _35reg5014);
if (True == _35reg5015) {
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4064;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4064;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5236(struct Cora* co) {
Obj _35cc4065 = makeNative(_35clofun5237, 0, 1, closureRef(co, 0));
Obj _35reg5000 = primIsCons(closureRef(co, 0));
if (True == _35reg5000) {
Obj _35reg5001 = primCar(closureRef(co, 0));
Obj x = _35reg5001;
Obj _35reg5002 = primCdr(closureRef(co, 0));
Obj _35reg5003 = primIsCons(_35reg5002);
if (True == _35reg5003) {
Obj _35reg5004 = primCdr(closureRef(co, 0));
Obj _35reg5005 = primCar(_35reg5004);
Obj y = _35reg5005;
Obj _35reg5006 = primCdr(closureRef(co, 0));
Obj _35reg5007 = primCdr(_35reg5006);
Obj _35reg5008 = primEQ(Nil, _35reg5007);
if (True == _35reg5008) {
Obj _35reg5009 = primCons(y, Nil);
Obj _35reg5010 = primCons(x, _35reg5009);
Obj _35reg5011 = primCons(intern("do"), _35reg5010);
co->nargs = 2;
co->args[1] = _35reg5011;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4065;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4065;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4065;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5237(struct Cora* co) {
Obj _35cc4066 = makeNative(_35clofun5238, 0, 0);
Obj _35reg4993 = primIsCons(closureRef(co, 0));
if (True == _35reg4993) {
Obj _35reg4994 = primCar(closureRef(co, 0));
Obj x = _35reg4994;
Obj _35reg4995 = primCdr(closureRef(co, 0));
Obj y = _35reg4995;
pushCont(co, _35clofun5239, 1, x);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-begin"));
co->args[1] = y;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4066;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5239(struct Cora* co) {
Obj _35val4996 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg4997 = primCons(_35val4996, Nil);
Obj _35reg4998 = primCons(x, _35reg4997);
Obj _35reg4999 = primCons(intern("do"), _35reg4998);
co->nargs = 2;
co->args[1] = _35reg4999;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5238(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5233(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun5234, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.macroexpand-boot"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5234(struct Cora* co) {
Obj _35val4991 = co->args[1];
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = _35val4991;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5210(struct Cora* co) {
Obj _35p4051 = co->args[1];
Obj _35cc4052 = makeNative(_35clofun5211, 0, 1, _35p4051);
Obj _35reg4978 = primIsCons(_35p4051);
if (True == _35reg4978) {
Obj _35reg4979 = primCar(_35p4051);
Obj _35reg4980 = primEQ(intern("quote"), _35reg4979);
if (True == _35reg4980) {
Obj _35reg4981 = primCdr(_35p4051);
Obj _35reg4982 = primIsCons(_35reg4981);
if (True == _35reg4982) {
Obj _35reg4983 = primCdr(_35p4051);
Obj _35reg4984 = primCar(_35reg4983);
Obj x = _35reg4984;
Obj _35reg4985 = primCdr(_35p4051);
Obj _35reg4986 = primCdr(_35reg4985);
Obj _35reg4987 = primEQ(Nil, _35reg4986);
if (True == _35reg4987) {
Obj _35reg4988 = primCons(x, Nil);
Obj _35reg4989 = primCons(intern("quote"), _35reg4988);
co->nargs = 2;
co->args[1] = _35reg4989;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4052;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4052;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4052;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4052;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5211(struct Cora* co) {
Obj _35cc4053 = makeNative(_35clofun5212, 0, 1, closureRef(co, 0));
Obj _35reg4965 = primIsCons(closureRef(co, 0));
if (True == _35reg4965) {
Obj _35reg4966 = primCar(closureRef(co, 0));
Obj _35reg4967 = primEQ(intern("cons?"), _35reg4966);
if (True == _35reg4967) {
Obj _35reg4968 = primCdr(closureRef(co, 0));
Obj _35reg4969 = primIsCons(_35reg4968);
if (True == _35reg4969) {
Obj _35reg4970 = primCdr(closureRef(co, 0));
Obj _35reg4971 = primCar(_35reg4970);
Obj x = _35reg4971;
Obj _35reg4972 = primCdr(closureRef(co, 0));
Obj _35reg4973 = primCdr(_35reg4972);
Obj _35reg4974 = primEQ(Nil, _35reg4973);
if (True == _35reg4974) {
pushCont(co, _35clofun5232, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4053;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4053;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4053;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4053;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5232(struct Cora* co) {
Obj _35val4975 = co->args[1];
Obj x1 = _35val4975;
Obj _35reg4976 = primCons(x1, Nil);
Obj _35reg4977 = primCons(intern("cons?"), _35reg4976);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean0"));
co->args[1] = _35reg4977;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5212(struct Cora* co) {
Obj _35cc4054 = makeNative(_35clofun5213, 0, 1, closureRef(co, 0));
Obj _35reg4952 = primIsCons(closureRef(co, 0));
if (True == _35reg4952) {
Obj _35reg4953 = primCar(closureRef(co, 0));
Obj _35reg4954 = primEQ(intern("car"), _35reg4953);
if (True == _35reg4954) {
Obj _35reg4955 = primCdr(closureRef(co, 0));
Obj _35reg4956 = primIsCons(_35reg4955);
if (True == _35reg4956) {
Obj _35reg4957 = primCdr(closureRef(co, 0));
Obj _35reg4958 = primCar(_35reg4957);
Obj x = _35reg4958;
Obj _35reg4959 = primCdr(closureRef(co, 0));
Obj _35reg4960 = primCdr(_35reg4959);
Obj _35reg4961 = primEQ(Nil, _35reg4960);
if (True == _35reg4961) {
pushCont(co, _35clofun5231, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4054;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4054;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4054;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4054;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5231(struct Cora* co) {
Obj _35val4962 = co->args[1];
Obj x1 = _35val4962;
Obj _35reg4963 = primCons(x1, Nil);
Obj _35reg4964 = primCons(intern("car"), _35reg4963);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean0"));
co->args[1] = _35reg4964;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5213(struct Cora* co) {
Obj _35cc4055 = makeNative(_35clofun5214, 0, 1, closureRef(co, 0));
Obj _35reg4939 = primIsCons(closureRef(co, 0));
if (True == _35reg4939) {
Obj _35reg4940 = primCar(closureRef(co, 0));
Obj _35reg4941 = primEQ(intern("cdr"), _35reg4940);
if (True == _35reg4941) {
Obj _35reg4942 = primCdr(closureRef(co, 0));
Obj _35reg4943 = primIsCons(_35reg4942);
if (True == _35reg4943) {
Obj _35reg4944 = primCdr(closureRef(co, 0));
Obj _35reg4945 = primCar(_35reg4944);
Obj x = _35reg4945;
Obj _35reg4946 = primCdr(closureRef(co, 0));
Obj _35reg4947 = primCdr(_35reg4946);
Obj _35reg4948 = primEQ(Nil, _35reg4947);
if (True == _35reg4948) {
pushCont(co, _35clofun5230, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4055;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4055;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4055;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4055;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5230(struct Cora* co) {
Obj _35val4949 = co->args[1];
Obj x1 = _35val4949;
Obj _35reg4950 = primCons(x1, Nil);
Obj _35reg4951 = primCons(intern("cdr"), _35reg4950);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean0"));
co->args[1] = _35reg4951;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5214(struct Cora* co) {
Obj _35cc4056 = makeNative(_35clofun5215, 0, 1, closureRef(co, 0));
Obj _35reg4917 = primIsCons(closureRef(co, 0));
if (True == _35reg4917) {
Obj _35reg4918 = primCar(closureRef(co, 0));
Obj _35reg4919 = primEQ(intern("and"), _35reg4918);
if (True == _35reg4919) {
Obj _35reg4920 = primCdr(closureRef(co, 0));
Obj _35reg4921 = primIsCons(_35reg4920);
if (True == _35reg4921) {
Obj _35reg4922 = primCdr(closureRef(co, 0));
Obj _35reg4923 = primCar(_35reg4922);
Obj x = _35reg4923;
Obj _35reg4924 = primCdr(closureRef(co, 0));
Obj _35reg4925 = primCdr(_35reg4924);
Obj _35reg4926 = primIsCons(_35reg4925);
if (True == _35reg4926) {
Obj _35reg4927 = primCdr(closureRef(co, 0));
Obj _35reg4928 = primCdr(_35reg4927);
Obj _35reg4929 = primCar(_35reg4928);
Obj y = _35reg4929;
Obj _35reg4930 = primCdr(closureRef(co, 0));
Obj _35reg4931 = primCdr(_35reg4930);
Obj _35reg4932 = primCdr(_35reg4931);
Obj _35reg4933 = primEQ(Nil, _35reg4932);
if (True == _35reg4933) {
pushCont(co, _35clofun5228, 1, y);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4056;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4056;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4056;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4056;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4056;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5228(struct Cora* co) {
Obj _35val4934 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj x1 = _35val4934;
pushCont(co, _35clofun5229, 1, x1);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = y;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5229(struct Cora* co) {
Obj _35val4935 = co->args[1];
Obj x1 = co->stack[co->base + 0];
Obj y1 = _35val4935;
Obj _35reg4936 = primCons(y1, Nil);
Obj _35reg4937 = primCons(x1, _35reg4936);
Obj _35reg4938 = primCons(intern("and"), _35reg4937);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean0"));
co->args[1] = _35reg4938;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5215(struct Cora* co) {
Obj _35cc4057 = makeNative(_35clofun5216, 0, 1, closureRef(co, 0));
Obj _35reg4904 = primIsCons(closureRef(co, 0));
if (True == _35reg4904) {
Obj _35reg4905 = primCar(closureRef(co, 0));
Obj _35reg4906 = primEQ(intern("null?"), _35reg4905);
if (True == _35reg4906) {
Obj _35reg4907 = primCdr(closureRef(co, 0));
Obj _35reg4908 = primIsCons(_35reg4907);
if (True == _35reg4908) {
Obj _35reg4909 = primCdr(closureRef(co, 0));
Obj _35reg4910 = primCar(_35reg4909);
Obj x = _35reg4910;
Obj _35reg4911 = primCdr(closureRef(co, 0));
Obj _35reg4912 = primCdr(_35reg4911);
Obj _35reg4913 = primEQ(Nil, _35reg4912);
if (True == _35reg4913) {
pushCont(co, _35clofun5227, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4057;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4057;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4057;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4057;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5227(struct Cora* co) {
Obj _35val4914 = co->args[1];
Obj x1 = _35val4914;
Obj _35reg4915 = primCons(x1, Nil);
Obj _35reg4916 = primCons(intern("null?"), _35reg4915);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean0"));
co->args[1] = _35reg4916;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5216(struct Cora* co) {
Obj _35cc4058 = makeNative(_35clofun5217, 0, 1, closureRef(co, 0));
Obj _35reg4891 = primIsCons(closureRef(co, 0));
if (True == _35reg4891) {
Obj _35reg4892 = primCar(closureRef(co, 0));
Obj _35reg4893 = primEQ(intern("not"), _35reg4892);
if (True == _35reg4893) {
Obj _35reg4894 = primCdr(closureRef(co, 0));
Obj _35reg4895 = primIsCons(_35reg4894);
if (True == _35reg4895) {
Obj _35reg4896 = primCdr(closureRef(co, 0));
Obj _35reg4897 = primCar(_35reg4896);
Obj x = _35reg4897;
Obj _35reg4898 = primCdr(closureRef(co, 0));
Obj _35reg4899 = primCdr(_35reg4898);
Obj _35reg4900 = primEQ(Nil, _35reg4899);
if (True == _35reg4900) {
pushCont(co, _35clofun5226, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4058;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4058;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4058;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4058;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5226(struct Cora* co) {
Obj _35val4901 = co->args[1];
Obj x1 = _35val4901;
Obj _35reg4902 = primCons(x1, Nil);
Obj _35reg4903 = primCons(intern("not"), _35reg4902);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean0"));
co->args[1] = _35reg4903;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5217(struct Cora* co) {
Obj _35cc4059 = makeNative(_35clofun5218, 0, 1, closureRef(co, 0));
Obj _35reg4858 = primIsCons(closureRef(co, 0));
if (True == _35reg4858) {
Obj _35reg4859 = primCar(closureRef(co, 0));
Obj _35reg4860 = primEQ(intern("if"), _35reg4859);
if (True == _35reg4860) {
Obj _35reg4861 = primCdr(closureRef(co, 0));
Obj _35reg4862 = primIsCons(_35reg4861);
if (True == _35reg4862) {
Obj _35reg4863 = primCdr(closureRef(co, 0));
Obj _35reg4864 = primCar(_35reg4863);
Obj x = _35reg4864;
Obj _35reg4865 = primCdr(closureRef(co, 0));
Obj _35reg4866 = primCdr(_35reg4865);
Obj _35reg4867 = primIsCons(_35reg4866);
if (True == _35reg4867) {
Obj _35reg4868 = primCdr(closureRef(co, 0));
Obj _35reg4869 = primCdr(_35reg4868);
Obj _35reg4870 = primCar(_35reg4869);
Obj y = _35reg4870;
Obj _35reg4871 = primCdr(closureRef(co, 0));
Obj _35reg4872 = primCdr(_35reg4871);
Obj _35reg4873 = primCdr(_35reg4872);
Obj _35reg4874 = primIsCons(_35reg4873);
if (True == _35reg4874) {
Obj _35reg4875 = primCdr(closureRef(co, 0));
Obj _35reg4876 = primCdr(_35reg4875);
Obj _35reg4877 = primCdr(_35reg4876);
Obj _35reg4878 = primCar(_35reg4877);
Obj z = _35reg4878;
Obj _35reg4879 = primCdr(closureRef(co, 0));
Obj _35reg4880 = primCdr(_35reg4879);
Obj _35reg4881 = primCdr(_35reg4880);
Obj _35reg4882 = primCdr(_35reg4881);
Obj _35reg4883 = primEQ(Nil, _35reg4882);
if (True == _35reg4883) {
pushCont(co, _35clofun5223, 2, y, z);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4059;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4059;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4059;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4059;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4059;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4059;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5223(struct Cora* co) {
Obj _35val4884 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj z = co->stack[co->base + 1];
Obj x1 = _35val4884;
pushCont(co, _35clofun5224, 2, z, x1);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = y;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5224(struct Cora* co) {
Obj _35val4885 = co->args[1];
Obj z = co->stack[co->base + 0];
Obj x1 = co->stack[co->base + 1];
Obj y1 = _35val4885;
pushCont(co, _35clofun5225, 2, y1, x1);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = z;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5225(struct Cora* co) {
Obj _35val4886 = co->args[1];
Obj y1 = co->stack[co->base + 0];
Obj x1 = co->stack[co->base + 1];
Obj z1 = _35val4886;
Obj _35reg4887 = primCons(z1, Nil);
Obj _35reg4888 = primCons(y1, _35reg4887);
Obj _35reg4889 = primCons(x1, _35reg4888);
Obj _35reg4890 = primCons(intern("if"), _35reg4889);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean0"));
co->args[1] = _35reg4890;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5218(struct Cora* co) {
Obj _35cc4060 = makeNative(_35clofun5219, 0, 1, closureRef(co, 0));
Obj _35reg4837 = primIsCons(closureRef(co, 0));
if (True == _35reg4837) {
Obj _35reg4838 = primCar(closureRef(co, 0));
Obj _35reg4839 = primEQ(intern("lambda"), _35reg4838);
if (True == _35reg4839) {
Obj _35reg4840 = primCdr(closureRef(co, 0));
Obj _35reg4841 = primIsCons(_35reg4840);
if (True == _35reg4841) {
Obj _35reg4842 = primCdr(closureRef(co, 0));
Obj _35reg4843 = primCar(_35reg4842);
Obj args = _35reg4843;
Obj _35reg4844 = primCdr(closureRef(co, 0));
Obj _35reg4845 = primCdr(_35reg4844);
Obj _35reg4846 = primIsCons(_35reg4845);
if (True == _35reg4846) {
Obj _35reg4847 = primCdr(closureRef(co, 0));
Obj _35reg4848 = primCdr(_35reg4847);
Obj _35reg4849 = primCar(_35reg4848);
Obj body = _35reg4849;
Obj _35reg4850 = primCdr(closureRef(co, 0));
Obj _35reg4851 = primCdr(_35reg4850);
Obj _35reg4852 = primCdr(_35reg4851);
Obj _35reg4853 = primEQ(Nil, _35reg4852);
if (True == _35reg4853) {
pushCont(co, _35clofun5222, 1, args);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.propagate-boolean"));
co->args[1] = body;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4060;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4060;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4060;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4060;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4060;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5222(struct Cora* co) {
Obj _35val4854 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg4855 = primCons(_35val4854, Nil);
Obj _35reg4856 = primCons(args, _35reg4855);
Obj _35reg4857 = primCons(intern("lambda"), _35reg4856);
co->nargs = 2;
co->args[1] = _35reg4857;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5219(struct Cora* co) {
Obj _35cc4061 = makeNative(_35clofun5220, 0, 1, closureRef(co, 0));
Obj _35reg4833 = primIsCons(closureRef(co, 0));
if (True == _35reg4833) {
Obj _35reg4834 = primCar(closureRef(co, 0));
Obj f = _35reg4834;
Obj _35reg4835 = primCdr(closureRef(co, 0));
Obj args = _35reg4835;
Obj _35reg4836 = primCons(f, args);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/init.propagate-boolean"));
co->args[2] = _35reg4836;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4061;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5220(struct Cora* co) {
Obj _35cc4062 = makeNative(_35clofun5221, 0, 0);
Obj x = closureRef(co, 0);
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5221(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5198(struct Cora* co) {
Obj _35p4039 = co->args[1];
Obj _35cc4040 = makeNative(_35clofun5199, 0, 1, _35p4039);
Obj _35reg4793 = primIsCons(_35p4039);
if (True == _35reg4793) {
Obj _35reg4794 = primCar(_35p4039);
Obj _35reg4795 = primEQ(intern("car"), _35reg4794);
if (True == _35reg4795) {
Obj _35reg4796 = primCdr(_35p4039);
Obj _35reg4797 = primIsCons(_35reg4796);
if (True == _35reg4797) {
Obj _35reg4798 = primCdr(_35p4039);
Obj _35reg4799 = primCar(_35reg4798);
Obj _35reg4800 = primIsCons(_35reg4799);
if (True == _35reg4800) {
Obj _35reg4801 = primCdr(_35p4039);
Obj _35reg4802 = primCar(_35reg4801);
Obj _35reg4803 = primCar(_35reg4802);
Obj _35reg4804 = primEQ(intern("cons"), _35reg4803);
if (True == _35reg4804) {
Obj _35reg4805 = primCdr(_35p4039);
Obj _35reg4806 = primCar(_35reg4805);
Obj _35reg4807 = primCdr(_35reg4806);
Obj _35reg4808 = primIsCons(_35reg4807);
if (True == _35reg4808) {
Obj _35reg4809 = primCdr(_35p4039);
Obj _35reg4810 = primCar(_35reg4809);
Obj _35reg4811 = primCdr(_35reg4810);
Obj _35reg4812 = primCar(_35reg4811);
Obj x = _35reg4812;
Obj _35reg4813 = primCdr(_35p4039);
Obj _35reg4814 = primCar(_35reg4813);
Obj _35reg4815 = primCdr(_35reg4814);
Obj _35reg4816 = primCdr(_35reg4815);
Obj _35reg4817 = primIsCons(_35reg4816);
if (True == _35reg4817) {
Obj _35reg4818 = primCdr(_35p4039);
Obj _35reg4819 = primCar(_35reg4818);
Obj _35reg4820 = primCdr(_35reg4819);
Obj _35reg4821 = primCdr(_35reg4820);
Obj _35reg4822 = primCar(_35reg4821);
Obj __ = _35reg4822;
Obj _35reg4823 = primCdr(_35p4039);
Obj _35reg4824 = primCar(_35reg4823);
Obj _35reg4825 = primCdr(_35reg4824);
Obj _35reg4826 = primCdr(_35reg4825);
Obj _35reg4827 = primCdr(_35reg4826);
Obj _35reg4828 = primEQ(Nil, _35reg4827);
if (True == _35reg4828) {
Obj _35reg4829 = primCdr(_35p4039);
Obj _35reg4830 = primCdr(_35reg4829);
Obj _35reg4831 = primEQ(Nil, _35reg4830);
if (True == _35reg4831) {
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5199(struct Cora* co) {
Obj _35cc4041 = makeNative(_35clofun5200, 0, 1, closureRef(co, 0));
Obj _35reg4754 = primIsCons(closureRef(co, 0));
if (True == _35reg4754) {
Obj _35reg4755 = primCar(closureRef(co, 0));
Obj _35reg4756 = primEQ(intern("cdr"), _35reg4755);
if (True == _35reg4756) {
Obj _35reg4757 = primCdr(closureRef(co, 0));
Obj _35reg4758 = primIsCons(_35reg4757);
if (True == _35reg4758) {
Obj _35reg4759 = primCdr(closureRef(co, 0));
Obj _35reg4760 = primCar(_35reg4759);
Obj _35reg4761 = primIsCons(_35reg4760);
if (True == _35reg4761) {
Obj _35reg4762 = primCdr(closureRef(co, 0));
Obj _35reg4763 = primCar(_35reg4762);
Obj _35reg4764 = primCar(_35reg4763);
Obj _35reg4765 = primEQ(intern("cons"), _35reg4764);
if (True == _35reg4765) {
Obj _35reg4766 = primCdr(closureRef(co, 0));
Obj _35reg4767 = primCar(_35reg4766);
Obj _35reg4768 = primCdr(_35reg4767);
Obj _35reg4769 = primIsCons(_35reg4768);
if (True == _35reg4769) {
Obj _35reg4770 = primCdr(closureRef(co, 0));
Obj _35reg4771 = primCar(_35reg4770);
Obj _35reg4772 = primCdr(_35reg4771);
Obj _35reg4773 = primCar(_35reg4772);
Obj __ = _35reg4773;
Obj _35reg4774 = primCdr(closureRef(co, 0));
Obj _35reg4775 = primCar(_35reg4774);
Obj _35reg4776 = primCdr(_35reg4775);
Obj _35reg4777 = primCdr(_35reg4776);
Obj _35reg4778 = primIsCons(_35reg4777);
if (True == _35reg4778) {
Obj _35reg4779 = primCdr(closureRef(co, 0));
Obj _35reg4780 = primCar(_35reg4779);
Obj _35reg4781 = primCdr(_35reg4780);
Obj _35reg4782 = primCdr(_35reg4781);
Obj _35reg4783 = primCar(_35reg4782);
Obj x = _35reg4783;
Obj _35reg4784 = primCdr(closureRef(co, 0));
Obj _35reg4785 = primCar(_35reg4784);
Obj _35reg4786 = primCdr(_35reg4785);
Obj _35reg4787 = primCdr(_35reg4786);
Obj _35reg4788 = primCdr(_35reg4787);
Obj _35reg4789 = primEQ(Nil, _35reg4788);
if (True == _35reg4789) {
Obj _35reg4790 = primCdr(closureRef(co, 0));
Obj _35reg4791 = primCdr(_35reg4790);
Obj _35reg4792 = primEQ(Nil, _35reg4791);
if (True == _35reg4792) {
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4041;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5200(struct Cora* co) {
Obj _35cc4042 = makeNative(_35clofun5201, 0, 1, closureRef(co, 0));
Obj _35reg4715 = primIsCons(closureRef(co, 0));
if (True == _35reg4715) {
Obj _35reg4716 = primCar(closureRef(co, 0));
Obj _35reg4717 = primEQ(intern("cons?"), _35reg4716);
if (True == _35reg4717) {
Obj _35reg4718 = primCdr(closureRef(co, 0));
Obj _35reg4719 = primIsCons(_35reg4718);
if (True == _35reg4719) {
Obj _35reg4720 = primCdr(closureRef(co, 0));
Obj _35reg4721 = primCar(_35reg4720);
Obj _35reg4722 = primIsCons(_35reg4721);
if (True == _35reg4722) {
Obj _35reg4723 = primCdr(closureRef(co, 0));
Obj _35reg4724 = primCar(_35reg4723);
Obj _35reg4725 = primCar(_35reg4724);
Obj _35reg4726 = primEQ(intern("cons"), _35reg4725);
if (True == _35reg4726) {
Obj _35reg4727 = primCdr(closureRef(co, 0));
Obj _35reg4728 = primCar(_35reg4727);
Obj _35reg4729 = primCdr(_35reg4728);
Obj _35reg4730 = primIsCons(_35reg4729);
if (True == _35reg4730) {
Obj _35reg4731 = primCdr(closureRef(co, 0));
Obj _35reg4732 = primCar(_35reg4731);
Obj _35reg4733 = primCdr(_35reg4732);
Obj _35reg4734 = primCar(_35reg4733);
Obj __ = _35reg4734;
Obj _35reg4735 = primCdr(closureRef(co, 0));
Obj _35reg4736 = primCar(_35reg4735);
Obj _35reg4737 = primCdr(_35reg4736);
Obj _35reg4738 = primCdr(_35reg4737);
Obj _35reg4739 = primIsCons(_35reg4738);
if (True == _35reg4739) {
Obj _35reg4740 = primCdr(closureRef(co, 0));
Obj _35reg4741 = primCar(_35reg4740);
Obj _35reg4742 = primCdr(_35reg4741);
Obj _35reg4743 = primCdr(_35reg4742);
Obj _35reg4744 = primCar(_35reg4743);
__ = _35reg4744;
Obj _35reg4745 = primCdr(closureRef(co, 0));
Obj _35reg4746 = primCar(_35reg4745);
Obj _35reg4747 = primCdr(_35reg4746);
Obj _35reg4748 = primCdr(_35reg4747);
Obj _35reg4749 = primCdr(_35reg4748);
Obj _35reg4750 = primEQ(Nil, _35reg4749);
if (True == _35reg4750) {
Obj _35reg4751 = primCdr(closureRef(co, 0));
Obj _35reg4752 = primCdr(_35reg4751);
Obj _35reg4753 = primEQ(Nil, _35reg4752);
if (True == _35reg4753) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4042;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5201(struct Cora* co) {
Obj _35cc4043 = makeNative(_35clofun5202, 0, 1, closureRef(co, 0));
Obj _35reg4696 = primIsCons(closureRef(co, 0));
if (True == _35reg4696) {
Obj _35reg4697 = primCar(closureRef(co, 0));
Obj _35reg4698 = primEQ(intern("and"), _35reg4697);
if (True == _35reg4698) {
Obj _35reg4699 = primCdr(closureRef(co, 0));
Obj _35reg4700 = primIsCons(_35reg4699);
if (True == _35reg4700) {
Obj _35reg4701 = primCdr(closureRef(co, 0));
Obj _35reg4702 = primCar(_35reg4701);
Obj _35reg4703 = primEQ(True, _35reg4702);
if (True == _35reg4703) {
Obj _35reg4704 = primCdr(closureRef(co, 0));
Obj _35reg4705 = primCdr(_35reg4704);
Obj _35reg4706 = primIsCons(_35reg4705);
if (True == _35reg4706) {
Obj _35reg4707 = primCdr(closureRef(co, 0));
Obj _35reg4708 = primCdr(_35reg4707);
Obj _35reg4709 = primCar(_35reg4708);
Obj _35reg4710 = primEQ(True, _35reg4709);
if (True == _35reg4710) {
Obj _35reg4711 = primCdr(closureRef(co, 0));
Obj _35reg4712 = primCdr(_35reg4711);
Obj _35reg4713 = primCdr(_35reg4712);
Obj _35reg4714 = primEQ(Nil, _35reg4713);
if (True == _35reg4714) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4043;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4043;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4043;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4043;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4043;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4043;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4043;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5202(struct Cora* co) {
Obj _35cc4044 = makeNative(_35clofun5203, 0, 1, closureRef(co, 0));
Obj _35reg4685 = primIsCons(closureRef(co, 0));
if (True == _35reg4685) {
Obj _35reg4686 = primCar(closureRef(co, 0));
Obj _35reg4687 = primEQ(intern("null?"), _35reg4686);
if (True == _35reg4687) {
Obj _35reg4688 = primCdr(closureRef(co, 0));
Obj _35reg4689 = primIsCons(_35reg4688);
if (True == _35reg4689) {
Obj _35reg4690 = primCdr(closureRef(co, 0));
Obj _35reg4691 = primCar(_35reg4690);
Obj _35reg4692 = primEQ(Nil, _35reg4691);
if (True == _35reg4692) {
Obj _35reg4693 = primCdr(closureRef(co, 0));
Obj _35reg4694 = primCdr(_35reg4693);
Obj _35reg4695 = primEQ(Nil, _35reg4694);
if (True == _35reg4695) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5203(struct Cora* co) {
Obj _35cc4045 = makeNative(_35clofun5204, 0, 1, closureRef(co, 0));
Obj _35reg4646 = primIsCons(closureRef(co, 0));
if (True == _35reg4646) {
Obj _35reg4647 = primCar(closureRef(co, 0));
Obj _35reg4648 = primEQ(intern("null?"), _35reg4647);
if (True == _35reg4648) {
Obj _35reg4649 = primCdr(closureRef(co, 0));
Obj _35reg4650 = primIsCons(_35reg4649);
if (True == _35reg4650) {
Obj _35reg4651 = primCdr(closureRef(co, 0));
Obj _35reg4652 = primCar(_35reg4651);
Obj _35reg4653 = primIsCons(_35reg4652);
if (True == _35reg4653) {
Obj _35reg4654 = primCdr(closureRef(co, 0));
Obj _35reg4655 = primCar(_35reg4654);
Obj _35reg4656 = primCar(_35reg4655);
Obj _35reg4657 = primEQ(intern("cons"), _35reg4656);
if (True == _35reg4657) {
Obj _35reg4658 = primCdr(closureRef(co, 0));
Obj _35reg4659 = primCar(_35reg4658);
Obj _35reg4660 = primCdr(_35reg4659);
Obj _35reg4661 = primIsCons(_35reg4660);
if (True == _35reg4661) {
Obj _35reg4662 = primCdr(closureRef(co, 0));
Obj _35reg4663 = primCar(_35reg4662);
Obj _35reg4664 = primCdr(_35reg4663);
Obj _35reg4665 = primCar(_35reg4664);
Obj __ = _35reg4665;
Obj _35reg4666 = primCdr(closureRef(co, 0));
Obj _35reg4667 = primCar(_35reg4666);
Obj _35reg4668 = primCdr(_35reg4667);
Obj _35reg4669 = primCdr(_35reg4668);
Obj _35reg4670 = primIsCons(_35reg4669);
if (True == _35reg4670) {
Obj _35reg4671 = primCdr(closureRef(co, 0));
Obj _35reg4672 = primCar(_35reg4671);
Obj _35reg4673 = primCdr(_35reg4672);
Obj _35reg4674 = primCdr(_35reg4673);
Obj _35reg4675 = primCar(_35reg4674);
__ = _35reg4675;
Obj _35reg4676 = primCdr(closureRef(co, 0));
Obj _35reg4677 = primCar(_35reg4676);
Obj _35reg4678 = primCdr(_35reg4677);
Obj _35reg4679 = primCdr(_35reg4678);
Obj _35reg4680 = primCdr(_35reg4679);
Obj _35reg4681 = primEQ(Nil, _35reg4680);
if (True == _35reg4681) {
Obj _35reg4682 = primCdr(closureRef(co, 0));
Obj _35reg4683 = primCdr(_35reg4682);
Obj _35reg4684 = primEQ(Nil, _35reg4683);
if (True == _35reg4684) {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5204(struct Cora* co) {
Obj _35cc4046 = makeNative(_35clofun5205, 0, 1, closureRef(co, 0));
Obj _35reg4635 = primIsCons(closureRef(co, 0));
if (True == _35reg4635) {
Obj _35reg4636 = primCar(closureRef(co, 0));
Obj _35reg4637 = primEQ(intern("not"), _35reg4636);
if (True == _35reg4637) {
Obj _35reg4638 = primCdr(closureRef(co, 0));
Obj _35reg4639 = primIsCons(_35reg4638);
if (True == _35reg4639) {
Obj _35reg4640 = primCdr(closureRef(co, 0));
Obj _35reg4641 = primCar(_35reg4640);
Obj _35reg4642 = primEQ(True, _35reg4641);
if (True == _35reg4642) {
Obj _35reg4643 = primCdr(closureRef(co, 0));
Obj _35reg4644 = primCdr(_35reg4643);
Obj _35reg4645 = primEQ(Nil, _35reg4644);
if (True == _35reg4645) {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4046;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4046;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4046;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4046;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4046;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5205(struct Cora* co) {
Obj _35cc4047 = makeNative(_35clofun5206, 0, 1, closureRef(co, 0));
Obj _35reg4624 = primIsCons(closureRef(co, 0));
if (True == _35reg4624) {
Obj _35reg4625 = primCar(closureRef(co, 0));
Obj _35reg4626 = primEQ(intern("not"), _35reg4625);
if (True == _35reg4626) {
Obj _35reg4627 = primCdr(closureRef(co, 0));
Obj _35reg4628 = primIsCons(_35reg4627);
if (True == _35reg4628) {
Obj _35reg4629 = primCdr(closureRef(co, 0));
Obj _35reg4630 = primCar(_35reg4629);
Obj _35reg4631 = primEQ(False, _35reg4630);
if (True == _35reg4631) {
Obj _35reg4632 = primCdr(closureRef(co, 0));
Obj _35reg4633 = primCdr(_35reg4632);
Obj _35reg4634 = primEQ(Nil, _35reg4633);
if (True == _35reg4634) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5206(struct Cora* co) {
Obj _35cc4048 = makeNative(_35clofun5207, 0, 1, closureRef(co, 0));
Obj _35reg4597 = primIsCons(closureRef(co, 0));
if (True == _35reg4597) {
Obj _35reg4598 = primCar(closureRef(co, 0));
Obj _35reg4599 = primEQ(intern("if"), _35reg4598);
if (True == _35reg4599) {
Obj _35reg4600 = primCdr(closureRef(co, 0));
Obj _35reg4601 = primIsCons(_35reg4600);
if (True == _35reg4601) {
Obj _35reg4602 = primCdr(closureRef(co, 0));
Obj _35reg4603 = primCar(_35reg4602);
Obj _35reg4604 = primEQ(True, _35reg4603);
if (True == _35reg4604) {
Obj _35reg4605 = primCdr(closureRef(co, 0));
Obj _35reg4606 = primCdr(_35reg4605);
Obj _35reg4607 = primIsCons(_35reg4606);
if (True == _35reg4607) {
Obj _35reg4608 = primCdr(closureRef(co, 0));
Obj _35reg4609 = primCdr(_35reg4608);
Obj _35reg4610 = primCar(_35reg4609);
Obj y = _35reg4610;
Obj _35reg4611 = primCdr(closureRef(co, 0));
Obj _35reg4612 = primCdr(_35reg4611);
Obj _35reg4613 = primCdr(_35reg4612);
Obj _35reg4614 = primIsCons(_35reg4613);
if (True == _35reg4614) {
Obj _35reg4615 = primCdr(closureRef(co, 0));
Obj _35reg4616 = primCdr(_35reg4615);
Obj _35reg4617 = primCdr(_35reg4616);
Obj _35reg4618 = primCar(_35reg4617);
Obj z = _35reg4618;
Obj _35reg4619 = primCdr(closureRef(co, 0));
Obj _35reg4620 = primCdr(_35reg4619);
Obj _35reg4621 = primCdr(_35reg4620);
Obj _35reg4622 = primCdr(_35reg4621);
Obj _35reg4623 = primEQ(Nil, _35reg4622);
if (True == _35reg4623) {
co->nargs = 2;
co->args[1] = y;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5207(struct Cora* co) {
Obj _35cc4049 = makeNative(_35clofun5208, 0, 1, closureRef(co, 0));
Obj _35reg4570 = primIsCons(closureRef(co, 0));
if (True == _35reg4570) {
Obj _35reg4571 = primCar(closureRef(co, 0));
Obj _35reg4572 = primEQ(intern("if"), _35reg4571);
if (True == _35reg4572) {
Obj _35reg4573 = primCdr(closureRef(co, 0));
Obj _35reg4574 = primIsCons(_35reg4573);
if (True == _35reg4574) {
Obj _35reg4575 = primCdr(closureRef(co, 0));
Obj _35reg4576 = primCar(_35reg4575);
Obj _35reg4577 = primEQ(False, _35reg4576);
if (True == _35reg4577) {
Obj _35reg4578 = primCdr(closureRef(co, 0));
Obj _35reg4579 = primCdr(_35reg4578);
Obj _35reg4580 = primIsCons(_35reg4579);
if (True == _35reg4580) {
Obj _35reg4581 = primCdr(closureRef(co, 0));
Obj _35reg4582 = primCdr(_35reg4581);
Obj _35reg4583 = primCar(_35reg4582);
Obj y = _35reg4583;
Obj _35reg4584 = primCdr(closureRef(co, 0));
Obj _35reg4585 = primCdr(_35reg4584);
Obj _35reg4586 = primCdr(_35reg4585);
Obj _35reg4587 = primIsCons(_35reg4586);
if (True == _35reg4587) {
Obj _35reg4588 = primCdr(closureRef(co, 0));
Obj _35reg4589 = primCdr(_35reg4588);
Obj _35reg4590 = primCdr(_35reg4589);
Obj _35reg4591 = primCar(_35reg4590);
Obj z = _35reg4591;
Obj _35reg4592 = primCdr(closureRef(co, 0));
Obj _35reg4593 = primCdr(_35reg4592);
Obj _35reg4594 = primCdr(_35reg4593);
Obj _35reg4595 = primCdr(_35reg4594);
Obj _35reg4596 = primEQ(Nil, _35reg4595);
if (True == _35reg4596) {
co->nargs = 2;
co->args[1] = z;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5208(struct Cora* co) {
Obj _35cc4050 = makeNative(_35clofun5209, 0, 0);
Obj x = closureRef(co, 0);
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5209(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5191(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun5192, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5192(struct Cora* co) {
Obj _35val4557 = co->args[1];
Obj exp = co->stack[co->base + 0];
pushCont(co, _35clofun5193, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.extract-rules"));
co->args[1] = _35val4557;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5193(struct Cora* co) {
Obj _35val4558 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj body = _35val4558;
pushCont(co, _35clofun5194, 2, exp, body);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rules-arg-count"));
co->args[1] = body;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5194(struct Cora* co) {
Obj _35val4559 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj nargs = _35val4559;
pushCont(co, _35clofun5195, 2, exp, body);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.gen-parameters"));
co->args[1] = nargs;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5195(struct Cora* co) {
Obj _35val4560 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj args = _35val4560;
pushCont(co, _35clofun5196, 2, body, args);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5196(struct Cora* co) {
Obj _35val4561 = co->args[1];
Obj body = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj _35reg4562 = primCons(intern("list"), args);
Obj _35reg4563 = primCons(_35reg4562, body);
Obj _35reg4564 = primCons(intern("match"), _35reg4563);
Obj _35reg4565 = primCons(_35reg4564, Nil);
Obj _35reg4566 = primCons(args, _35reg4565);
Obj _35reg4567 = primCons(_35val4561, _35reg4566);
Obj _35reg4568 = primCons(intern("defun"), _35reg4567);
co->nargs = 2;
co->args[1] = _35reg4568;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5189(struct Cora* co) {
Obj n = co->args[1];
Obj _35reg4551 = primEQ(n, makeNumber(0));
if (True == _35reg4551) {
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4552 = primGenSym(intern("p"));
Obj _35reg4553 = primSub(n, makeNumber(1));
pushCont(co, _35clofun5190, 1, _35reg4552);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.gen-parameters"));
co->args[1] = _35reg4553;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5190(struct Cora* co) {
Obj _35val4554 = co->args[1];
Obj _35reg4552 = co->stack[co->base + 0];
Obj _35reg4555 = primCons(_35reg4552, _35val4554);
co->nargs = 2;
co->args[1] = _35reg4555;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5182(struct Cora* co) {
Obj rules = co->args[1];
pushCont(co, _35clofun5183, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.rules-patterns"));
co->args[1] = Nil;
co->args[2] = rules;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5183(struct Cora* co) {
Obj _35val4540 = co->args[1];
Obj pats = _35val4540;
Obj len = makeNative(_35clofun5184, 1, 0);
pushCont(co, _35clofun5185, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = len;
co->args[2] = pats;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5185(struct Cora* co) {
Obj _35val4542 = co->args[1];
Obj counts = _35val4542;
Obj _35reg4543 = primCar(counts);
Obj n = _35reg4543;
Obj dif = makeNative(_35clofun5186, 1, 1, n);
Obj _35reg4546 = primCdr(counts);
pushCont(co, _35clofun5187, 1, n);
co->nargs = 3;
co->args[0] = globalRef(intern("filter"));
co->args[1] = dif;
co->args[2] = _35reg4546;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5187(struct Cora* co) {
Obj _35val4547 = co->args[1];
Obj n = co->stack[co->base + 0];
pushCont(co, _35clofun5188, 1, n);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = _35val4547;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5188(struct Cora* co) {
Obj _35val4548 = co->args[1];
Obj n = co->stack[co->base + 0];
Obj _35reg4549 = primNot(_35val4548);
if (True == _35reg4549) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("inconsistent func rule args count");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[1] = n;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun5186(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4544 = primEQ(closureRef(co, 0), x);
Obj _35reg4545 = primNot(_35reg4544);
co->nargs = 2;
co->args[1] = _35reg4545;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5184(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4541 = primCdr(x);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = _35reg4541;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5180(struct Cora* co) {
Obj l1 = co->args[1];
Obj l2 = co->args[2];
Obj _35reg4534 = primEQ(l1, Nil);
if (True == _35reg4534) {
co->nargs = 2;
co->args[1] = l2;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4535 = primCar(l1);
Obj _35reg4536 = primCdr(l1);
pushCont(co, _35clofun5181, 1, _35reg4535);
co->nargs = 3;
co->args[0] = globalRef(intern("append"));
co->args[1] = _35reg4536;
co->args[2] = l2;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5181(struct Cora* co) {
Obj _35val4537 = co->args[1];
Obj _35reg4535 = co->stack[co->base + 0];
Obj _35reg4538 = primCons(_35reg4535, _35val4537);
co->nargs = 2;
co->args[1] = _35reg4538;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5179(struct Cora* co) {
Obj fn = co->args[1];
Obj l = co->args[2];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/init.filter-h"));
co->args[1] = Nil;
co->args[2] = fn;
co->args[3] = l;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5177(struct Cora* co) {
Obj res = co->args[1];
Obj fn = co->args[2];
Obj l = co->args[3];
Obj _35reg4525 = primIsCons(l);
if (True == _35reg4525) {
Obj _35reg4526 = primCar(l);
pushCont(co, _35clofun5178, 3, l, res, fn);
co->nargs = 2;
co->args[0] = fn;
co->args[1] = _35reg4526;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("reverse"));
co->args[1] = res;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5178(struct Cora* co) {
Obj _35val4527 = co->args[1];
Obj l = co->stack[co->base + 0];
Obj res = co->stack[co->base + 1];
Obj fn = co->stack[co->base + 2];
if (True == _35val4527) {
Obj _35reg4528 = primCar(l);
Obj _35reg4529 = primCons(_35reg4528, res);
Obj _35reg4530 = primCdr(l);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/init.filter-h"));
co->args[1] = _35reg4529;
co->args[2] = fn;
co->args[3] = _35reg4530;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4531 = primCdr(l);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/init.filter-h"));
co->args[1] = res;
co->args[2] = fn;
co->args[3] = _35reg4531;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5176(struct Cora* co) {
Obj l = co->args[1];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.length-h"));
co->args[1] = makeNumber(0);
co->args[2] = l;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5175(struct Cora* co) {
Obj i = co->args[1];
Obj l = co->args[2];
Obj _35reg4520 = primEQ(l, Nil);
if (True == _35reg4520) {
co->nargs = 2;
co->args[1] = i;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4521 = primAdd(i, makeNumber(1));
Obj _35reg4522 = primCdr(l);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.length-h"));
co->args[1] = _35reg4521;
co->args[2] = _35reg4522;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5172(struct Cora* co) {
Obj res = co->args[1];
Obj rules = co->args[2];
pushCont(co, _35clofun5173, 2, res, rules);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = rules;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5173(struct Cora* co) {
Obj _35val4515 = co->args[1];
Obj res = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
if (True == _35val4515) {
co->nargs = 2;
co->args[0] = globalRef(intern("reverse"));
co->args[1] = res;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4516 = primCar(rules);
Obj _35reg4517 = primCons(_35reg4516, res);
pushCont(co, _35clofun5174, 1, _35reg4517);
co->nargs = 2;
co->args[0] = globalRef(intern("cddr"));
co->args[1] = rules;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5174(struct Cora* co) {
Obj _35val4518 = co->args[1];
Obj _35reg4517 = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.rules-patterns"));
co->args[1] = _35reg4517;
co->args[2] = _35val4518;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5171(struct Cora* co) {
Obj input = co->args[1];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/init.extract-rules1"));
co->args[1] = input;
co->args[2] = Nil;
co->args[3] = Nil;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5164(struct Cora* co) {
Obj input = co->args[1];
Obj current = co->args[2];
Obj result = co->args[3];
Obj _35cc4035 = makeNative(_35clofun5165, 0, 3, input, current, result);
Obj _35reg4512 = primEQ(Nil, input);
if (True == _35reg4512) {
co->nargs = 2;
co->args[0] = globalRef(intern("reverse"));
co->args[1] = result;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4035;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5165(struct Cora* co) {
Obj _35cc4036 = makeNative(_35clofun5166, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj _35reg4479 = primIsCons(closureRef(co, 0));
if (True == _35reg4479) {
Obj _35reg4480 = primCar(closureRef(co, 0));
Obj _35reg4481 = primEQ(intern("=>"), _35reg4480);
if (True == _35reg4481) {
Obj _35reg4482 = primCdr(closureRef(co, 0));
Obj _35reg4483 = primIsCons(_35reg4482);
if (True == _35reg4483) {
Obj _35reg4484 = primCdr(closureRef(co, 0));
Obj _35reg4485 = primCar(_35reg4484);
Obj act = _35reg4485;
Obj _35reg4486 = primCdr(closureRef(co, 0));
Obj _35reg4487 = primCdr(_35reg4486);
Obj _35reg4488 = primIsCons(_35reg4487);
if (True == _35reg4488) {
Obj _35reg4489 = primCdr(closureRef(co, 0));
Obj _35reg4490 = primCdr(_35reg4489);
Obj _35reg4491 = primCar(_35reg4490);
Obj _35reg4492 = primEQ(intern("where"), _35reg4491);
if (True == _35reg4492) {
Obj _35reg4493 = primCdr(closureRef(co, 0));
Obj _35reg4494 = primCdr(_35reg4493);
Obj _35reg4495 = primCdr(_35reg4494);
Obj _35reg4496 = primIsCons(_35reg4495);
if (True == _35reg4496) {
Obj _35reg4497 = primCdr(closureRef(co, 0));
Obj _35reg4498 = primCdr(_35reg4497);
Obj _35reg4499 = primCdr(_35reg4498);
Obj _35reg4500 = primCar(_35reg4499);
Obj pred = _35reg4500;
Obj _35reg4501 = primCdr(closureRef(co, 0));
Obj _35reg4502 = primCdr(_35reg4501);
Obj _35reg4503 = primCdr(_35reg4502);
Obj _35reg4504 = primCdr(_35reg4503);
Obj remain = _35reg4504;
pushCont(co, _35clofun5170, 3, act, pred, remain);
co->nargs = 2;
co->args[0] = globalRef(intern("reverse"));
co->args[1] = closureRef(co, 1);
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4036;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4036;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4036;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4036;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4036;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4036;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5170(struct Cora* co) {
Obj _35val4505 = co->args[1];
Obj act = co->stack[co->base + 0];
Obj pred = co->stack[co->base + 1];
Obj remain = co->stack[co->base + 2];
Obj _35reg4506 = primCons(intern("list"), _35val4505);
Obj pat = _35reg4506;
Obj _35reg4507 = primCons(act, Nil);
Obj _35reg4508 = primCons(pred, _35reg4507);
Obj _35reg4509 = primCons(intern("where"), _35reg4508);
Obj _35reg4510 = primCons(pat, closureRef(co, 2));
Obj _35reg4511 = primCons(_35reg4509, _35reg4510);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/init.extract-rules1"));
co->args[1] = remain;
co->args[2] = Nil;
co->args[3] = _35reg4511;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5166(struct Cora* co) {
Obj _35cc4037 = makeNative(_35clofun5167, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj _35reg4466 = primIsCons(closureRef(co, 0));
if (True == _35reg4466) {
Obj _35reg4467 = primCar(closureRef(co, 0));
Obj _35reg4468 = primEQ(intern("=>"), _35reg4467);
if (True == _35reg4468) {
Obj _35reg4469 = primCdr(closureRef(co, 0));
Obj _35reg4470 = primIsCons(_35reg4469);
if (True == _35reg4470) {
Obj _35reg4471 = primCdr(closureRef(co, 0));
Obj _35reg4472 = primCar(_35reg4471);
Obj act = _35reg4472;
Obj _35reg4473 = primCdr(closureRef(co, 0));
Obj _35reg4474 = primCdr(_35reg4473);
Obj remain = _35reg4474;
pushCont(co, _35clofun5169, 2, act, remain);
co->nargs = 2;
co->args[0] = globalRef(intern("reverse"));
co->args[1] = closureRef(co, 1);
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4037;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4037;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc4037;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5169(struct Cora* co) {
Obj _35val4475 = co->args[1];
Obj act = co->stack[co->base + 0];
Obj remain = co->stack[co->base + 1];
Obj _35reg4476 = primCons(intern("list"), _35val4475);
Obj pat = _35reg4476;
Obj _35reg4477 = primCons(pat, closureRef(co, 2));
Obj _35reg4478 = primCons(act, _35reg4477);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/init.extract-rules1"));
co->args[1] = remain;
co->args[2] = Nil;
co->args[3] = _35reg4478;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5167(struct Cora* co) {
Obj _35cc4038 = makeNative(_35clofun5168, 0, 0);
Obj _35reg4462 = primIsCons(closureRef(co, 0));
if (True == _35reg4462) {
Obj _35reg4463 = primCar(closureRef(co, 0));
Obj x = _35reg4463;
Obj _35reg4464 = primCdr(closureRef(co, 0));
Obj y = _35reg4464;
Obj _35reg4465 = primCons(x, closureRef(co, 1));
co->nargs = 4;
co->args[0] = globalRef(intern("cora/init.extract-rules1"));
co->args[1] = y;
co->args[2] = _35reg4465;
co->args[3] = closureRef(co, 2);
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc4038;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5168(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5162(struct Cora* co) {
Obj exp = co->args[1];
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-match"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5155(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun5156, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5156(struct Cora* co) {
Obj _35val4435 = co->args[1];
Obj exp = co->stack[co->base + 0];
pushCont(co, _35clofun5157, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("macroexpand"));
co->args[1] = _35val4435;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5157(struct Cora* co) {
Obj _35val4436 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj value = _35val4436;
pushCont(co, _35clofun5158, 1, value);
co->nargs = 2;
co->args[0] = globalRef(intern("cddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5158(struct Cora* co) {
Obj _35val4437 = co->args[1];
Obj value = co->stack[co->base + 0];
Obj rules = _35val4437;
Obj _35reg4438 = primIsCons(value);
if (True == _35reg4438) {
Obj _35reg4439 = primCar(value);
Obj _35reg4440 = primEQ(intern("cons"), _35reg4439);
Obj _35reg4441 = primNot(_35reg4440);
if (True == _35reg4441) {
if (True == True) {
Obj _35reg4442 = primGenSym(intern("val"));
Obj val = _35reg4442;
pushCont(co, _35clofun5159, 2, value, val);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = val;
co->args[2] = rules;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = value;
co->args[2] = rules;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg4448 = primGenSym(intern("val"));
Obj val = _35reg4448;
pushCont(co, _35clofun5160, 2, value, val);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = val;
co->args[2] = rules;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = value;
co->args[2] = rules;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
Obj _35reg4454 = primGenSym(intern("val"));
Obj val = _35reg4454;
pushCont(co, _35clofun5161, 2, value, val);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = val;
co->args[2] = rules;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = value;
co->args[2] = rules;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun5161(struct Cora* co) {
Obj _35val4455 = co->args[1];
Obj value = co->stack[co->base + 0];
Obj val = co->stack[co->base + 1];
Obj _35reg4456 = primCons(_35val4455, Nil);
Obj _35reg4457 = primCons(value, _35reg4456);
Obj _35reg4458 = primCons(val, _35reg4457);
Obj _35reg4459 = primCons(intern("let"), _35reg4458);
co->nargs = 2;
co->args[1] = _35reg4459;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5160(struct Cora* co) {
Obj _35val4449 = co->args[1];
Obj value = co->stack[co->base + 0];
Obj val = co->stack[co->base + 1];
Obj _35reg4450 = primCons(_35val4449, Nil);
Obj _35reg4451 = primCons(value, _35reg4450);
Obj _35reg4452 = primCons(val, _35reg4451);
Obj _35reg4453 = primCons(intern("let"), _35reg4452);
co->nargs = 2;
co->args[1] = _35reg4453;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5159(struct Cora* co) {
Obj _35val4443 = co->args[1];
Obj value = co->stack[co->base + 0];
Obj val = co->stack[co->base + 1];
Obj _35reg4444 = primCons(_35val4443, Nil);
Obj _35reg4445 = primCons(value, _35reg4444);
Obj _35reg4446 = primCons(val, _35reg4445);
Obj _35reg4447 = primCons(intern("let"), _35reg4446);
co->nargs = 2;
co->args[1] = _35reg4447;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5139(struct Cora* co) {
Obj value = co->args[1];
Obj rules = co->args[2];
pushCont(co, _35clofun5140, 2, rules, value);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = rules;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5140(struct Cora* co) {
Obj _35val4383 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
if (True == _35val4383) {
Obj _35reg4384 = primCons(makeString1("no match-help found!"), Nil);
Obj _35reg4385 = primCons(intern("error"), _35reg4384);
co->nargs = 2;
co->args[1] = _35reg4385;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
pushCont(co, _35clofun5141, 2, rules, value);
co->nargs = 2;
co->args[0] = globalRef(intern("pair?"));
co->args[1] = rules;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5141(struct Cora* co) {
Obj _35val4386 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
if (True == _35val4386) {
Obj _35reg4387 = primCdr(rules);
pushCont(co, _35clofun5142, 2, rules, value);
co->nargs = 2;
co->args[0] = globalRef(intern("pair?"));
co->args[1] = _35reg4387;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
if (True == False) {
Obj _35reg4419 = primCar(rules);
Obj pat = _35reg4419;
Obj _35reg4420 = primGenSym(intern("cc"));
Obj cc = _35reg4420;
pushCont(co, _35clofun5151, 4, pat, rules, value, cc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.extract-rule-action"));
co->args[1] = rules;
co->args[2] = cc;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun5151(struct Cora* co) {
Obj _35val4421 = co->args[1];
Obj pat = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj action = _35val4421;
pushCont(co, _35clofun5152, 4, action, rules, value, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("macroexpand"));
co->args[1] = pat;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5152(struct Cora* co) {
Obj _35val4422 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
pushCont(co, _35clofun5153, 3, rules, value, cc);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = _35val4422;
co->args[2] = value;
co->args[3] = action;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5153(struct Cora* co) {
Obj _35val4423 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj curr = _35val4423;
Obj _35reg4424 = primCdr(rules);
Obj _35reg4425 = primCdr(_35reg4424);
pushCont(co, _35clofun5154, 2, curr, cc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = value;
co->args[2] = _35reg4425;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5154(struct Cora* co) {
Obj _35val4426 = co->args[1];
Obj curr = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
Obj rest = _35val4426;
Obj _35reg4427 = primCons(rest, Nil);
Obj _35reg4428 = primCons(Nil, _35reg4427);
Obj _35reg4429 = primCons(intern("lambda"), _35reg4428);
Obj _35reg4430 = primCons(curr, Nil);
Obj _35reg4431 = primCons(_35reg4429, _35reg4430);
Obj _35reg4432 = primCons(cc, _35reg4431);
Obj _35reg4433 = primCons(intern("let"), _35reg4432);
co->nargs = 2;
co->args[1] = _35reg4433;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5142(struct Cora* co) {
Obj _35val4388 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
if (True == _35val4388) {
if (True == True) {
Obj _35reg4389 = primCar(rules);
Obj pat = _35reg4389;
Obj _35reg4390 = primGenSym(intern("cc"));
Obj cc = _35reg4390;
pushCont(co, _35clofun5143, 4, pat, rules, value, cc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.extract-rule-action"));
co->args[1] = rules;
co->args[2] = cc;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg4404 = primCar(rules);
Obj pat = _35reg4404;
Obj _35reg4405 = primGenSym(intern("cc"));
Obj cc = _35reg4405;
pushCont(co, _35clofun5147, 4, pat, rules, value, cc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.extract-rule-action"));
co->args[1] = rules;
co->args[2] = cc;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun5147(struct Cora* co) {
Obj _35val4406 = co->args[1];
Obj pat = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj action = _35val4406;
pushCont(co, _35clofun5148, 4, action, rules, value, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("macroexpand"));
co->args[1] = pat;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5148(struct Cora* co) {
Obj _35val4407 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
pushCont(co, _35clofun5149, 3, rules, value, cc);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = _35val4407;
co->args[2] = value;
co->args[3] = action;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5149(struct Cora* co) {
Obj _35val4408 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj curr = _35val4408;
Obj _35reg4409 = primCdr(rules);
Obj _35reg4410 = primCdr(_35reg4409);
pushCont(co, _35clofun5150, 2, curr, cc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = value;
co->args[2] = _35reg4410;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5150(struct Cora* co) {
Obj _35val4411 = co->args[1];
Obj curr = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
Obj rest = _35val4411;
Obj _35reg4412 = primCons(rest, Nil);
Obj _35reg4413 = primCons(Nil, _35reg4412);
Obj _35reg4414 = primCons(intern("lambda"), _35reg4413);
Obj _35reg4415 = primCons(curr, Nil);
Obj _35reg4416 = primCons(_35reg4414, _35reg4415);
Obj _35reg4417 = primCons(cc, _35reg4416);
Obj _35reg4418 = primCons(intern("let"), _35reg4417);
co->nargs = 2;
co->args[1] = _35reg4418;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5143(struct Cora* co) {
Obj _35val4391 = co->args[1];
Obj pat = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj action = _35val4391;
pushCont(co, _35clofun5144, 4, action, rules, value, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("macroexpand"));
co->args[1] = pat;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5144(struct Cora* co) {
Obj _35val4392 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
pushCont(co, _35clofun5145, 3, rules, value, cc);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = _35val4392;
co->args[2] = value;
co->args[3] = action;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5145(struct Cora* co) {
Obj _35val4393 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj curr = _35val4393;
Obj _35reg4394 = primCdr(rules);
Obj _35reg4395 = primCdr(_35reg4394);
pushCont(co, _35clofun5146, 2, curr, cc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.match-helper"));
co->args[1] = value;
co->args[2] = _35reg4395;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5146(struct Cora* co) {
Obj _35val4396 = co->args[1];
Obj curr = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
Obj rest = _35val4396;
Obj _35reg4397 = primCons(rest, Nil);
Obj _35reg4398 = primCons(Nil, _35reg4397);
Obj _35reg4399 = primCons(intern("lambda"), _35reg4398);
Obj _35reg4400 = primCons(curr, Nil);
Obj _35reg4401 = primCons(_35reg4399, _35reg4400);
Obj _35reg4402 = primCons(cc, _35reg4401);
Obj _35reg4403 = primCons(intern("let"), _35reg4402);
co->nargs = 2;
co->args[1] = _35reg4403;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5131(struct Cora* co) {
Obj rules = co->args[1];
Obj cc = co->args[2];
Obj _35reg4356 = primCdr(rules);
Obj _35reg4357 = primCar(_35reg4356);
Obj action = _35reg4357;
pushCont(co, _35clofun5132, 2, cc, action);
co->nargs = 2;
co->args[0] = globalRef(intern("pair?"));
co->args[1] = action;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5132(struct Cora* co) {
Obj _35val4358 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj action = co->stack[co->base + 1];
if (True == _35val4358) {
Obj _35reg4359 = primCar(action);
Obj _35reg4360 = primEQ(_35reg4359, intern("where"));
if (True == _35reg4360) {
if (True == True) {
pushCont(co, _35clofun5133, 2, action, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = action;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[1] = action;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
} else {
if (True == False) {
pushCont(co, _35clofun5135, 2, action, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = action;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[1] = action;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}
} else {
if (True == False) {
pushCont(co, _35clofun5137, 2, action, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = action;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[1] = action;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}
}

void _35clofun5137(struct Cora* co) {
Obj _35val4375 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
pushCont(co, _35clofun5138, 2, cc, _35val4375);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = action;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5138(struct Cora* co) {
Obj _35val4376 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35val4375 = co->stack[co->base + 1];
Obj _35reg4377 = primCons(cc, Nil);
Obj _35reg4378 = primCons(_35reg4377, Nil);
Obj _35reg4379 = primCons(_35val4376, _35reg4378);
Obj _35reg4380 = primCons(_35val4375, _35reg4379);
Obj _35reg4381 = primCons(intern("if"), _35reg4380);
co->nargs = 2;
co->args[1] = _35reg4381;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5135(struct Cora* co) {
Obj _35val4368 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
pushCont(co, _35clofun5136, 2, cc, _35val4368);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = action;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5136(struct Cora* co) {
Obj _35val4369 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35val4368 = co->stack[co->base + 1];
Obj _35reg4370 = primCons(cc, Nil);
Obj _35reg4371 = primCons(_35reg4370, Nil);
Obj _35reg4372 = primCons(_35val4369, _35reg4371);
Obj _35reg4373 = primCons(_35val4368, _35reg4372);
Obj _35reg4374 = primCons(intern("if"), _35reg4373);
co->nargs = 2;
co->args[1] = _35reg4374;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5133(struct Cora* co) {
Obj _35val4361 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
pushCont(co, _35clofun5134, 2, cc, _35val4361);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = action;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5134(struct Cora* co) {
Obj _35val4362 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35val4361 = co->stack[co->base + 1];
Obj _35reg4363 = primCons(cc, Nil);
Obj _35reg4364 = primCons(_35reg4363, Nil);
Obj _35reg4365 = primCons(_35val4362, _35reg4364);
Obj _35reg4366 = primCons(_35val4361, _35reg4365);
Obj _35reg4367 = primCons(intern("if"), _35reg4366);
co->nargs = 2;
co->args[1] = _35reg4367;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5125(struct Cora* co) {
Obj pat = co->args[1];
Obj expr = co->args[2];
Obj body = co->args[3];
Obj cc = co->args[4];
Obj literal_63 = makeNative(_35clofun5126, 1, 0);
pushCont(co, _35clofun5128, 4, expr, body, cc, pat);
co->nargs = 2;
co->args[0] = literal_63;
co->args[1] = pat;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5128(struct Cora* co) {
Obj _35val4326 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj pat = co->stack[co->base + 3];
if (True == _35val4326) {
Obj _35reg4327 = primEQ(pat, expr);
if (True == _35reg4327) {
co->nargs = 2;
co->args[1] = body;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4328 = primCons(expr, Nil);
Obj _35reg4329 = primCons(pat, _35reg4328);
Obj _35reg4330 = primCons(intern("="), _35reg4329);
Obj _35reg4331 = primCons(cc, Nil);
Obj _35reg4332 = primCons(_35reg4331, Nil);
Obj _35reg4333 = primCons(body, _35reg4332);
Obj _35reg4334 = primCons(_35reg4330, _35reg4333);
Obj _35reg4335 = primCons(intern("if"), _35reg4334);
co->nargs = 2;
co->args[1] = _35reg4335;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
} else {
Obj _35reg4336 = primIsSymbol(pat);
if (True == _35reg4336) {
Obj _35reg4337 = primCons(body, Nil);
Obj _35reg4338 = primCons(expr, _35reg4337);
Obj _35reg4339 = primCons(pat, _35reg4338);
Obj _35reg4340 = primCons(intern("let"), _35reg4339);
co->nargs = 2;
co->args[1] = _35reg4340;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
pushCont(co, _35clofun5129, 4, expr, body, cc, pat);
co->nargs = 2;
co->args[0] = globalRef(intern("pair?"));
co->args[1] = pat;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun5129(struct Cora* co) {
Obj _35val4341 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj pat = co->stack[co->base + 3];
if (True == _35val4341) {
Obj _35reg4342 = primCar(pat);
Obj _35reg4343 = primEQ(_35reg4342, intern("quote"));
if (True == _35reg4343) {
Obj _35reg4344 = primCons(expr, Nil);
Obj _35reg4345 = primCons(pat, _35reg4344);
Obj _35reg4346 = primCons(intern("="), _35reg4345);
Obj _35reg4347 = primCons(cc, Nil);
Obj _35reg4348 = primCons(_35reg4347, Nil);
Obj _35reg4349 = primCons(body, _35reg4348);
Obj _35reg4350 = primCons(_35reg4346, _35reg4349);
Obj _35reg4351 = primCons(intern("if"), _35reg4350);
co->nargs = 2;
co->args[1] = _35reg4351;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4352 = primCar(pat);
Obj _35reg4353 = primEQ(_35reg4352, intern("cons"));
if (True == _35reg4353) {
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match-cons-expander"));
co->args[1] = pat;
co->args[2] = expr;
co->args[3] = body;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
pushCont(co, _35clofun5130, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("str"));
co->args[1] = makeString1("match fail ");
co->args[2] = pat;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5130(struct Cora* co) {
Obj _35val4354 = co->args[1];
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = _35val4354;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5126(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun5127, 1, x);
co->nargs = 2;
co->args[0] = globalRef(intern("atom?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5127(struct Cora* co) {
Obj _35val4323 = co->args[1];
Obj x = co->stack[co->base + 0];
if (True == _35val4323) {
Obj _35reg4324 = primIsSymbol(x);
Obj _35reg4325 = primNot(_35reg4324);
if (True == _35reg4325) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
} else {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun5107(struct Cora* co) {
Obj pat = co->args[1];
Obj expr = co->args[2];
Obj body = co->args[3];
Obj cc = co->args[4];
pushCont(co, _35clofun5108, 4, pat, expr, body, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = pat;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5108(struct Cora* co) {
Obj _35val4269 = co->args[1];
Obj pat = co->stack[co->base + 0];
Obj expr = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj x = _35val4269;
pushCont(co, _35clofun5109, 4, expr, body, x, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = pat;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5109(struct Cora* co) {
Obj _35val4270 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj x = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj y = _35val4270;
Obj _35reg4271 = primIsCons(expr);
if (True == _35reg4271) {
Obj _35reg4272 = primCar(expr);
Obj _35reg4273 = primEQ(_35reg4272, intern("cons"));
if (True == _35reg4273) {
if (True == True) {
pushCont(co, _35clofun5110, 5, expr, y, body, x, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = expr;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4277 = primCons(expr, Nil);
Obj _35reg4278 = primCons(intern("cons?"), _35reg4277);
Obj _35reg4279 = primCons(expr, Nil);
Obj _35reg4280 = primCons(intern("car"), _35reg4279);
Obj _35reg4281 = primCons(expr, Nil);
Obj _35reg4282 = primCons(intern("cdr"), _35reg4281);
pushCont(co, _35clofun5113, 4, x, _35reg4280, cc, _35reg4278);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = y;
co->args[2] = _35reg4282;
co->args[3] = body;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
pushCont(co, _35clofun5115, 5, expr, y, body, x, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = expr;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4293 = primCons(expr, Nil);
Obj _35reg4294 = primCons(intern("cons?"), _35reg4293);
Obj _35reg4295 = primCons(expr, Nil);
Obj _35reg4296 = primCons(intern("car"), _35reg4295);
Obj _35reg4297 = primCons(expr, Nil);
Obj _35reg4298 = primCons(intern("cdr"), _35reg4297);
pushCont(co, _35clofun5118, 4, x, _35reg4296, cc, _35reg4294);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = y;
co->args[2] = _35reg4298;
co->args[3] = body;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
pushCont(co, _35clofun5120, 5, expr, y, body, x, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = expr;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4309 = primCons(expr, Nil);
Obj _35reg4310 = primCons(intern("cons?"), _35reg4309);
Obj _35reg4311 = primCons(expr, Nil);
Obj _35reg4312 = primCons(intern("car"), _35reg4311);
Obj _35reg4313 = primCons(expr, Nil);
Obj _35reg4314 = primCons(intern("cdr"), _35reg4313);
pushCont(co, _35clofun5123, 4, x, _35reg4312, cc, _35reg4310);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = y;
co->args[2] = _35reg4314;
co->args[3] = body;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun5123(struct Cora* co) {
Obj _35val4315 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg4312 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj _35reg4310 = co->stack[co->base + 3];
pushCont(co, _35clofun5124, 2, cc, _35reg4310);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = x;
co->args[2] = _35reg4312;
co->args[3] = _35val4315;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5124(struct Cora* co) {
Obj _35val4316 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35reg4310 = co->stack[co->base + 1];
Obj _35reg4317 = primCons(cc, Nil);
Obj _35reg4318 = primCons(_35reg4317, Nil);
Obj _35reg4319 = primCons(_35val4316, _35reg4318);
Obj _35reg4320 = primCons(_35reg4310, _35reg4319);
Obj _35reg4321 = primCons(intern("if"), _35reg4320);
co->nargs = 2;
co->args[1] = _35reg4321;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5120(struct Cora* co) {
Obj _35val4306 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj x = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e1 = _35val4306;
pushCont(co, _35clofun5121, 5, y, body, x, e1, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = expr;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5121(struct Cora* co) {
Obj _35val4307 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj x = co->stack[co->base + 2];
Obj e1 = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e2 = _35val4307;
pushCont(co, _35clofun5122, 3, x, e1, cc);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = y;
co->args[2] = e2;
co->args[3] = body;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5122(struct Cora* co) {
Obj _35val4308 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj e1 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = x;
co->args[2] = e1;
co->args[3] = _35val4308;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5118(struct Cora* co) {
Obj _35val4299 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg4296 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj _35reg4294 = co->stack[co->base + 3];
pushCont(co, _35clofun5119, 2, cc, _35reg4294);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = x;
co->args[2] = _35reg4296;
co->args[3] = _35val4299;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5119(struct Cora* co) {
Obj _35val4300 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35reg4294 = co->stack[co->base + 1];
Obj _35reg4301 = primCons(cc, Nil);
Obj _35reg4302 = primCons(_35reg4301, Nil);
Obj _35reg4303 = primCons(_35val4300, _35reg4302);
Obj _35reg4304 = primCons(_35reg4294, _35reg4303);
Obj _35reg4305 = primCons(intern("if"), _35reg4304);
co->nargs = 2;
co->args[1] = _35reg4305;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5115(struct Cora* co) {
Obj _35val4290 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj x = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e1 = _35val4290;
pushCont(co, _35clofun5116, 5, y, body, x, e1, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = expr;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5116(struct Cora* co) {
Obj _35val4291 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj x = co->stack[co->base + 2];
Obj e1 = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e2 = _35val4291;
pushCont(co, _35clofun5117, 3, x, e1, cc);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = y;
co->args[2] = e2;
co->args[3] = body;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5117(struct Cora* co) {
Obj _35val4292 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj e1 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = x;
co->args[2] = e1;
co->args[3] = _35val4292;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5113(struct Cora* co) {
Obj _35val4283 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg4280 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj _35reg4278 = co->stack[co->base + 3];
pushCont(co, _35clofun5114, 2, cc, _35reg4278);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = x;
co->args[2] = _35reg4280;
co->args[3] = _35val4283;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5114(struct Cora* co) {
Obj _35val4284 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35reg4278 = co->stack[co->base + 1];
Obj _35reg4285 = primCons(cc, Nil);
Obj _35reg4286 = primCons(_35reg4285, Nil);
Obj _35reg4287 = primCons(_35val4284, _35reg4286);
Obj _35reg4288 = primCons(_35reg4278, _35reg4287);
Obj _35reg4289 = primCons(intern("if"), _35reg4288);
co->nargs = 2;
co->args[1] = _35reg4289;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5110(struct Cora* co) {
Obj _35val4274 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj x = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e1 = _35val4274;
pushCont(co, _35clofun5111, 5, y, body, x, e1, cc);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = expr;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5111(struct Cora* co) {
Obj _35val4275 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj x = co->stack[co->base + 2];
Obj e1 = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e2 = _35val4275;
pushCont(co, _35clofun5112, 3, x, e1, cc);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = y;
co->args[2] = e2;
co->args[3] = body;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5112(struct Cora* co) {
Obj _35val4276 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj e1 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
co->nargs = 5;
co->args[0] = globalRef(intern("cora/init.match1"));
co->args[1] = x;
co->args[2] = e1;
co->args[3] = _35val4276;
co->args[4] = cc;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5105(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4267 = primCdr(exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rcons1"));
co->args[1] = _35reg4267;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5102(struct Cora* co) {
Obj pat = co->args[1];
Obj _35reg4257 = primCdr(pat);
pushCont(co, _35clofun5103, 1, pat);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = _35reg4257;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5103(struct Cora* co) {
Obj _35val4258 = co->args[1];
Obj pat = co->stack[co->base + 0];
if (True == _35val4258) {
Obj _35reg4259 = primCar(pat);
co->nargs = 2;
co->args[1] = _35reg4259;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4260 = primCar(pat);
Obj _35reg4261 = primCdr(pat);
pushCont(co, _35clofun5104, 1, _35reg4260);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rcons1"));
co->args[1] = _35reg4261;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5104(struct Cora* co) {
Obj _35val4262 = co->args[1];
Obj _35reg4260 = co->stack[co->base + 0];
Obj _35reg4263 = primCons(_35val4262, Nil);
Obj _35reg4264 = primCons(_35reg4260, _35reg4263);
Obj _35reg4265 = primCons(intern("cons"), _35reg4264);
co->nargs = 2;
co->args[1] = _35reg4265;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5101(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4254 = primEQ(x, True);
if (True == _35reg4254) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4255 = primEQ(x, False);
if (True == _35reg4255) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}
}

void _35clofun5099(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4252 = primCdr(exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-and"));
co->args[1] = _35reg4252;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5097(struct Cora* co) {
Obj l = co->args[1];
Obj _35reg4240 = primEQ(Nil, l);
if (True == _35reg4240) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4241 = primCar(l);
Obj _35reg4242 = primEQ(_35reg4241, False);
if (True == _35reg4242) {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4243 = primCdr(l);
pushCont(co, _35clofun5098, 1, l);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-and"));
co->args[1] = _35reg4243;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun5098(struct Cora* co) {
Obj _35val4244 = co->args[1];
Obj l = co->stack[co->base + 0];
Obj more = _35val4244;
Obj _35reg4245 = primEQ(more, False);
if (True == _35reg4245) {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4246 = primCar(l);
Obj _35reg4247 = primCons(False, Nil);
Obj _35reg4248 = primCons(more, _35reg4247);
Obj _35reg4249 = primCons(_35reg4246, _35reg4248);
Obj _35reg4250 = primCons(intern("if"), _35reg4249);
co->nargs = 2;
co->args[1] = _35reg4250;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun5095(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4238 = primCdr(exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-or"));
co->args[1] = _35reg4238;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5093(struct Cora* co) {
Obj l = co->args[1];
Obj _35reg4226 = primEQ(l, Nil);
if (True == _35reg4226) {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4227 = primCar(l);
Obj _35reg4228 = primEQ(_35reg4227, True);
if (True == _35reg4228) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4229 = primCdr(l);
pushCont(co, _35clofun5094, 1, l);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-or"));
co->args[1] = _35reg4229;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun5094(struct Cora* co) {
Obj _35val4230 = co->args[1];
Obj l = co->stack[co->base + 0];
Obj more = _35val4230;
Obj _35reg4231 = primEQ(more, True);
if (True == _35reg4231) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4232 = primCar(l);
Obj _35reg4233 = primCons(more, Nil);
Obj _35reg4234 = primCons(True, _35reg4233);
Obj _35reg4235 = primCons(_35reg4232, _35reg4234);
Obj _35reg4236 = primCons(intern("if"), _35reg4235);
co->nargs = 2;
co->args[1] = _35reg4236;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun5088(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4212 = primCdr(exp);
Obj _35reg4213 = primEQ(Nil, _35reg4212);
if (True == _35reg4213) {
Obj _35reg4214 = primCons(makeString1("no cond match"), Nil);
Obj _35reg4215 = primCons(intern("error"), _35reg4214);
co->nargs = 2;
co->args[1] = _35reg4215;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
pushCont(co, _35clofun5089, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5089(struct Cora* co) {
Obj _35val4216 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj curr = _35val4216;
Obj _35reg4217 = primCar(curr);
pushCont(co, _35clofun5090, 2, exp, _35reg4217);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = curr;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5090(struct Cora* co) {
Obj _35val4218 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg4217 = co->stack[co->base + 1];
pushCont(co, _35clofun5091, 2, _35val4218, _35reg4217);
co->nargs = 2;
co->args[0] = globalRef(intern("cddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5091(struct Cora* co) {
Obj _35val4219 = co->args[1];
Obj _35val4218 = co->stack[co->base + 0];
Obj _35reg4217 = co->stack[co->base + 1];
Obj _35reg4220 = primCons(intern("cond"), _35val4219);
Obj _35reg4221 = primCons(_35reg4220, Nil);
Obj _35reg4222 = primCons(_35val4218, _35reg4221);
Obj _35reg4223 = primCons(_35reg4217, _35reg4222);
Obj _35reg4224 = primCons(intern("if"), _35reg4223);
co->nargs = 2;
co->args[1] = _35reg4224;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5086(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4210 = primCdr(exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-let"));
co->args[1] = _35reg4210;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5081(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4198 = primCdr(exp);
pushCont(co, _35clofun5082, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = _35reg4198;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5082(struct Cora* co) {
Obj _35val4199 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val4199) {
Obj _35reg4200 = primCar(exp);
co->nargs = 2;
co->args[1] = _35reg4200;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4201 = primCar(exp);
pushCont(co, _35clofun5083, 2, exp, _35reg4201);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5083(struct Cora* co) {
Obj _35val4202 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg4201 = co->stack[co->base + 1];
pushCont(co, _35clofun5084, 2, _35val4202, _35reg4201);
co->nargs = 2;
co->args[0] = globalRef(intern("cddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5084(struct Cora* co) {
Obj _35val4203 = co->args[1];
Obj _35val4202 = co->stack[co->base + 0];
Obj _35reg4201 = co->stack[co->base + 1];
pushCont(co, _35clofun5085, 2, _35val4202, _35reg4201);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.rewrite-let"));
co->args[1] = _35val4203;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5085(struct Cora* co) {
Obj _35val4204 = co->args[1];
Obj _35val4202 = co->stack[co->base + 0];
Obj _35reg4201 = co->stack[co->base + 1];
Obj _35reg4205 = primCons(_35val4204, Nil);
Obj _35reg4206 = primCons(_35val4202, _35reg4205);
Obj _35reg4207 = primCons(_35reg4201, _35reg4206);
Obj _35reg4208 = primCons(intern("let"), _35reg4207);
co->nargs = 2;
co->args[1] = _35reg4208;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5080(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4195 = primIsCons(x);
Obj _35reg4196 = primNot(_35reg4195);
co->nargs = 2;
co->args[1] = _35reg4196;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5079(struct Cora* co) {
Obj x = co->args[1];
Obj l = co->args[2];
Obj _35reg4190 = primIsCons(l);
if (True == _35reg4190) {
Obj _35reg4191 = primCar(l);
Obj _35reg4192 = primEQ(_35reg4191, x);
if (True == _35reg4192) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4193 = primCdr(l);
co->nargs = 3;
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = _35reg4193;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun5074(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun5075, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5075(struct Cora* co) {
Obj _35val4178 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg4179 = primCons(_35val4178, Nil);
Obj _35reg4180 = primCons(intern("quote"), _35reg4179);
pushCont(co, _35clofun5076, 2, exp, _35reg4180);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5076(struct Cora* co) {
Obj _35val4181 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg4180 = co->stack[co->base + 1];
pushCont(co, _35clofun5077, 2, _35val4181, _35reg4180);
co->nargs = 2;
co->args[0] = globalRef(intern("cadddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5077(struct Cora* co) {
Obj _35val4182 = co->args[1];
Obj _35val4181 = co->stack[co->base + 0];
Obj _35reg4180 = co->stack[co->base + 1];
Obj _35reg4183 = primCons(_35val4182, Nil);
Obj _35reg4184 = primCons(_35val4181, _35reg4183);
Obj _35reg4185 = primCons(intern("lambda"), _35reg4184);
Obj _35reg4186 = primCons(_35reg4185, Nil);
Obj _35reg4187 = primCons(_35reg4180, _35reg4186);
Obj _35reg4188 = primCons(intern("set"), _35reg4187);
co->nargs = 2;
co->args[1] = _35reg4188;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5072(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4176 = primCdr(exp);
co->nargs = 2;
co->args[0] = globalRef(intern("rcons"));
co->args[1] = _35reg4176;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5067(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun5068, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5068(struct Cora* co) {
Obj _35val4164 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg4165 = primCons(_35val4164, Nil);
Obj _35reg4166 = primCons(intern("quote"), _35reg4165);
pushCont(co, _35clofun5069, 2, exp, _35reg4166);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5069(struct Cora* co) {
Obj _35val4167 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg4166 = co->stack[co->base + 1];
pushCont(co, _35clofun5070, 2, _35val4167, _35reg4166);
co->nargs = 2;
co->args[0] = globalRef(intern("cdddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5070(struct Cora* co) {
Obj _35val4168 = co->args[1];
Obj _35val4167 = co->stack[co->base + 0];
Obj _35reg4166 = co->stack[co->base + 1];
Obj _35reg4169 = primCons(_35val4167, _35val4168);
Obj _35reg4170 = primCons(intern("lambda"), _35reg4169);
Obj _35reg4171 = primCons(_35reg4170, Nil);
Obj _35reg4172 = primCons(_35reg4166, _35reg4171);
Obj _35reg4173 = primCons(intern("cora/init.add-to-*macros*"), _35reg4172);
co->nargs = 2;
co->args[1] = _35reg4173;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5061(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4146 = primIsCons(exp);
if (True == _35reg4146) {
Obj _35reg4147 = primCar(exp);
Obj _35reg4148 = primEQ(_35reg4147, globalRef(intern("*protect-symbol*")));
if (True == _35reg4148) {
Obj _35reg4149 = primCdr(exp);
co->nargs = 2;
co->args[1] = _35reg4149;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4150 = primCar(exp);
Obj _35reg4151 = primEQ(_35reg4150, intern("lambda"));
if (True == _35reg4151) {
pushCont(co, _35clofun5062, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4158 = primCar(exp);
Obj _35reg4159 = primEQ(_35reg4158, intern("quote"));
if (True == _35reg4159) {
co->nargs = 2;
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
pushCont(co, _35clofun5065, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.macroexpand1"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
} else {
co->nargs = 2;
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun5065(struct Cora* co) {
Obj _35val4161 = co->args[1];
Obj exp = co->stack[co->base + 0];
co->nargs = 2;
co->args[0] = makeNative(_35clofun5066, 1, 1, exp);
co->args[1] = _35val4161;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5066(struct Cora* co) {
Obj exp1 = co->args[1];
Obj _35reg4160 = primEQ(exp1, closureRef(co, 0));
if (True == _35reg4160) {
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/init.macroexpand-boot"));
co->args[2] = exp1;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.macroexpand-boot"));
co->args[1] = exp1;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5062(struct Cora* co) {
Obj _35val4152 = co->args[1];
Obj exp = co->stack[co->base + 0];
pushCont(co, _35clofun5063, 1, _35val4152);
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5063(struct Cora* co) {
Obj _35val4153 = co->args[1];
Obj _35val4152 = co->stack[co->base + 0];
pushCont(co, _35clofun5064, 1, _35val4152);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/init.macroexpand-boot"));
co->args[1] = _35val4153;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5064(struct Cora* co) {
Obj _35val4154 = co->args[1];
Obj _35val4152 = co->stack[co->base + 0];
Obj _35reg4155 = primCons(_35val4154, Nil);
Obj _35reg4156 = primCons(_35val4152, _35reg4155);
Obj _35reg4157 = primCons(intern("lambda"), _35reg4156);
co->nargs = 2;
co->args[1] = _35reg4157;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5060(struct Cora* co) {
Obj exp = co->args[1];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.macroexpand1-h"));
co->args[1] = exp;
co->args[2] = globalRef(intern("*macros*"));
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5058(struct Cora* co) {
Obj exp = co->args[1];
Obj macros = co->args[2];
Obj _35reg4132 = primEQ(Nil, macros);
if (True == _35reg4132) {
co->nargs = 2;
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg4143 = primCar(macros);
co->nargs = 2;
co->args[0] = makeNative(_35clofun5059, 1, 2, exp, macros);
co->args[1] = _35reg4143;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5059(struct Cora* co) {
Obj item = co->args[1];
Obj _35reg4133 = primIsCons(closureRef(co, 0));
if (True == _35reg4133) {
Obj _35reg4134 = primCar(closureRef(co, 0));
Obj _35reg4135 = primCar(item);
Obj _35reg4136 = primEQ(_35reg4134, _35reg4135);
if (True == _35reg4136) {
if (True == True) {
Obj _35reg4137 = primCdr(item);
co->nargs = 2;
co->args[0] = _35reg4137;
co->args[1] = closureRef(co, 0);
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4138 = primCdr(closureRef(co, 1));
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.macroexpand1-h"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg4138;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg4139 = primCdr(item);
co->nargs = 2;
co->args[0] = _35reg4139;
co->args[1] = closureRef(co, 0);
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4140 = primCdr(closureRef(co, 1));
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.macroexpand1-h"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg4140;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
Obj _35reg4141 = primCdr(item);
co->nargs = 2;
co->args[0] = _35reg4141;
co->args[1] = closureRef(co, 0);
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg4142 = primCdr(closureRef(co, 1));
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.macroexpand1-h"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg4142;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun5057(struct Cora* co) {
Obj n = co->args[1];
Obj v = co->args[2];
Obj _35reg4128 = primCons(n, v);
Obj _35reg4129 = primCons(_35reg4128, globalRef(intern("*macros*")));
Obj _35reg4130 = primSet(intern("*macros*"), _35reg4129);
co->nargs = 2;
co->args[1] = _35reg4130;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5056(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4126 = primCons(globalRef(intern("*protect-symbol*")), x);
co->nargs = 2;
co->args[1] = _35reg4126;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5055(struct Cora* co) {
Obj f = co->args[1];
Obj l = co->args[2];
co->nargs = 4;
co->args[0] = globalRef(intern("map-h"));
co->args[1] = Nil;
co->args[2] = f;
co->args[3] = l;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5053(struct Cora* co) {
Obj res = co->args[1];
Obj f = co->args[2];
Obj l = co->args[3];
Obj _35reg4116 = primIsCons(l);
if (True == _35reg4116) {
Obj _35reg4117 = primCar(l);
pushCont(co, _35clofun5054, 3, res, l, f);
co->nargs = 2;
co->args[0] = f;
co->args[1] = _35reg4117;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("reverse"));
co->args[1] = res;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun5054(struct Cora* co) {
Obj _35val4118 = co->args[1];
Obj res = co->stack[co->base + 0];
Obj l = co->stack[co->base + 1];
Obj f = co->stack[co->base + 2];
Obj _35reg4119 = primCons(_35val4118, res);
Obj _35reg4120 = primCdr(l);
co->nargs = 4;
co->args[0] = globalRef(intern("map-h"));
co->args[1] = _35reg4119;
co->args[2] = f;
co->args[3] = _35reg4120;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun5051(struct Cora* co) {
Obj res = co->args[1];
Obj l = co->args[2];
Obj _35reg4109 = primIsCons(l);
if (True == _35reg4109) {
Obj _35reg4110 = primCar(l);
Obj _35reg4111 = primCons(_35reg4110, res);
Obj _35reg4112 = primCdr(l);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.reverse-h"));
co->args[1] = _35reg4111;
co->args[2] = _35reg4112;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[1] = res;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun5050(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4107 = primIsCons(x);
co->nargs = 2;
co->args[1] = _35reg4107;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5048(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg4099 = primIsCons(exp);
if (True == _35reg4099) {
Obj _35reg4100 = primCar(exp);
Obj _35reg4101 = primCdr(exp);
pushCont(co, _35clofun5049, 1, _35reg4100);
co->nargs = 2;
co->args[0] = globalRef(intern("rcons"));
co->args[1] = _35reg4101;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun5049(struct Cora* co) {
Obj _35val4102 = co->args[1];
Obj _35reg4100 = co->stack[co->base + 0];
Obj _35reg4103 = primCons(_35val4102, Nil);
Obj _35reg4104 = primCons(_35reg4100, _35reg4103);
Obj _35reg4105 = primCons(intern("cons"), _35reg4104);
co->nargs = 2;
co->args[1] = _35reg4105;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5047(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4095 = primCdr(x);
Obj _35reg4096 = primCdr(_35reg4095);
Obj _35reg4097 = primCdr(_35reg4096);
co->nargs = 2;
co->args[1] = _35reg4097;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5046(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4090 = primCdr(x);
Obj _35reg4091 = primCdr(_35reg4090);
Obj _35reg4092 = primCdr(_35reg4091);
Obj _35reg4093 = primCar(_35reg4092);
co->nargs = 2;
co->args[1] = _35reg4093;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5045(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4086 = primCdr(x);
Obj _35reg4087 = primCdr(_35reg4086);
Obj _35reg4088 = primCar(_35reg4087);
co->nargs = 2;
co->args[1] = _35reg4088;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5044(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4083 = primCdr(x);
Obj _35reg4084 = primCdr(_35reg4083);
co->nargs = 2;
co->args[1] = _35reg4084;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5043(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4080 = primCar(x);
Obj _35reg4081 = primCdr(_35reg4080);
co->nargs = 2;
co->args[1] = _35reg4081;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5042(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4077 = primCar(x);
Obj _35reg4078 = primCar(_35reg4077);
co->nargs = 2;
co->args[1] = _35reg4078;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5041(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4074 = primCdr(x);
Obj _35reg4075 = primCar(_35reg4074);
co->nargs = 2;
co->args[1] = _35reg4075;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun5040(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg4072 = primEQ(x, Nil);
co->nargs = 2;
co->args[1] = _35reg4072;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

