#include "types.h"
#include "runtime.h"

void entry(struct Cora* co);
void _35clofun1018(struct Cora* co);
void _35clofun1037(struct Cora* co);
void _35clofun1039(struct Cora* co);
void _35clofun1044(struct Cora* co);
void _35clofun1053(struct Cora* co);
void _35clofun1058(struct Cora* co);
void _35clofun1062(struct Cora* co);
void _35clofun1066(struct Cora* co);
void _35clofun1072(struct Cora* co);
void _35clofun1129(struct Cora* co);
void _35clofun1163(struct Cora* co);
void _35clofun1207(struct Cora* co);
void _35clofun1214(struct Cora* co);
void _35clofun1215(struct Cora* co);
void _35clofun1208(struct Cora* co);
void _35clofun1209(struct Cora* co);
void _35clofun1210(struct Cora* co);
void _35clofun1213(struct Cora* co);
void _35clofun1211(struct Cora* co);
void _35clofun1212(struct Cora* co);
void _35clofun1206(struct Cora* co);
void _35clofun1201(struct Cora* co);
void _35clofun1202(struct Cora* co);
void _35clofun1203(struct Cora* co);
void _35clofun1205(struct Cora* co);
void _35clofun1204(struct Cora* co);
void _35clofun1199(struct Cora* co);
void _35clofun1200(struct Cora* co);
void _35clofun1176(struct Cora* co);
void _35clofun1177(struct Cora* co);
void _35clofun1198(struct Cora* co);
void _35clofun1178(struct Cora* co);
void _35clofun1197(struct Cora* co);
void _35clofun1179(struct Cora* co);
void _35clofun1196(struct Cora* co);
void _35clofun1180(struct Cora* co);
void _35clofun1194(struct Cora* co);
void _35clofun1195(struct Cora* co);
void _35clofun1181(struct Cora* co);
void _35clofun1193(struct Cora* co);
void _35clofun1182(struct Cora* co);
void _35clofun1192(struct Cora* co);
void _35clofun1183(struct Cora* co);
void _35clofun1189(struct Cora* co);
void _35clofun1190(struct Cora* co);
void _35clofun1191(struct Cora* co);
void _35clofun1184(struct Cora* co);
void _35clofun1188(struct Cora* co);
void _35clofun1185(struct Cora* co);
void _35clofun1186(struct Cora* co);
void _35clofun1187(struct Cora* co);
void _35clofun1164(struct Cora* co);
void _35clofun1165(struct Cora* co);
void _35clofun1166(struct Cora* co);
void _35clofun1167(struct Cora* co);
void _35clofun1168(struct Cora* co);
void _35clofun1169(struct Cora* co);
void _35clofun1170(struct Cora* co);
void _35clofun1171(struct Cora* co);
void _35clofun1172(struct Cora* co);
void _35clofun1173(struct Cora* co);
void _35clofun1174(struct Cora* co);
void _35clofun1175(struct Cora* co);
void _35clofun1157(struct Cora* co);
void _35clofun1158(struct Cora* co);
void _35clofun1159(struct Cora* co);
void _35clofun1160(struct Cora* co);
void _35clofun1161(struct Cora* co);
void _35clofun1162(struct Cora* co);
void _35clofun1155(struct Cora* co);
void _35clofun1156(struct Cora* co);
void _35clofun1148(struct Cora* co);
void _35clofun1149(struct Cora* co);
void _35clofun1151(struct Cora* co);
void _35clofun1153(struct Cora* co);
void _35clofun1154(struct Cora* co);
void _35clofun1152(struct Cora* co);
void _35clofun1150(struct Cora* co);
void _35clofun1146(struct Cora* co);
void _35clofun1147(struct Cora* co);
void _35clofun1145(struct Cora* co);
void _35clofun1143(struct Cora* co);
void _35clofun1144(struct Cora* co);
void _35clofun1142(struct Cora* co);
void _35clofun1141(struct Cora* co);
void _35clofun1138(struct Cora* co);
void _35clofun1139(struct Cora* co);
void _35clofun1140(struct Cora* co);
void _35clofun1137(struct Cora* co);
void _35clofun1130(struct Cora* co);
void _35clofun1131(struct Cora* co);
void _35clofun1136(struct Cora* co);
void _35clofun1132(struct Cora* co);
void _35clofun1135(struct Cora* co);
void _35clofun1133(struct Cora* co);
void _35clofun1134(struct Cora* co);
void _35clofun1128(struct Cora* co);
void _35clofun1121(struct Cora* co);
void _35clofun1122(struct Cora* co);
void _35clofun1123(struct Cora* co);
void _35clofun1124(struct Cora* co);
void _35clofun1127(struct Cora* co);
void _35clofun1126(struct Cora* co);
void _35clofun1125(struct Cora* co);
void _35clofun1105(struct Cora* co);
void _35clofun1106(struct Cora* co);
void _35clofun1107(struct Cora* co);
void _35clofun1117(struct Cora* co);
void _35clofun1118(struct Cora* co);
void _35clofun1119(struct Cora* co);
void _35clofun1120(struct Cora* co);
void _35clofun1108(struct Cora* co);
void _35clofun1113(struct Cora* co);
void _35clofun1114(struct Cora* co);
void _35clofun1115(struct Cora* co);
void _35clofun1116(struct Cora* co);
void _35clofun1109(struct Cora* co);
void _35clofun1110(struct Cora* co);
void _35clofun1111(struct Cora* co);
void _35clofun1112(struct Cora* co);
void _35clofun1097(struct Cora* co);
void _35clofun1098(struct Cora* co);
void _35clofun1103(struct Cora* co);
void _35clofun1104(struct Cora* co);
void _35clofun1101(struct Cora* co);
void _35clofun1102(struct Cora* co);
void _35clofun1099(struct Cora* co);
void _35clofun1100(struct Cora* co);
void _35clofun1091(struct Cora* co);
void _35clofun1094(struct Cora* co);
void _35clofun1095(struct Cora* co);
void _35clofun1096(struct Cora* co);
void _35clofun1092(struct Cora* co);
void _35clofun1093(struct Cora* co);
void _35clofun1073(struct Cora* co);
void _35clofun1074(struct Cora* co);
void _35clofun1075(struct Cora* co);
void _35clofun1089(struct Cora* co);
void _35clofun1090(struct Cora* co);
void _35clofun1086(struct Cora* co);
void _35clofun1087(struct Cora* co);
void _35clofun1088(struct Cora* co);
void _35clofun1084(struct Cora* co);
void _35clofun1085(struct Cora* co);
void _35clofun1081(struct Cora* co);
void _35clofun1082(struct Cora* co);
void _35clofun1083(struct Cora* co);
void _35clofun1079(struct Cora* co);
void _35clofun1080(struct Cora* co);
void _35clofun1076(struct Cora* co);
void _35clofun1077(struct Cora* co);
void _35clofun1078(struct Cora* co);
void _35clofun1071(struct Cora* co);
void _35clofun1068(struct Cora* co);
void _35clofun1069(struct Cora* co);
void _35clofun1070(struct Cora* co);
void _35clofun1067(struct Cora* co);
void _35clofun1065(struct Cora* co);
void _35clofun1063(struct Cora* co);
void _35clofun1064(struct Cora* co);
void _35clofun1061(struct Cora* co);
void _35clofun1059(struct Cora* co);
void _35clofun1060(struct Cora* co);
void _35clofun1054(struct Cora* co);
void _35clofun1055(struct Cora* co);
void _35clofun1056(struct Cora* co);
void _35clofun1057(struct Cora* co);
void _35clofun1052(struct Cora* co);
void _35clofun1047(struct Cora* co);
void _35clofun1048(struct Cora* co);
void _35clofun1049(struct Cora* co);
void _35clofun1050(struct Cora* co);
void _35clofun1051(struct Cora* co);
void _35clofun1046(struct Cora* co);
void _35clofun1045(struct Cora* co);
void _35clofun1040(struct Cora* co);
void _35clofun1041(struct Cora* co);
void _35clofun1042(struct Cora* co);
void _35clofun1043(struct Cora* co);
void _35clofun1038(struct Cora* co);
void _35clofun1033(struct Cora* co);
void _35clofun1034(struct Cora* co);
void _35clofun1035(struct Cora* co);
void _35clofun1036(struct Cora* co);
void _35clofun1027(struct Cora* co);
void _35clofun1031(struct Cora* co);
void _35clofun1032(struct Cora* co);
void _35clofun1028(struct Cora* co);
void _35clofun1029(struct Cora* co);
void _35clofun1030(struct Cora* co);
void _35clofun1026(struct Cora* co);
void _35clofun1024(struct Cora* co);
void _35clofun1025(struct Cora* co);
void _35clofun1023(struct Cora* co);
void _35clofun1022(struct Cora* co);
void _35clofun1021(struct Cora* co);
void _35clofun1019(struct Cora* co);
void _35clofun1020(struct Cora* co);
void _35clofun1017(struct Cora* co);
void _35clofun1016(struct Cora* co);
void _35clofun1014(struct Cora* co);
void _35clofun1015(struct Cora* co);
void _35clofun1013(struct Cora* co);
void _35clofun1012(struct Cora* co);
void _35clofun1011(struct Cora* co);
void _35clofun1010(struct Cora* co);
void _35clofun1009(struct Cora* co);
void _35clofun1008(struct Cora* co);
void _35clofun1007(struct Cora* co);
void _35clofun1006(struct Cora* co);

void entry(struct Cora* co) {
Obj _35reg39 = primSet(intern("null?"), makeNative(_35clofun1006, 1, 0));
Obj _35reg42 = primSet(intern("cadr"), makeNative(_35clofun1007, 1, 0));
Obj _35reg45 = primSet(intern("caar"), makeNative(_35clofun1008, 1, 0));
Obj _35reg48 = primSet(intern("cdar"), makeNative(_35clofun1009, 1, 0));
Obj _35reg51 = primSet(intern("cddr"), makeNative(_35clofun1010, 1, 0));
Obj _35reg55 = primSet(intern("caddr"), makeNative(_35clofun1011, 1, 0));
Obj _35reg60 = primSet(intern("cadddr"), makeNative(_35clofun1012, 1, 0));
Obj _35reg64 = primSet(intern("cdddr"), makeNative(_35clofun1013, 1, 0));
Obj _35reg72 = primSet(intern("rcons"), makeNative(_35clofun1014, 1, 0));
Obj _35reg74 = primSet(intern("pair?"), makeNative(_35clofun1016, 1, 0));
Obj _35reg79 = primSet(intern("cora/init.reverse-h"), makeNative(_35clofun1017, 2, 0));
pushCont(co, _35clofun1018, 0);
coraCall(co, 2, globalRef(intern("cora/init.reverse-h")), Nil);
}

void _35clofun1018(struct Cora* co) {
Obj _35val80 = co->args[1];
Obj _35reg81 = primSet(intern("reverse"), _35val80);
Obj _35reg87 = primSet(intern("map-h"), makeNative(_35clofun1019, 3, 0));
Obj _35reg88 = primSet(intern("map"), makeNative(_35clofun1021, 2, 0));
Obj _35reg89 = primSet(intern("*macros*"), Nil);
Obj _35reg90 = primGenSym(intern("protect"));
Obj _35reg91 = primSet(intern("*protect-symbol*"), _35reg90);
Obj _35reg93 = primSet(intern("cora/init.protect"), makeNative(_35clofun1022, 1, 0));
Obj _35reg97 = primSet(intern("cora/init.add-to-*macros*"), makeNative(_35clofun1023, 2, 0));
Obj _35reg110 = primSet(intern("cora/init.macroexpand1-h"), makeNative(_35clofun1024, 2, 0));
Obj _35reg111 = primSet(intern("cora/init.macroexpand1"), makeNative(_35clofun1026, 1, 0));
Obj _35reg128 = primSet(intern("cora/init.macroexpand-boot"), makeNative(_35clofun1027, 1, 0));
Obj _35reg129 = primSet(intern("macroexpand"), globalRef(intern("cora/init.macroexpand-boot")));
Obj _35reg140 = primSet(intern("defmacro-macro"), makeNative(_35clofun1033, 1, 0));
pushCont(co, _35clofun1037, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("defmacro"), globalRef(intern("defmacro-macro")));
}

void _35clofun1037(struct Cora* co) {
Obj _35val141 = co->args[1];
pushCont(co, _35clofun1039, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("list"), makeNative(_35clofun1038, 1, 0));
}

void _35clofun1039(struct Cora* co) {
Obj _35val143 = co->args[1];
pushCont(co, _35clofun1044, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("defun"), makeNative(_35clofun1040, 1, 0));
}

void _35clofun1044(struct Cora* co) {
Obj _35val155 = co->args[1];
Obj _35reg160 = primSet(intern("elem?"), makeNative(_35clofun1045, 2, 0));
Obj _35reg163 = primSet(intern("atom?"), makeNative(_35clofun1046, 1, 0));
Obj _35reg175 = primSet(intern("cora/init.rewrite-let"), makeNative(_35clofun1047, 1, 0));
pushCont(co, _35clofun1053, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("let"), makeNative(_35clofun1052, 1, 0));
}

void _35clofun1053(struct Cora* co) {
Obj _35val177 = co->args[1];
pushCont(co, _35clofun1058, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("cond"), makeNative(_35clofun1054, 1, 0));
}

void _35clofun1058(struct Cora* co) {
Obj _35val191 = co->args[1];
Obj _35reg203 = primSet(intern("cora/init.rewrite-or"), makeNative(_35clofun1059, 1, 0));
pushCont(co, _35clofun1062, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("or"), makeNative(_35clofun1061, 1, 0));
}

void _35clofun1062(struct Cora* co) {
Obj _35val205 = co->args[1];
Obj _35reg217 = primSet(intern("cora/init.rewrite-and"), makeNative(_35clofun1063, 1, 0));
pushCont(co, _35clofun1066, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("and"), makeNative(_35clofun1065, 1, 0));
}

void _35clofun1066(struct Cora* co) {
Obj _35val219 = co->args[1];
Obj _35reg222 = primSet(intern("boolean?"), makeNative(_35clofun1067, 1, 0));
Obj _35reg232 = primSet(intern("cora/init.rcons1"), makeNative(_35clofun1068, 1, 0));
pushCont(co, _35clofun1072, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("list-rest"), makeNative(_35clofun1071, 1, 0));
}

void _35clofun1072(struct Cora* co) {
Obj _35val234 = co->args[1];
Obj _35reg288 = primSet(intern("cora/init.match-cons-expander"), makeNative(_35clofun1073, 4, 0));
Obj _35reg321 = primSet(intern("cora/init.match1"), makeNative(_35clofun1091, 4, 0));
Obj _35reg348 = primSet(intern("cora/init.extract-rule-action"), makeNative(_35clofun1097, 2, 0));
Obj _35reg400 = primSet(intern("cora/init.match-helper"), makeNative(_35clofun1105, 2, 0));
Obj _35reg426 = primSet(intern("cora/init.rewrite-match"), makeNative(_35clofun1121, 1, 0));
pushCont(co, _35clofun1129, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("match"), makeNative(_35clofun1128, 1, 0));
}

void _35clofun1129(struct Cora* co) {
Obj _35val427 = co->args[1];
Obj _35reg479 = primSet(intern("cora/init.extract-rules1"), makeNative(_35clofun1130, 3, 0));
Obj _35reg480 = primSet(intern("cora/init.extract-rules"), makeNative(_35clofun1137, 1, 0));
Obj _35reg485 = primSet(intern("cora/init.rules-patterns"), makeNative(_35clofun1138, 2, 0));
Obj _35reg489 = primSet(intern("cora/init.length-h"), makeNative(_35clofun1141, 2, 0));
Obj _35reg490 = primSet(intern("length"), makeNative(_35clofun1142, 1, 0));
Obj _35reg498 = primSet(intern("cora/init.filter-h"), makeNative(_35clofun1143, 3, 0));
Obj _35reg499 = primSet(intern("filter"), makeNative(_35clofun1145, 2, 0));
Obj _35reg505 = primSet(intern("append"), makeNative(_35clofun1146, 2, 0));
Obj _35reg516 = primSet(intern("cora/init.rules-arg-count"), makeNative(_35clofun1148, 1, 0));
Obj _35reg522 = primSet(intern("cora/init.gen-parameters"), makeNative(_35clofun1155, 1, 0));
pushCont(co, _35clofun1163, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("func"), makeNative(_35clofun1157, 1, 0));
}

void _35clofun1163(struct Cora* co) {
Obj _35val535 = co->args[1];
Obj _35reg798 = primSet(intern("cora/init.propagate-boolean0"), makeNative(_35clofun1164, 1, 0));
Obj _35reg956 = primSet(intern("cora/init.propagate-boolean"), makeNative(_35clofun1176, 1, 0));
Obj _35reg958 = primSet(intern("macroexpand"), makeNative(_35clofun1199, 1, 0));
Obj _35reg982 = primSet(intern("cora/init.rewrite-begin"), makeNative(_35clofun1201, 1, 0));
pushCont(co, _35clofun1207, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("begin"), makeNative(_35clofun1206, 1, 0));
}

void _35clofun1207(struct Cora* co) {
Obj _35val984 = co->args[1];
Obj _35reg1004 = primSet(intern("cora/init.rewrite-backquote"), makeNative(_35clofun1208, 1, 0));
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("backquote"), makeNative(_35clofun1214, 1, 0));
}

void _35clofun1214(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun1215, 0);
coraCall(co, 2, globalRef(intern("cadr")), exp);
}

void _35clofun1215(struct Cora* co) {
Obj _35val1005 = co->args[1];
coraCall(co, 2, globalRef(intern("cora/init.rewrite-backquote")), _35val1005);
}

void _35clofun1208(struct Cora* co) {
Obj _35p33 = co->args[1];
Obj _35cc34 = makeNative(_35clofun1209, 0, 1, _35p33);
Obj x = _35p33;
Obj _35reg1001 = primIsSymbol(x);
if (True == _35reg1001) {
Obj _35reg1002 = primCons(x, Nil);
Obj _35reg1003 = primCons(intern("quote"), _35reg1002);
coraReturn(co, _35reg1003);
return;
} else {
coraCall(co, 1, _35cc34);
}
}

void _35clofun1209(struct Cora* co) {
Obj _35cc35 = makeNative(_35clofun1210, 0, 1, closureRef(co, 0));
Obj _35reg991 = primIsCons(closureRef(co, 0));
if (True == _35reg991) {
Obj _35reg992 = primCar(closureRef(co, 0));
Obj _35reg993 = primEQ(intern("unquote"), _35reg992);
if (True == _35reg993) {
Obj _35reg994 = primCdr(closureRef(co, 0));
Obj _35reg995 = primIsCons(_35reg994);
if (True == _35reg995) {
Obj _35reg996 = primCdr(closureRef(co, 0));
Obj _35reg997 = primCar(_35reg996);
Obj x = _35reg997;
Obj _35reg998 = primCdr(closureRef(co, 0));
Obj _35reg999 = primCdr(_35reg998);
Obj _35reg1000 = primEQ(Nil, _35reg999);
if (True == _35reg1000) {
coraReturn(co, x);
return;
} else {
coraCall(co, 1, _35cc35);
}
} else {
coraCall(co, 1, _35cc35);
}
} else {
coraCall(co, 1, _35cc35);
}
} else {
coraCall(co, 1, _35cc35);
}
}

void _35clofun1210(struct Cora* co) {
Obj _35cc36 = makeNative(_35clofun1211, 0, 1, closureRef(co, 0));
Obj _35reg985 = primIsCons(closureRef(co, 0));
if (True == _35reg985) {
Obj _35reg986 = primCar(closureRef(co, 0));
Obj x = _35reg986;
Obj _35reg987 = primCdr(closureRef(co, 0));
Obj more = _35reg987;
Obj _35reg988 = primCons(x, more);
pushCont(co, _35clofun1213, 0);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/init.rewrite-backquote")), _35reg988);
} else {
coraCall(co, 1, _35cc36);
}
}

void _35clofun1213(struct Cora* co) {
Obj _35val989 = co->args[1];
Obj _35reg990 = primCons(intern("list"), _35val989);
coraReturn(co, _35reg990);
return;
}

void _35clofun1211(struct Cora* co) {
Obj _35cc37 = makeNative(_35clofun1212, 0, 0);
Obj x = closureRef(co, 0);
coraReturn(co, x);
return;
}

void _35clofun1212(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun1206(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg983 = primCdr(exp);
coraCall(co, 2, globalRef(intern("cora/init.rewrite-begin")), _35reg983);
}

void _35clofun1201(struct Cora* co) {
Obj _35p29 = co->args[1];
Obj _35cc30 = makeNative(_35clofun1202, 0, 1, _35p29);
Obj _35reg978 = primIsCons(_35p29);
if (True == _35reg978) {
Obj _35reg979 = primCar(_35p29);
Obj x = _35reg979;
Obj _35reg980 = primCdr(_35p29);
Obj _35reg981 = primEQ(Nil, _35reg980);
if (True == _35reg981) {
coraReturn(co, x);
return;
} else {
coraCall(co, 1, _35cc30);
}
} else {
coraCall(co, 1, _35cc30);
}
}

void _35clofun1202(struct Cora* co) {
Obj _35cc31 = makeNative(_35clofun1203, 0, 1, closureRef(co, 0));
Obj _35reg966 = primIsCons(closureRef(co, 0));
if (True == _35reg966) {
Obj _35reg967 = primCar(closureRef(co, 0));
Obj x = _35reg967;
Obj _35reg968 = primCdr(closureRef(co, 0));
Obj _35reg969 = primIsCons(_35reg968);
if (True == _35reg969) {
Obj _35reg970 = primCdr(closureRef(co, 0));
Obj _35reg971 = primCar(_35reg970);
Obj y = _35reg971;
Obj _35reg972 = primCdr(closureRef(co, 0));
Obj _35reg973 = primCdr(_35reg972);
Obj _35reg974 = primEQ(Nil, _35reg973);
if (True == _35reg974) {
Obj _35reg975 = primCons(y, Nil);
Obj _35reg976 = primCons(x, _35reg975);
Obj _35reg977 = primCons(intern("do"), _35reg976);
coraReturn(co, _35reg977);
return;
} else {
coraCall(co, 1, _35cc31);
}
} else {
coraCall(co, 1, _35cc31);
}
} else {
coraCall(co, 1, _35cc31);
}
}

void _35clofun1203(struct Cora* co) {
Obj _35cc32 = makeNative(_35clofun1204, 0, 0);
Obj _35reg959 = primIsCons(closureRef(co, 0));
if (True == _35reg959) {
Obj _35reg960 = primCar(closureRef(co, 0));
Obj x = _35reg960;
Obj _35reg961 = primCdr(closureRef(co, 0));
Obj y = _35reg961;
pushCont(co, _35clofun1205, 1, x);
coraCall(co, 2, globalRef(intern("cora/init.rewrite-begin")), y);
} else {
coraCall(co, 1, _35cc32);
}
}

void _35clofun1205(struct Cora* co) {
Obj _35val962 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg963 = primCons(_35val962, Nil);
Obj _35reg964 = primCons(x, _35reg963);
Obj _35reg965 = primCons(intern("do"), _35reg964);
coraReturn(co, _35reg965);
return;
}

void _35clofun1204(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun1199(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun1200, 0);
coraCall(co, 2, globalRef(intern("cora/init.macroexpand-boot")), exp);
}

void _35clofun1200(struct Cora* co) {
Obj _35val957 = co->args[1];
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), _35val957);
}

void _35clofun1176(struct Cora* co) {
Obj _35p17 = co->args[1];
Obj _35cc18 = makeNative(_35clofun1177, 0, 1, _35p17);
Obj _35reg944 = primIsCons(_35p17);
if (True == _35reg944) {
Obj _35reg945 = primCar(_35p17);
Obj _35reg946 = primEQ(intern("quote"), _35reg945);
if (True == _35reg946) {
Obj _35reg947 = primCdr(_35p17);
Obj _35reg948 = primIsCons(_35reg947);
if (True == _35reg948) {
Obj _35reg949 = primCdr(_35p17);
Obj _35reg950 = primCar(_35reg949);
Obj x = _35reg950;
Obj _35reg951 = primCdr(_35p17);
Obj _35reg952 = primCdr(_35reg951);
Obj _35reg953 = primEQ(Nil, _35reg952);
if (True == _35reg953) {
Obj _35reg954 = primCons(x, Nil);
Obj _35reg955 = primCons(intern("quote"), _35reg954);
coraReturn(co, _35reg955);
return;
} else {
coraCall(co, 1, _35cc18);
}
} else {
coraCall(co, 1, _35cc18);
}
} else {
coraCall(co, 1, _35cc18);
}
} else {
coraCall(co, 1, _35cc18);
}
}

void _35clofun1177(struct Cora* co) {
Obj _35cc19 = makeNative(_35clofun1178, 0, 1, closureRef(co, 0));
Obj _35reg931 = primIsCons(closureRef(co, 0));
if (True == _35reg931) {
Obj _35reg932 = primCar(closureRef(co, 0));
Obj _35reg933 = primEQ(intern("cons?"), _35reg932);
if (True == _35reg933) {
Obj _35reg934 = primCdr(closureRef(co, 0));
Obj _35reg935 = primIsCons(_35reg934);
if (True == _35reg935) {
Obj _35reg936 = primCdr(closureRef(co, 0));
Obj _35reg937 = primCar(_35reg936);
Obj x = _35reg937;
Obj _35reg938 = primCdr(closureRef(co, 0));
Obj _35reg939 = primCdr(_35reg938);
Obj _35reg940 = primEQ(Nil, _35reg939);
if (True == _35reg940) {
pushCont(co, _35clofun1198, 0);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), x);
} else {
coraCall(co, 1, _35cc19);
}
} else {
coraCall(co, 1, _35cc19);
}
} else {
coraCall(co, 1, _35cc19);
}
} else {
coraCall(co, 1, _35cc19);
}
}

void _35clofun1198(struct Cora* co) {
Obj _35val941 = co->args[1];
Obj x1 = _35val941;
Obj _35reg942 = primCons(x1, Nil);
Obj _35reg943 = primCons(intern("cons?"), _35reg942);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean0")), _35reg943);
}

void _35clofun1178(struct Cora* co) {
Obj _35cc20 = makeNative(_35clofun1179, 0, 1, closureRef(co, 0));
Obj _35reg918 = primIsCons(closureRef(co, 0));
if (True == _35reg918) {
Obj _35reg919 = primCar(closureRef(co, 0));
Obj _35reg920 = primEQ(intern("car"), _35reg919);
if (True == _35reg920) {
Obj _35reg921 = primCdr(closureRef(co, 0));
Obj _35reg922 = primIsCons(_35reg921);
if (True == _35reg922) {
Obj _35reg923 = primCdr(closureRef(co, 0));
Obj _35reg924 = primCar(_35reg923);
Obj x = _35reg924;
Obj _35reg925 = primCdr(closureRef(co, 0));
Obj _35reg926 = primCdr(_35reg925);
Obj _35reg927 = primEQ(Nil, _35reg926);
if (True == _35reg927) {
pushCont(co, _35clofun1197, 0);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), x);
} else {
coraCall(co, 1, _35cc20);
}
} else {
coraCall(co, 1, _35cc20);
}
} else {
coraCall(co, 1, _35cc20);
}
} else {
coraCall(co, 1, _35cc20);
}
}

void _35clofun1197(struct Cora* co) {
Obj _35val928 = co->args[1];
Obj x1 = _35val928;
Obj _35reg929 = primCons(x1, Nil);
Obj _35reg930 = primCons(intern("car"), _35reg929);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean0")), _35reg930);
}

void _35clofun1179(struct Cora* co) {
Obj _35cc21 = makeNative(_35clofun1180, 0, 1, closureRef(co, 0));
Obj _35reg905 = primIsCons(closureRef(co, 0));
if (True == _35reg905) {
Obj _35reg906 = primCar(closureRef(co, 0));
Obj _35reg907 = primEQ(intern("cdr"), _35reg906);
if (True == _35reg907) {
Obj _35reg908 = primCdr(closureRef(co, 0));
Obj _35reg909 = primIsCons(_35reg908);
if (True == _35reg909) {
Obj _35reg910 = primCdr(closureRef(co, 0));
Obj _35reg911 = primCar(_35reg910);
Obj x = _35reg911;
Obj _35reg912 = primCdr(closureRef(co, 0));
Obj _35reg913 = primCdr(_35reg912);
Obj _35reg914 = primEQ(Nil, _35reg913);
if (True == _35reg914) {
pushCont(co, _35clofun1196, 0);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), x);
} else {
coraCall(co, 1, _35cc21);
}
} else {
coraCall(co, 1, _35cc21);
}
} else {
coraCall(co, 1, _35cc21);
}
} else {
coraCall(co, 1, _35cc21);
}
}

void _35clofun1196(struct Cora* co) {
Obj _35val915 = co->args[1];
Obj x1 = _35val915;
Obj _35reg916 = primCons(x1, Nil);
Obj _35reg917 = primCons(intern("cdr"), _35reg916);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean0")), _35reg917);
}

void _35clofun1180(struct Cora* co) {
Obj _35cc22 = makeNative(_35clofun1181, 0, 1, closureRef(co, 0));
Obj _35reg883 = primIsCons(closureRef(co, 0));
if (True == _35reg883) {
Obj _35reg884 = primCar(closureRef(co, 0));
Obj _35reg885 = primEQ(intern("and"), _35reg884);
if (True == _35reg885) {
Obj _35reg886 = primCdr(closureRef(co, 0));
Obj _35reg887 = primIsCons(_35reg886);
if (True == _35reg887) {
Obj _35reg888 = primCdr(closureRef(co, 0));
Obj _35reg889 = primCar(_35reg888);
Obj x = _35reg889;
Obj _35reg890 = primCdr(closureRef(co, 0));
Obj _35reg891 = primCdr(_35reg890);
Obj _35reg892 = primIsCons(_35reg891);
if (True == _35reg892) {
Obj _35reg893 = primCdr(closureRef(co, 0));
Obj _35reg894 = primCdr(_35reg893);
Obj _35reg895 = primCar(_35reg894);
Obj y = _35reg895;
Obj _35reg896 = primCdr(closureRef(co, 0));
Obj _35reg897 = primCdr(_35reg896);
Obj _35reg898 = primCdr(_35reg897);
Obj _35reg899 = primEQ(Nil, _35reg898);
if (True == _35reg899) {
pushCont(co, _35clofun1194, 1, y);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), x);
} else {
coraCall(co, 1, _35cc22);
}
} else {
coraCall(co, 1, _35cc22);
}
} else {
coraCall(co, 1, _35cc22);
}
} else {
coraCall(co, 1, _35cc22);
}
} else {
coraCall(co, 1, _35cc22);
}
}

void _35clofun1194(struct Cora* co) {
Obj _35val900 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj x1 = _35val900;
pushCont(co, _35clofun1195, 1, x1);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), y);
}

void _35clofun1195(struct Cora* co) {
Obj _35val901 = co->args[1];
Obj x1 = co->stack[co->base + 0];
Obj y1 = _35val901;
Obj _35reg902 = primCons(y1, Nil);
Obj _35reg903 = primCons(x1, _35reg902);
Obj _35reg904 = primCons(intern("and"), _35reg903);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean0")), _35reg904);
}

void _35clofun1181(struct Cora* co) {
Obj _35cc23 = makeNative(_35clofun1182, 0, 1, closureRef(co, 0));
Obj _35reg870 = primIsCons(closureRef(co, 0));
if (True == _35reg870) {
Obj _35reg871 = primCar(closureRef(co, 0));
Obj _35reg872 = primEQ(intern("null?"), _35reg871);
if (True == _35reg872) {
Obj _35reg873 = primCdr(closureRef(co, 0));
Obj _35reg874 = primIsCons(_35reg873);
if (True == _35reg874) {
Obj _35reg875 = primCdr(closureRef(co, 0));
Obj _35reg876 = primCar(_35reg875);
Obj x = _35reg876;
Obj _35reg877 = primCdr(closureRef(co, 0));
Obj _35reg878 = primCdr(_35reg877);
Obj _35reg879 = primEQ(Nil, _35reg878);
if (True == _35reg879) {
pushCont(co, _35clofun1193, 0);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), x);
} else {
coraCall(co, 1, _35cc23);
}
} else {
coraCall(co, 1, _35cc23);
}
} else {
coraCall(co, 1, _35cc23);
}
} else {
coraCall(co, 1, _35cc23);
}
}

void _35clofun1193(struct Cora* co) {
Obj _35val880 = co->args[1];
Obj x1 = _35val880;
Obj _35reg881 = primCons(x1, Nil);
Obj _35reg882 = primCons(intern("null?"), _35reg881);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean0")), _35reg882);
}

void _35clofun1182(struct Cora* co) {
Obj _35cc24 = makeNative(_35clofun1183, 0, 1, closureRef(co, 0));
Obj _35reg857 = primIsCons(closureRef(co, 0));
if (True == _35reg857) {
Obj _35reg858 = primCar(closureRef(co, 0));
Obj _35reg859 = primEQ(intern("not"), _35reg858);
if (True == _35reg859) {
Obj _35reg860 = primCdr(closureRef(co, 0));
Obj _35reg861 = primIsCons(_35reg860);
if (True == _35reg861) {
Obj _35reg862 = primCdr(closureRef(co, 0));
Obj _35reg863 = primCar(_35reg862);
Obj x = _35reg863;
Obj _35reg864 = primCdr(closureRef(co, 0));
Obj _35reg865 = primCdr(_35reg864);
Obj _35reg866 = primEQ(Nil, _35reg865);
if (True == _35reg866) {
pushCont(co, _35clofun1192, 0);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), x);
} else {
coraCall(co, 1, _35cc24);
}
} else {
coraCall(co, 1, _35cc24);
}
} else {
coraCall(co, 1, _35cc24);
}
} else {
coraCall(co, 1, _35cc24);
}
}

void _35clofun1192(struct Cora* co) {
Obj _35val867 = co->args[1];
Obj x1 = _35val867;
Obj _35reg868 = primCons(x1, Nil);
Obj _35reg869 = primCons(intern("not"), _35reg868);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean0")), _35reg869);
}

void _35clofun1183(struct Cora* co) {
Obj _35cc25 = makeNative(_35clofun1184, 0, 1, closureRef(co, 0));
Obj _35reg824 = primIsCons(closureRef(co, 0));
if (True == _35reg824) {
Obj _35reg825 = primCar(closureRef(co, 0));
Obj _35reg826 = primEQ(intern("if"), _35reg825);
if (True == _35reg826) {
Obj _35reg827 = primCdr(closureRef(co, 0));
Obj _35reg828 = primIsCons(_35reg827);
if (True == _35reg828) {
Obj _35reg829 = primCdr(closureRef(co, 0));
Obj _35reg830 = primCar(_35reg829);
Obj x = _35reg830;
Obj _35reg831 = primCdr(closureRef(co, 0));
Obj _35reg832 = primCdr(_35reg831);
Obj _35reg833 = primIsCons(_35reg832);
if (True == _35reg833) {
Obj _35reg834 = primCdr(closureRef(co, 0));
Obj _35reg835 = primCdr(_35reg834);
Obj _35reg836 = primCar(_35reg835);
Obj y = _35reg836;
Obj _35reg837 = primCdr(closureRef(co, 0));
Obj _35reg838 = primCdr(_35reg837);
Obj _35reg839 = primCdr(_35reg838);
Obj _35reg840 = primIsCons(_35reg839);
if (True == _35reg840) {
Obj _35reg841 = primCdr(closureRef(co, 0));
Obj _35reg842 = primCdr(_35reg841);
Obj _35reg843 = primCdr(_35reg842);
Obj _35reg844 = primCar(_35reg843);
Obj z = _35reg844;
Obj _35reg845 = primCdr(closureRef(co, 0));
Obj _35reg846 = primCdr(_35reg845);
Obj _35reg847 = primCdr(_35reg846);
Obj _35reg848 = primCdr(_35reg847);
Obj _35reg849 = primEQ(Nil, _35reg848);
if (True == _35reg849) {
pushCont(co, _35clofun1189, 2, y, z);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), x);
} else {
coraCall(co, 1, _35cc25);
}
} else {
coraCall(co, 1, _35cc25);
}
} else {
coraCall(co, 1, _35cc25);
}
} else {
coraCall(co, 1, _35cc25);
}
} else {
coraCall(co, 1, _35cc25);
}
} else {
coraCall(co, 1, _35cc25);
}
}

void _35clofun1189(struct Cora* co) {
Obj _35val850 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj z = co->stack[co->base + 1];
Obj x1 = _35val850;
pushCont(co, _35clofun1190, 2, z, x1);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), y);
}

void _35clofun1190(struct Cora* co) {
Obj _35val851 = co->args[1];
Obj z = co->stack[co->base + 0];
Obj x1 = co->stack[co->base + 1];
Obj y1 = _35val851;
pushCont(co, _35clofun1191, 2, y1, x1);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), z);
}

void _35clofun1191(struct Cora* co) {
Obj _35val852 = co->args[1];
Obj y1 = co->stack[co->base + 0];
Obj x1 = co->stack[co->base + 1];
Obj z1 = _35val852;
Obj _35reg853 = primCons(z1, Nil);
Obj _35reg854 = primCons(y1, _35reg853);
Obj _35reg855 = primCons(x1, _35reg854);
Obj _35reg856 = primCons(intern("if"), _35reg855);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean0")), _35reg856);
}

void _35clofun1184(struct Cora* co) {
Obj _35cc26 = makeNative(_35clofun1185, 0, 1, closureRef(co, 0));
Obj _35reg803 = primIsCons(closureRef(co, 0));
if (True == _35reg803) {
Obj _35reg804 = primCar(closureRef(co, 0));
Obj _35reg805 = primEQ(intern("lambda"), _35reg804);
if (True == _35reg805) {
Obj _35reg806 = primCdr(closureRef(co, 0));
Obj _35reg807 = primIsCons(_35reg806);
if (True == _35reg807) {
Obj _35reg808 = primCdr(closureRef(co, 0));
Obj _35reg809 = primCar(_35reg808);
Obj args = _35reg809;
Obj _35reg810 = primCdr(closureRef(co, 0));
Obj _35reg811 = primCdr(_35reg810);
Obj _35reg812 = primIsCons(_35reg811);
if (True == _35reg812) {
Obj _35reg813 = primCdr(closureRef(co, 0));
Obj _35reg814 = primCdr(_35reg813);
Obj _35reg815 = primCar(_35reg814);
Obj body = _35reg815;
Obj _35reg816 = primCdr(closureRef(co, 0));
Obj _35reg817 = primCdr(_35reg816);
Obj _35reg818 = primCdr(_35reg817);
Obj _35reg819 = primEQ(Nil, _35reg818);
if (True == _35reg819) {
pushCont(co, _35clofun1188, 1, args);
coraCall(co, 2, globalRef(intern("cora/init.propagate-boolean")), body);
} else {
coraCall(co, 1, _35cc26);
}
} else {
coraCall(co, 1, _35cc26);
}
} else {
coraCall(co, 1, _35cc26);
}
} else {
coraCall(co, 1, _35cc26);
}
} else {
coraCall(co, 1, _35cc26);
}
}

void _35clofun1188(struct Cora* co) {
Obj _35val820 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg821 = primCons(_35val820, Nil);
Obj _35reg822 = primCons(args, _35reg821);
Obj _35reg823 = primCons(intern("lambda"), _35reg822);
coraReturn(co, _35reg823);
return;
}

void _35clofun1185(struct Cora* co) {
Obj _35cc27 = makeNative(_35clofun1186, 0, 1, closureRef(co, 0));
Obj _35reg799 = primIsCons(closureRef(co, 0));
if (True == _35reg799) {
Obj _35reg800 = primCar(closureRef(co, 0));
Obj f = _35reg800;
Obj _35reg801 = primCdr(closureRef(co, 0));
Obj args = _35reg801;
Obj _35reg802 = primCons(f, args);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/init.propagate-boolean")), _35reg802);
} else {
coraCall(co, 1, _35cc27);
}
}

void _35clofun1186(struct Cora* co) {
Obj _35cc28 = makeNative(_35clofun1187, 0, 0);
Obj x = closureRef(co, 0);
coraReturn(co, x);
return;
}

void _35clofun1187(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun1164(struct Cora* co) {
Obj _35p5 = co->args[1];
Obj _35cc6 = makeNative(_35clofun1165, 0, 1, _35p5);
Obj _35reg759 = primIsCons(_35p5);
if (True == _35reg759) {
Obj _35reg760 = primCar(_35p5);
Obj _35reg761 = primEQ(intern("car"), _35reg760);
if (True == _35reg761) {
Obj _35reg762 = primCdr(_35p5);
Obj _35reg763 = primIsCons(_35reg762);
if (True == _35reg763) {
Obj _35reg764 = primCdr(_35p5);
Obj _35reg765 = primCar(_35reg764);
Obj _35reg766 = primIsCons(_35reg765);
if (True == _35reg766) {
Obj _35reg767 = primCdr(_35p5);
Obj _35reg768 = primCar(_35reg767);
Obj _35reg769 = primCar(_35reg768);
Obj _35reg770 = primEQ(intern("cons"), _35reg769);
if (True == _35reg770) {
Obj _35reg771 = primCdr(_35p5);
Obj _35reg772 = primCar(_35reg771);
Obj _35reg773 = primCdr(_35reg772);
Obj _35reg774 = primIsCons(_35reg773);
if (True == _35reg774) {
Obj _35reg775 = primCdr(_35p5);
Obj _35reg776 = primCar(_35reg775);
Obj _35reg777 = primCdr(_35reg776);
Obj _35reg778 = primCar(_35reg777);
Obj x = _35reg778;
Obj _35reg779 = primCdr(_35p5);
Obj _35reg780 = primCar(_35reg779);
Obj _35reg781 = primCdr(_35reg780);
Obj _35reg782 = primCdr(_35reg781);
Obj _35reg783 = primIsCons(_35reg782);
if (True == _35reg783) {
Obj _35reg784 = primCdr(_35p5);
Obj _35reg785 = primCar(_35reg784);
Obj _35reg786 = primCdr(_35reg785);
Obj _35reg787 = primCdr(_35reg786);
Obj _35reg788 = primCar(_35reg787);
Obj __ = _35reg788;
Obj _35reg789 = primCdr(_35p5);
Obj _35reg790 = primCar(_35reg789);
Obj _35reg791 = primCdr(_35reg790);
Obj _35reg792 = primCdr(_35reg791);
Obj _35reg793 = primCdr(_35reg792);
Obj _35reg794 = primEQ(Nil, _35reg793);
if (True == _35reg794) {
Obj _35reg795 = primCdr(_35p5);
Obj _35reg796 = primCdr(_35reg795);
Obj _35reg797 = primEQ(Nil, _35reg796);
if (True == _35reg797) {
coraReturn(co, x);
return;
} else {
coraCall(co, 1, _35cc6);
}
} else {
coraCall(co, 1, _35cc6);
}
} else {
coraCall(co, 1, _35cc6);
}
} else {
coraCall(co, 1, _35cc6);
}
} else {
coraCall(co, 1, _35cc6);
}
} else {
coraCall(co, 1, _35cc6);
}
} else {
coraCall(co, 1, _35cc6);
}
} else {
coraCall(co, 1, _35cc6);
}
} else {
coraCall(co, 1, _35cc6);
}
}

void _35clofun1165(struct Cora* co) {
Obj _35cc7 = makeNative(_35clofun1166, 0, 1, closureRef(co, 0));
Obj _35reg720 = primIsCons(closureRef(co, 0));
if (True == _35reg720) {
Obj _35reg721 = primCar(closureRef(co, 0));
Obj _35reg722 = primEQ(intern("cdr"), _35reg721);
if (True == _35reg722) {
Obj _35reg723 = primCdr(closureRef(co, 0));
Obj _35reg724 = primIsCons(_35reg723);
if (True == _35reg724) {
Obj _35reg725 = primCdr(closureRef(co, 0));
Obj _35reg726 = primCar(_35reg725);
Obj _35reg727 = primIsCons(_35reg726);
if (True == _35reg727) {
Obj _35reg728 = primCdr(closureRef(co, 0));
Obj _35reg729 = primCar(_35reg728);
Obj _35reg730 = primCar(_35reg729);
Obj _35reg731 = primEQ(intern("cons"), _35reg730);
if (True == _35reg731) {
Obj _35reg732 = primCdr(closureRef(co, 0));
Obj _35reg733 = primCar(_35reg732);
Obj _35reg734 = primCdr(_35reg733);
Obj _35reg735 = primIsCons(_35reg734);
if (True == _35reg735) {
Obj _35reg736 = primCdr(closureRef(co, 0));
Obj _35reg737 = primCar(_35reg736);
Obj _35reg738 = primCdr(_35reg737);
Obj _35reg739 = primCar(_35reg738);
Obj __ = _35reg739;
Obj _35reg740 = primCdr(closureRef(co, 0));
Obj _35reg741 = primCar(_35reg740);
Obj _35reg742 = primCdr(_35reg741);
Obj _35reg743 = primCdr(_35reg742);
Obj _35reg744 = primIsCons(_35reg743);
if (True == _35reg744) {
Obj _35reg745 = primCdr(closureRef(co, 0));
Obj _35reg746 = primCar(_35reg745);
Obj _35reg747 = primCdr(_35reg746);
Obj _35reg748 = primCdr(_35reg747);
Obj _35reg749 = primCar(_35reg748);
Obj x = _35reg749;
Obj _35reg750 = primCdr(closureRef(co, 0));
Obj _35reg751 = primCar(_35reg750);
Obj _35reg752 = primCdr(_35reg751);
Obj _35reg753 = primCdr(_35reg752);
Obj _35reg754 = primCdr(_35reg753);
Obj _35reg755 = primEQ(Nil, _35reg754);
if (True == _35reg755) {
Obj _35reg756 = primCdr(closureRef(co, 0));
Obj _35reg757 = primCdr(_35reg756);
Obj _35reg758 = primEQ(Nil, _35reg757);
if (True == _35reg758) {
coraReturn(co, x);
return;
} else {
coraCall(co, 1, _35cc7);
}
} else {
coraCall(co, 1, _35cc7);
}
} else {
coraCall(co, 1, _35cc7);
}
} else {
coraCall(co, 1, _35cc7);
}
} else {
coraCall(co, 1, _35cc7);
}
} else {
coraCall(co, 1, _35cc7);
}
} else {
coraCall(co, 1, _35cc7);
}
} else {
coraCall(co, 1, _35cc7);
}
} else {
coraCall(co, 1, _35cc7);
}
}

void _35clofun1166(struct Cora* co) {
Obj _35cc8 = makeNative(_35clofun1167, 0, 1, closureRef(co, 0));
Obj _35reg681 = primIsCons(closureRef(co, 0));
if (True == _35reg681) {
Obj _35reg682 = primCar(closureRef(co, 0));
Obj _35reg683 = primEQ(intern("cons?"), _35reg682);
if (True == _35reg683) {
Obj _35reg684 = primCdr(closureRef(co, 0));
Obj _35reg685 = primIsCons(_35reg684);
if (True == _35reg685) {
Obj _35reg686 = primCdr(closureRef(co, 0));
Obj _35reg687 = primCar(_35reg686);
Obj _35reg688 = primIsCons(_35reg687);
if (True == _35reg688) {
Obj _35reg689 = primCdr(closureRef(co, 0));
Obj _35reg690 = primCar(_35reg689);
Obj _35reg691 = primCar(_35reg690);
Obj _35reg692 = primEQ(intern("cons"), _35reg691);
if (True == _35reg692) {
Obj _35reg693 = primCdr(closureRef(co, 0));
Obj _35reg694 = primCar(_35reg693);
Obj _35reg695 = primCdr(_35reg694);
Obj _35reg696 = primIsCons(_35reg695);
if (True == _35reg696) {
Obj _35reg697 = primCdr(closureRef(co, 0));
Obj _35reg698 = primCar(_35reg697);
Obj _35reg699 = primCdr(_35reg698);
Obj _35reg700 = primCar(_35reg699);
Obj __ = _35reg700;
Obj _35reg701 = primCdr(closureRef(co, 0));
Obj _35reg702 = primCar(_35reg701);
Obj _35reg703 = primCdr(_35reg702);
Obj _35reg704 = primCdr(_35reg703);
Obj _35reg705 = primIsCons(_35reg704);
if (True == _35reg705) {
Obj _35reg706 = primCdr(closureRef(co, 0));
Obj _35reg707 = primCar(_35reg706);
Obj _35reg708 = primCdr(_35reg707);
Obj _35reg709 = primCdr(_35reg708);
Obj _35reg710 = primCar(_35reg709);
__ = _35reg710;
Obj _35reg711 = primCdr(closureRef(co, 0));
Obj _35reg712 = primCar(_35reg711);
Obj _35reg713 = primCdr(_35reg712);
Obj _35reg714 = primCdr(_35reg713);
Obj _35reg715 = primCdr(_35reg714);
Obj _35reg716 = primEQ(Nil, _35reg715);
if (True == _35reg716) {
Obj _35reg717 = primCdr(closureRef(co, 0));
Obj _35reg718 = primCdr(_35reg717);
Obj _35reg719 = primEQ(Nil, _35reg718);
if (True == _35reg719) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc8);
}
} else {
coraCall(co, 1, _35cc8);
}
} else {
coraCall(co, 1, _35cc8);
}
} else {
coraCall(co, 1, _35cc8);
}
} else {
coraCall(co, 1, _35cc8);
}
} else {
coraCall(co, 1, _35cc8);
}
} else {
coraCall(co, 1, _35cc8);
}
} else {
coraCall(co, 1, _35cc8);
}
} else {
coraCall(co, 1, _35cc8);
}
}

void _35clofun1167(struct Cora* co) {
Obj _35cc9 = makeNative(_35clofun1168, 0, 1, closureRef(co, 0));
Obj _35reg662 = primIsCons(closureRef(co, 0));
if (True == _35reg662) {
Obj _35reg663 = primCar(closureRef(co, 0));
Obj _35reg664 = primEQ(intern("and"), _35reg663);
if (True == _35reg664) {
Obj _35reg665 = primCdr(closureRef(co, 0));
Obj _35reg666 = primIsCons(_35reg665);
if (True == _35reg666) {
Obj _35reg667 = primCdr(closureRef(co, 0));
Obj _35reg668 = primCar(_35reg667);
Obj _35reg669 = primEQ(True, _35reg668);
if (True == _35reg669) {
Obj _35reg670 = primCdr(closureRef(co, 0));
Obj _35reg671 = primCdr(_35reg670);
Obj _35reg672 = primIsCons(_35reg671);
if (True == _35reg672) {
Obj _35reg673 = primCdr(closureRef(co, 0));
Obj _35reg674 = primCdr(_35reg673);
Obj _35reg675 = primCar(_35reg674);
Obj _35reg676 = primEQ(True, _35reg675);
if (True == _35reg676) {
Obj _35reg677 = primCdr(closureRef(co, 0));
Obj _35reg678 = primCdr(_35reg677);
Obj _35reg679 = primCdr(_35reg678);
Obj _35reg680 = primEQ(Nil, _35reg679);
if (True == _35reg680) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc9);
}
} else {
coraCall(co, 1, _35cc9);
}
} else {
coraCall(co, 1, _35cc9);
}
} else {
coraCall(co, 1, _35cc9);
}
} else {
coraCall(co, 1, _35cc9);
}
} else {
coraCall(co, 1, _35cc9);
}
} else {
coraCall(co, 1, _35cc9);
}
}

void _35clofun1168(struct Cora* co) {
Obj _35cc10 = makeNative(_35clofun1169, 0, 1, closureRef(co, 0));
Obj _35reg651 = primIsCons(closureRef(co, 0));
if (True == _35reg651) {
Obj _35reg652 = primCar(closureRef(co, 0));
Obj _35reg653 = primEQ(intern("null?"), _35reg652);
if (True == _35reg653) {
Obj _35reg654 = primCdr(closureRef(co, 0));
Obj _35reg655 = primIsCons(_35reg654);
if (True == _35reg655) {
Obj _35reg656 = primCdr(closureRef(co, 0));
Obj _35reg657 = primCar(_35reg656);
Obj _35reg658 = primEQ(Nil, _35reg657);
if (True == _35reg658) {
Obj _35reg659 = primCdr(closureRef(co, 0));
Obj _35reg660 = primCdr(_35reg659);
Obj _35reg661 = primEQ(Nil, _35reg660);
if (True == _35reg661) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc10);
}
} else {
coraCall(co, 1, _35cc10);
}
} else {
coraCall(co, 1, _35cc10);
}
} else {
coraCall(co, 1, _35cc10);
}
} else {
coraCall(co, 1, _35cc10);
}
}

void _35clofun1169(struct Cora* co) {
Obj _35cc11 = makeNative(_35clofun1170, 0, 1, closureRef(co, 0));
Obj _35reg612 = primIsCons(closureRef(co, 0));
if (True == _35reg612) {
Obj _35reg613 = primCar(closureRef(co, 0));
Obj _35reg614 = primEQ(intern("null?"), _35reg613);
if (True == _35reg614) {
Obj _35reg615 = primCdr(closureRef(co, 0));
Obj _35reg616 = primIsCons(_35reg615);
if (True == _35reg616) {
Obj _35reg617 = primCdr(closureRef(co, 0));
Obj _35reg618 = primCar(_35reg617);
Obj _35reg619 = primIsCons(_35reg618);
if (True == _35reg619) {
Obj _35reg620 = primCdr(closureRef(co, 0));
Obj _35reg621 = primCar(_35reg620);
Obj _35reg622 = primCar(_35reg621);
Obj _35reg623 = primEQ(intern("cons"), _35reg622);
if (True == _35reg623) {
Obj _35reg624 = primCdr(closureRef(co, 0));
Obj _35reg625 = primCar(_35reg624);
Obj _35reg626 = primCdr(_35reg625);
Obj _35reg627 = primIsCons(_35reg626);
if (True == _35reg627) {
Obj _35reg628 = primCdr(closureRef(co, 0));
Obj _35reg629 = primCar(_35reg628);
Obj _35reg630 = primCdr(_35reg629);
Obj _35reg631 = primCar(_35reg630);
Obj __ = _35reg631;
Obj _35reg632 = primCdr(closureRef(co, 0));
Obj _35reg633 = primCar(_35reg632);
Obj _35reg634 = primCdr(_35reg633);
Obj _35reg635 = primCdr(_35reg634);
Obj _35reg636 = primIsCons(_35reg635);
if (True == _35reg636) {
Obj _35reg637 = primCdr(closureRef(co, 0));
Obj _35reg638 = primCar(_35reg637);
Obj _35reg639 = primCdr(_35reg638);
Obj _35reg640 = primCdr(_35reg639);
Obj _35reg641 = primCar(_35reg640);
__ = _35reg641;
Obj _35reg642 = primCdr(closureRef(co, 0));
Obj _35reg643 = primCar(_35reg642);
Obj _35reg644 = primCdr(_35reg643);
Obj _35reg645 = primCdr(_35reg644);
Obj _35reg646 = primCdr(_35reg645);
Obj _35reg647 = primEQ(Nil, _35reg646);
if (True == _35reg647) {
Obj _35reg648 = primCdr(closureRef(co, 0));
Obj _35reg649 = primCdr(_35reg648);
Obj _35reg650 = primEQ(Nil, _35reg649);
if (True == _35reg650) {
coraReturn(co, False);
return;
} else {
coraCall(co, 1, _35cc11);
}
} else {
coraCall(co, 1, _35cc11);
}
} else {
coraCall(co, 1, _35cc11);
}
} else {
coraCall(co, 1, _35cc11);
}
} else {
coraCall(co, 1, _35cc11);
}
} else {
coraCall(co, 1, _35cc11);
}
} else {
coraCall(co, 1, _35cc11);
}
} else {
coraCall(co, 1, _35cc11);
}
} else {
coraCall(co, 1, _35cc11);
}
}

void _35clofun1170(struct Cora* co) {
Obj _35cc12 = makeNative(_35clofun1171, 0, 1, closureRef(co, 0));
Obj _35reg601 = primIsCons(closureRef(co, 0));
if (True == _35reg601) {
Obj _35reg602 = primCar(closureRef(co, 0));
Obj _35reg603 = primEQ(intern("not"), _35reg602);
if (True == _35reg603) {
Obj _35reg604 = primCdr(closureRef(co, 0));
Obj _35reg605 = primIsCons(_35reg604);
if (True == _35reg605) {
Obj _35reg606 = primCdr(closureRef(co, 0));
Obj _35reg607 = primCar(_35reg606);
Obj _35reg608 = primEQ(True, _35reg607);
if (True == _35reg608) {
Obj _35reg609 = primCdr(closureRef(co, 0));
Obj _35reg610 = primCdr(_35reg609);
Obj _35reg611 = primEQ(Nil, _35reg610);
if (True == _35reg611) {
coraReturn(co, False);
return;
} else {
coraCall(co, 1, _35cc12);
}
} else {
coraCall(co, 1, _35cc12);
}
} else {
coraCall(co, 1, _35cc12);
}
} else {
coraCall(co, 1, _35cc12);
}
} else {
coraCall(co, 1, _35cc12);
}
}

void _35clofun1171(struct Cora* co) {
Obj _35cc13 = makeNative(_35clofun1172, 0, 1, closureRef(co, 0));
Obj _35reg590 = primIsCons(closureRef(co, 0));
if (True == _35reg590) {
Obj _35reg591 = primCar(closureRef(co, 0));
Obj _35reg592 = primEQ(intern("not"), _35reg591);
if (True == _35reg592) {
Obj _35reg593 = primCdr(closureRef(co, 0));
Obj _35reg594 = primIsCons(_35reg593);
if (True == _35reg594) {
Obj _35reg595 = primCdr(closureRef(co, 0));
Obj _35reg596 = primCar(_35reg595);
Obj _35reg597 = primEQ(False, _35reg596);
if (True == _35reg597) {
Obj _35reg598 = primCdr(closureRef(co, 0));
Obj _35reg599 = primCdr(_35reg598);
Obj _35reg600 = primEQ(Nil, _35reg599);
if (True == _35reg600) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc13);
}
} else {
coraCall(co, 1, _35cc13);
}
} else {
coraCall(co, 1, _35cc13);
}
} else {
coraCall(co, 1, _35cc13);
}
} else {
coraCall(co, 1, _35cc13);
}
}

void _35clofun1172(struct Cora* co) {
Obj _35cc14 = makeNative(_35clofun1173, 0, 1, closureRef(co, 0));
Obj _35reg563 = primIsCons(closureRef(co, 0));
if (True == _35reg563) {
Obj _35reg564 = primCar(closureRef(co, 0));
Obj _35reg565 = primEQ(intern("if"), _35reg564);
if (True == _35reg565) {
Obj _35reg566 = primCdr(closureRef(co, 0));
Obj _35reg567 = primIsCons(_35reg566);
if (True == _35reg567) {
Obj _35reg568 = primCdr(closureRef(co, 0));
Obj _35reg569 = primCar(_35reg568);
Obj _35reg570 = primEQ(True, _35reg569);
if (True == _35reg570) {
Obj _35reg571 = primCdr(closureRef(co, 0));
Obj _35reg572 = primCdr(_35reg571);
Obj _35reg573 = primIsCons(_35reg572);
if (True == _35reg573) {
Obj _35reg574 = primCdr(closureRef(co, 0));
Obj _35reg575 = primCdr(_35reg574);
Obj _35reg576 = primCar(_35reg575);
Obj y = _35reg576;
Obj _35reg577 = primCdr(closureRef(co, 0));
Obj _35reg578 = primCdr(_35reg577);
Obj _35reg579 = primCdr(_35reg578);
Obj _35reg580 = primIsCons(_35reg579);
if (True == _35reg580) {
Obj _35reg581 = primCdr(closureRef(co, 0));
Obj _35reg582 = primCdr(_35reg581);
Obj _35reg583 = primCdr(_35reg582);
Obj _35reg584 = primCar(_35reg583);
Obj z = _35reg584;
Obj _35reg585 = primCdr(closureRef(co, 0));
Obj _35reg586 = primCdr(_35reg585);
Obj _35reg587 = primCdr(_35reg586);
Obj _35reg588 = primCdr(_35reg587);
Obj _35reg589 = primEQ(Nil, _35reg588);
if (True == _35reg589) {
coraReturn(co, y);
return;
} else {
coraCall(co, 1, _35cc14);
}
} else {
coraCall(co, 1, _35cc14);
}
} else {
coraCall(co, 1, _35cc14);
}
} else {
coraCall(co, 1, _35cc14);
}
} else {
coraCall(co, 1, _35cc14);
}
} else {
coraCall(co, 1, _35cc14);
}
} else {
coraCall(co, 1, _35cc14);
}
}

void _35clofun1173(struct Cora* co) {
Obj _35cc15 = makeNative(_35clofun1174, 0, 1, closureRef(co, 0));
Obj _35reg536 = primIsCons(closureRef(co, 0));
if (True == _35reg536) {
Obj _35reg537 = primCar(closureRef(co, 0));
Obj _35reg538 = primEQ(intern("if"), _35reg537);
if (True == _35reg538) {
Obj _35reg539 = primCdr(closureRef(co, 0));
Obj _35reg540 = primIsCons(_35reg539);
if (True == _35reg540) {
Obj _35reg541 = primCdr(closureRef(co, 0));
Obj _35reg542 = primCar(_35reg541);
Obj _35reg543 = primEQ(False, _35reg542);
if (True == _35reg543) {
Obj _35reg544 = primCdr(closureRef(co, 0));
Obj _35reg545 = primCdr(_35reg544);
Obj _35reg546 = primIsCons(_35reg545);
if (True == _35reg546) {
Obj _35reg547 = primCdr(closureRef(co, 0));
Obj _35reg548 = primCdr(_35reg547);
Obj _35reg549 = primCar(_35reg548);
Obj y = _35reg549;
Obj _35reg550 = primCdr(closureRef(co, 0));
Obj _35reg551 = primCdr(_35reg550);
Obj _35reg552 = primCdr(_35reg551);
Obj _35reg553 = primIsCons(_35reg552);
if (True == _35reg553) {
Obj _35reg554 = primCdr(closureRef(co, 0));
Obj _35reg555 = primCdr(_35reg554);
Obj _35reg556 = primCdr(_35reg555);
Obj _35reg557 = primCar(_35reg556);
Obj z = _35reg557;
Obj _35reg558 = primCdr(closureRef(co, 0));
Obj _35reg559 = primCdr(_35reg558);
Obj _35reg560 = primCdr(_35reg559);
Obj _35reg561 = primCdr(_35reg560);
Obj _35reg562 = primEQ(Nil, _35reg561);
if (True == _35reg562) {
coraReturn(co, z);
return;
} else {
coraCall(co, 1, _35cc15);
}
} else {
coraCall(co, 1, _35cc15);
}
} else {
coraCall(co, 1, _35cc15);
}
} else {
coraCall(co, 1, _35cc15);
}
} else {
coraCall(co, 1, _35cc15);
}
} else {
coraCall(co, 1, _35cc15);
}
} else {
coraCall(co, 1, _35cc15);
}
}

void _35clofun1174(struct Cora* co) {
Obj _35cc16 = makeNative(_35clofun1175, 0, 0);
Obj x = closureRef(co, 0);
coraReturn(co, x);
return;
}

void _35clofun1175(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun1157(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun1158, 1, exp);
coraCall(co, 2, globalRef(intern("cddr")), exp);
}

void _35clofun1158(struct Cora* co) {
Obj _35val523 = co->args[1];
Obj exp = co->stack[co->base + 0];
pushCont(co, _35clofun1159, 1, exp);
coraCall(co, 2, globalRef(intern("cora/init.extract-rules")), _35val523);
}

void _35clofun1159(struct Cora* co) {
Obj _35val524 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj body = _35val524;
pushCont(co, _35clofun1160, 2, exp, body);
coraCall(co, 2, globalRef(intern("cora/init.rules-arg-count")), body);
}

void _35clofun1160(struct Cora* co) {
Obj _35val525 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj nargs = _35val525;
pushCont(co, _35clofun1161, 2, exp, body);
coraCall(co, 2, globalRef(intern("cora/init.gen-parameters")), nargs);
}

void _35clofun1161(struct Cora* co) {
Obj _35val526 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj args = _35val526;
pushCont(co, _35clofun1162, 2, body, args);
coraCall(co, 2, globalRef(intern("cadr")), exp);
}

void _35clofun1162(struct Cora* co) {
Obj _35val527 = co->args[1];
Obj body = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj _35reg528 = primCons(intern("list"), args);
Obj _35reg529 = primCons(_35reg528, body);
Obj _35reg530 = primCons(intern("match"), _35reg529);
Obj _35reg531 = primCons(_35reg530, Nil);
Obj _35reg532 = primCons(args, _35reg531);
Obj _35reg533 = primCons(_35val527, _35reg532);
Obj _35reg534 = primCons(intern("defun"), _35reg533);
coraReturn(co, _35reg534);
return;
}

void _35clofun1155(struct Cora* co) {
Obj n = co->args[1];
Obj _35reg517 = primEQ(n, makeNumber(0));
if (True == _35reg517) {
coraReturn(co, Nil);
return;
} else {
Obj _35reg518 = primGenSym(intern("p"));
Obj _35reg519 = primSub(n, makeNumber(1));
pushCont(co, _35clofun1156, 1, _35reg518);
coraCall(co, 2, globalRef(intern("cora/init.gen-parameters")), _35reg519);
}
}

void _35clofun1156(struct Cora* co) {
Obj _35val520 = co->args[1];
Obj _35reg518 = co->stack[co->base + 0];
Obj _35reg521 = primCons(_35reg518, _35val520);
coraReturn(co, _35reg521);
return;
}

void _35clofun1148(struct Cora* co) {
Obj rules = co->args[1];
pushCont(co, _35clofun1149, 0);
coraCall(co, 3, globalRef(intern("cora/init.rules-patterns")), Nil, rules);
}

void _35clofun1149(struct Cora* co) {
Obj _35val506 = co->args[1];
Obj pats = _35val506;
Obj len = makeNative(_35clofun1150, 1, 0);
pushCont(co, _35clofun1151, 0);
coraCall(co, 3, globalRef(intern("map")), len, pats);
}

void _35clofun1151(struct Cora* co) {
Obj _35val508 = co->args[1];
Obj counts = _35val508;
Obj _35reg509 = primCar(counts);
Obj n = _35reg509;
Obj dif = makeNative(_35clofun1152, 1, 1, n);
Obj _35reg512 = primCdr(counts);
pushCont(co, _35clofun1153, 1, n);
coraCall(co, 3, globalRef(intern("filter")), dif, _35reg512);
}

void _35clofun1153(struct Cora* co) {
Obj _35val513 = co->args[1];
Obj n = co->stack[co->base + 0];
pushCont(co, _35clofun1154, 1, n);
coraCall(co, 2, globalRef(intern("null?")), _35val513);
}

void _35clofun1154(struct Cora* co) {
Obj _35val514 = co->args[1];
Obj n = co->stack[co->base + 0];
Obj _35reg515 = primNot(_35val514);
if (True == _35reg515) {
coraCall(co, 2, globalRef(intern("error")), makeString1("inconsistent func rule args count"));
} else {
coraReturn(co, n);
return;
}
}

void _35clofun1152(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg510 = primEQ(closureRef(co, 0), x);
Obj _35reg511 = primNot(_35reg510);
coraReturn(co, _35reg511);
return;
}

void _35clofun1150(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg507 = primCdr(x);
coraCall(co, 2, globalRef(intern("length")), _35reg507);
}

void _35clofun1146(struct Cora* co) {
Obj l1 = co->args[1];
Obj l2 = co->args[2];
Obj _35reg500 = primEQ(l1, Nil);
if (True == _35reg500) {
coraReturn(co, l2);
return;
} else {
Obj _35reg501 = primCar(l1);
Obj _35reg502 = primCdr(l1);
pushCont(co, _35clofun1147, 1, _35reg501);
coraCall(co, 3, globalRef(intern("append")), _35reg502, l2);
}
}

void _35clofun1147(struct Cora* co) {
Obj _35val503 = co->args[1];
Obj _35reg501 = co->stack[co->base + 0];
Obj _35reg504 = primCons(_35reg501, _35val503);
coraReturn(co, _35reg504);
return;
}

void _35clofun1145(struct Cora* co) {
Obj fn = co->args[1];
Obj l = co->args[2];
coraCall(co, 4, globalRef(intern("cora/init.filter-h")), Nil, fn, l);
}

void _35clofun1143(struct Cora* co) {
Obj res = co->args[1];
Obj fn = co->args[2];
Obj l = co->args[3];
Obj _35reg491 = primIsCons(l);
if (True == _35reg491) {
Obj _35reg492 = primCar(l);
pushCont(co, _35clofun1144, 3, l, res, fn);
coraCall(co, 2, fn, _35reg492);
} else {
coraCall(co, 2, globalRef(intern("reverse")), res);
}
}

void _35clofun1144(struct Cora* co) {
Obj _35val493 = co->args[1];
Obj l = co->stack[co->base + 0];
Obj res = co->stack[co->base + 1];
Obj fn = co->stack[co->base + 2];
if (True == _35val493) {
Obj _35reg494 = primCar(l);
Obj _35reg495 = primCons(_35reg494, res);
Obj _35reg496 = primCdr(l);
coraCall(co, 4, globalRef(intern("cora/init.filter-h")), _35reg495, fn, _35reg496);
} else {
Obj _35reg497 = primCdr(l);
coraCall(co, 4, globalRef(intern("cora/init.filter-h")), res, fn, _35reg497);
}
}

void _35clofun1142(struct Cora* co) {
Obj l = co->args[1];
coraCall(co, 3, globalRef(intern("cora/init.length-h")), makeNumber(0), l);
}

void _35clofun1141(struct Cora* co) {
Obj i = co->args[1];
Obj l = co->args[2];
Obj _35reg486 = primEQ(l, Nil);
if (True == _35reg486) {
coraReturn(co, i);
return;
} else {
Obj _35reg487 = primAdd(i, makeNumber(1));
Obj _35reg488 = primCdr(l);
coraCall(co, 3, globalRef(intern("cora/init.length-h")), _35reg487, _35reg488);
}
}

void _35clofun1138(struct Cora* co) {
Obj res = co->args[1];
Obj rules = co->args[2];
pushCont(co, _35clofun1139, 2, res, rules);
coraCall(co, 2, globalRef(intern("null?")), rules);
}

void _35clofun1139(struct Cora* co) {
Obj _35val481 = co->args[1];
Obj res = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
if (True == _35val481) {
coraCall(co, 2, globalRef(intern("reverse")), res);
} else {
Obj _35reg482 = primCar(rules);
Obj _35reg483 = primCons(_35reg482, res);
pushCont(co, _35clofun1140, 1, _35reg483);
coraCall(co, 2, globalRef(intern("cddr")), rules);
}
}

void _35clofun1140(struct Cora* co) {
Obj _35val484 = co->args[1];
Obj _35reg483 = co->stack[co->base + 0];
coraCall(co, 3, globalRef(intern("cora/init.rules-patterns")), _35reg483, _35val484);
}

void _35clofun1137(struct Cora* co) {
Obj input = co->args[1];
coraCall(co, 4, globalRef(intern("cora/init.extract-rules1")), input, Nil, Nil);
}

void _35clofun1130(struct Cora* co) {
Obj input = co->args[1];
Obj current = co->args[2];
Obj result = co->args[3];
Obj _35cc1 = makeNative(_35clofun1131, 0, 3, input, current, result);
Obj _35reg478 = primEQ(Nil, input);
if (True == _35reg478) {
coraCall(co, 2, globalRef(intern("reverse")), result);
} else {
coraCall(co, 1, _35cc1);
}
}

void _35clofun1131(struct Cora* co) {
Obj _35cc2 = makeNative(_35clofun1132, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj _35reg445 = primIsCons(closureRef(co, 0));
if (True == _35reg445) {
Obj _35reg446 = primCar(closureRef(co, 0));
Obj _35reg447 = primEQ(intern("=>"), _35reg446);
if (True == _35reg447) {
Obj _35reg448 = primCdr(closureRef(co, 0));
Obj _35reg449 = primIsCons(_35reg448);
if (True == _35reg449) {
Obj _35reg450 = primCdr(closureRef(co, 0));
Obj _35reg451 = primCar(_35reg450);
Obj act = _35reg451;
Obj _35reg452 = primCdr(closureRef(co, 0));
Obj _35reg453 = primCdr(_35reg452);
Obj _35reg454 = primIsCons(_35reg453);
if (True == _35reg454) {
Obj _35reg455 = primCdr(closureRef(co, 0));
Obj _35reg456 = primCdr(_35reg455);
Obj _35reg457 = primCar(_35reg456);
Obj _35reg458 = primEQ(intern("where"), _35reg457);
if (True == _35reg458) {
Obj _35reg459 = primCdr(closureRef(co, 0));
Obj _35reg460 = primCdr(_35reg459);
Obj _35reg461 = primCdr(_35reg460);
Obj _35reg462 = primIsCons(_35reg461);
if (True == _35reg462) {
Obj _35reg463 = primCdr(closureRef(co, 0));
Obj _35reg464 = primCdr(_35reg463);
Obj _35reg465 = primCdr(_35reg464);
Obj _35reg466 = primCar(_35reg465);
Obj pred = _35reg466;
Obj _35reg467 = primCdr(closureRef(co, 0));
Obj _35reg468 = primCdr(_35reg467);
Obj _35reg469 = primCdr(_35reg468);
Obj _35reg470 = primCdr(_35reg469);
Obj remain = _35reg470;
pushCont(co, _35clofun1136, 3, act, pred, remain);
coraCall(co, 2, globalRef(intern("reverse")), closureRef(co, 1));
} else {
coraCall(co, 1, _35cc2);
}
} else {
coraCall(co, 1, _35cc2);
}
} else {
coraCall(co, 1, _35cc2);
}
} else {
coraCall(co, 1, _35cc2);
}
} else {
coraCall(co, 1, _35cc2);
}
} else {
coraCall(co, 1, _35cc2);
}
}

void _35clofun1136(struct Cora* co) {
Obj _35val471 = co->args[1];
Obj act = co->stack[co->base + 0];
Obj pred = co->stack[co->base + 1];
Obj remain = co->stack[co->base + 2];
Obj _35reg472 = primCons(intern("list"), _35val471);
Obj pat = _35reg472;
Obj _35reg473 = primCons(act, Nil);
Obj _35reg474 = primCons(pred, _35reg473);
Obj _35reg475 = primCons(intern("where"), _35reg474);
Obj _35reg476 = primCons(pat, closureRef(co, 2));
Obj _35reg477 = primCons(_35reg475, _35reg476);
coraCall(co, 4, globalRef(intern("cora/init.extract-rules1")), remain, Nil, _35reg477);
}

void _35clofun1132(struct Cora* co) {
Obj _35cc3 = makeNative(_35clofun1133, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj _35reg432 = primIsCons(closureRef(co, 0));
if (True == _35reg432) {
Obj _35reg433 = primCar(closureRef(co, 0));
Obj _35reg434 = primEQ(intern("=>"), _35reg433);
if (True == _35reg434) {
Obj _35reg435 = primCdr(closureRef(co, 0));
Obj _35reg436 = primIsCons(_35reg435);
if (True == _35reg436) {
Obj _35reg437 = primCdr(closureRef(co, 0));
Obj _35reg438 = primCar(_35reg437);
Obj act = _35reg438;
Obj _35reg439 = primCdr(closureRef(co, 0));
Obj _35reg440 = primCdr(_35reg439);
Obj remain = _35reg440;
pushCont(co, _35clofun1135, 2, act, remain);
coraCall(co, 2, globalRef(intern("reverse")), closureRef(co, 1));
} else {
coraCall(co, 1, _35cc3);
}
} else {
coraCall(co, 1, _35cc3);
}
} else {
coraCall(co, 1, _35cc3);
}
}

void _35clofun1135(struct Cora* co) {
Obj _35val441 = co->args[1];
Obj act = co->stack[co->base + 0];
Obj remain = co->stack[co->base + 1];
Obj _35reg442 = primCons(intern("list"), _35val441);
Obj pat = _35reg442;
Obj _35reg443 = primCons(pat, closureRef(co, 2));
Obj _35reg444 = primCons(act, _35reg443);
coraCall(co, 4, globalRef(intern("cora/init.extract-rules1")), remain, Nil, _35reg444);
}

void _35clofun1133(struct Cora* co) {
Obj _35cc4 = makeNative(_35clofun1134, 0, 0);
Obj _35reg428 = primIsCons(closureRef(co, 0));
if (True == _35reg428) {
Obj _35reg429 = primCar(closureRef(co, 0));
Obj x = _35reg429;
Obj _35reg430 = primCdr(closureRef(co, 0));
Obj y = _35reg430;
Obj _35reg431 = primCons(x, closureRef(co, 1));
coraCall(co, 4, globalRef(intern("cora/init.extract-rules1")), y, _35reg431, closureRef(co, 2));
} else {
coraCall(co, 1, _35cc4);
}
}

void _35clofun1134(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun1128(struct Cora* co) {
Obj exp = co->args[1];
coraCall(co, 2, globalRef(intern("cora/init.rewrite-match")), exp);
}

void _35clofun1121(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun1122, 1, exp);
coraCall(co, 2, globalRef(intern("cadr")), exp);
}

void _35clofun1122(struct Cora* co) {
Obj _35val401 = co->args[1];
Obj exp = co->stack[co->base + 0];
pushCont(co, _35clofun1123, 1, exp);
coraCall(co, 2, globalRef(intern("macroexpand")), _35val401);
}

void _35clofun1123(struct Cora* co) {
Obj _35val402 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj value = _35val402;
pushCont(co, _35clofun1124, 1, value);
coraCall(co, 2, globalRef(intern("cddr")), exp);
}

void _35clofun1124(struct Cora* co) {
Obj _35val403 = co->args[1];
Obj value = co->stack[co->base + 0];
Obj rules = _35val403;
Obj _35reg404 = primIsCons(value);
if (True == _35reg404) {
Obj _35reg405 = primCar(value);
Obj _35reg406 = primEQ(intern("cons"), _35reg405);
Obj _35reg407 = primNot(_35reg406);
if (True == _35reg407) {
if (True == True) {
Obj _35reg408 = primGenSym(intern("val"));
Obj val = _35reg408;
pushCont(co, _35clofun1125, 2, value, val);
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), val, rules);
} else {
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), value, rules);
}
} else {
if (True == False) {
Obj _35reg414 = primGenSym(intern("val"));
Obj val = _35reg414;
pushCont(co, _35clofun1126, 2, value, val);
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), val, rules);
} else {
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), value, rules);
}
}
} else {
if (True == False) {
Obj _35reg420 = primGenSym(intern("val"));
Obj val = _35reg420;
pushCont(co, _35clofun1127, 2, value, val);
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), val, rules);
} else {
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), value, rules);
}
}
}

void _35clofun1127(struct Cora* co) {
Obj _35val421 = co->args[1];
Obj value = co->stack[co->base + 0];
Obj val = co->stack[co->base + 1];
Obj _35reg422 = primCons(_35val421, Nil);
Obj _35reg423 = primCons(value, _35reg422);
Obj _35reg424 = primCons(val, _35reg423);
Obj _35reg425 = primCons(intern("let"), _35reg424);
coraReturn(co, _35reg425);
return;
}

void _35clofun1126(struct Cora* co) {
Obj _35val415 = co->args[1];
Obj value = co->stack[co->base + 0];
Obj val = co->stack[co->base + 1];
Obj _35reg416 = primCons(_35val415, Nil);
Obj _35reg417 = primCons(value, _35reg416);
Obj _35reg418 = primCons(val, _35reg417);
Obj _35reg419 = primCons(intern("let"), _35reg418);
coraReturn(co, _35reg419);
return;
}

void _35clofun1125(struct Cora* co) {
Obj _35val409 = co->args[1];
Obj value = co->stack[co->base + 0];
Obj val = co->stack[co->base + 1];
Obj _35reg410 = primCons(_35val409, Nil);
Obj _35reg411 = primCons(value, _35reg410);
Obj _35reg412 = primCons(val, _35reg411);
Obj _35reg413 = primCons(intern("let"), _35reg412);
coraReturn(co, _35reg413);
return;
}

void _35clofun1105(struct Cora* co) {
Obj value = co->args[1];
Obj rules = co->args[2];
pushCont(co, _35clofun1106, 2, rules, value);
coraCall(co, 2, globalRef(intern("null?")), rules);
}

void _35clofun1106(struct Cora* co) {
Obj _35val349 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
if (True == _35val349) {
Obj _35reg350 = primCons(makeString1("no match-help found!"), Nil);
Obj _35reg351 = primCons(intern("error"), _35reg350);
coraReturn(co, _35reg351);
return;
} else {
pushCont(co, _35clofun1107, 2, rules, value);
coraCall(co, 2, globalRef(intern("pair?")), rules);
}
}

void _35clofun1107(struct Cora* co) {
Obj _35val352 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
if (True == _35val352) {
Obj _35reg353 = primCdr(rules);
pushCont(co, _35clofun1108, 2, rules, value);
coraCall(co, 2, globalRef(intern("pair?")), _35reg353);
} else {
if (True == False) {
Obj _35reg385 = primCar(rules);
Obj pat = _35reg385;
Obj _35reg386 = primGenSym(intern("cc"));
Obj cc = _35reg386;
pushCont(co, _35clofun1117, 4, pat, rules, value, cc);
coraCall(co, 3, globalRef(intern("cora/init.extract-rule-action")), rules, cc);
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
}

void _35clofun1117(struct Cora* co) {
Obj _35val387 = co->args[1];
Obj pat = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj action = _35val387;
pushCont(co, _35clofun1118, 4, action, rules, value, cc);
coraCall(co, 2, globalRef(intern("macroexpand")), pat);
}

void _35clofun1118(struct Cora* co) {
Obj _35val388 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
pushCont(co, _35clofun1119, 3, rules, value, cc);
coraCall(co, 5, globalRef(intern("cora/init.match1")), _35val388, value, action, cc);
}

void _35clofun1119(struct Cora* co) {
Obj _35val389 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj curr = _35val389;
Obj _35reg390 = primCdr(rules);
Obj _35reg391 = primCdr(_35reg390);
pushCont(co, _35clofun1120, 2, curr, cc);
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), value, _35reg391);
}

void _35clofun1120(struct Cora* co) {
Obj _35val392 = co->args[1];
Obj curr = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
Obj rest = _35val392;
Obj _35reg393 = primCons(rest, Nil);
Obj _35reg394 = primCons(Nil, _35reg393);
Obj _35reg395 = primCons(intern("lambda"), _35reg394);
Obj _35reg396 = primCons(curr, Nil);
Obj _35reg397 = primCons(_35reg395, _35reg396);
Obj _35reg398 = primCons(cc, _35reg397);
Obj _35reg399 = primCons(intern("let"), _35reg398);
coraReturn(co, _35reg399);
return;
}

void _35clofun1108(struct Cora* co) {
Obj _35val354 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
if (True == _35val354) {
if (True == True) {
Obj _35reg355 = primCar(rules);
Obj pat = _35reg355;
Obj _35reg356 = primGenSym(intern("cc"));
Obj cc = _35reg356;
pushCont(co, _35clofun1109, 4, pat, rules, value, cc);
coraCall(co, 3, globalRef(intern("cora/init.extract-rule-action")), rules, cc);
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
} else {
if (True == False) {
Obj _35reg370 = primCar(rules);
Obj pat = _35reg370;
Obj _35reg371 = primGenSym(intern("cc"));
Obj cc = _35reg371;
pushCont(co, _35clofun1113, 4, pat, rules, value, cc);
coraCall(co, 3, globalRef(intern("cora/init.extract-rule-action")), rules, cc);
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
}

void _35clofun1113(struct Cora* co) {
Obj _35val372 = co->args[1];
Obj pat = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj action = _35val372;
pushCont(co, _35clofun1114, 4, action, rules, value, cc);
coraCall(co, 2, globalRef(intern("macroexpand")), pat);
}

void _35clofun1114(struct Cora* co) {
Obj _35val373 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
pushCont(co, _35clofun1115, 3, rules, value, cc);
coraCall(co, 5, globalRef(intern("cora/init.match1")), _35val373, value, action, cc);
}

void _35clofun1115(struct Cora* co) {
Obj _35val374 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj curr = _35val374;
Obj _35reg375 = primCdr(rules);
Obj _35reg376 = primCdr(_35reg375);
pushCont(co, _35clofun1116, 2, curr, cc);
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), value, _35reg376);
}

void _35clofun1116(struct Cora* co) {
Obj _35val377 = co->args[1];
Obj curr = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
Obj rest = _35val377;
Obj _35reg378 = primCons(rest, Nil);
Obj _35reg379 = primCons(Nil, _35reg378);
Obj _35reg380 = primCons(intern("lambda"), _35reg379);
Obj _35reg381 = primCons(curr, Nil);
Obj _35reg382 = primCons(_35reg380, _35reg381);
Obj _35reg383 = primCons(cc, _35reg382);
Obj _35reg384 = primCons(intern("let"), _35reg383);
coraReturn(co, _35reg384);
return;
}

void _35clofun1109(struct Cora* co) {
Obj _35val357 = co->args[1];
Obj pat = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj action = _35val357;
pushCont(co, _35clofun1110, 4, action, rules, value, cc);
coraCall(co, 2, globalRef(intern("macroexpand")), pat);
}

void _35clofun1110(struct Cora* co) {
Obj _35val358 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj rules = co->stack[co->base + 1];
Obj value = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
pushCont(co, _35clofun1111, 3, rules, value, cc);
coraCall(co, 5, globalRef(intern("cora/init.match1")), _35val358, value, action, cc);
}

void _35clofun1111(struct Cora* co) {
Obj _35val359 = co->args[1];
Obj rules = co->stack[co->base + 0];
Obj value = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj curr = _35val359;
Obj _35reg360 = primCdr(rules);
Obj _35reg361 = primCdr(_35reg360);
pushCont(co, _35clofun1112, 2, curr, cc);
coraCall(co, 3, globalRef(intern("cora/init.match-helper")), value, _35reg361);
}

void _35clofun1112(struct Cora* co) {
Obj _35val362 = co->args[1];
Obj curr = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
Obj rest = _35val362;
Obj _35reg363 = primCons(rest, Nil);
Obj _35reg364 = primCons(Nil, _35reg363);
Obj _35reg365 = primCons(intern("lambda"), _35reg364);
Obj _35reg366 = primCons(curr, Nil);
Obj _35reg367 = primCons(_35reg365, _35reg366);
Obj _35reg368 = primCons(cc, _35reg367);
Obj _35reg369 = primCons(intern("let"), _35reg368);
coraReturn(co, _35reg369);
return;
}

void _35clofun1097(struct Cora* co) {
Obj rules = co->args[1];
Obj cc = co->args[2];
Obj _35reg322 = primCdr(rules);
Obj _35reg323 = primCar(_35reg322);
Obj action = _35reg323;
pushCont(co, _35clofun1098, 2, cc, action);
coraCall(co, 2, globalRef(intern("pair?")), action);
}

void _35clofun1098(struct Cora* co) {
Obj _35val324 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj action = co->stack[co->base + 1];
if (True == _35val324) {
Obj _35reg325 = primCar(action);
Obj _35reg326 = primEQ(_35reg325, intern("where"));
if (True == _35reg326) {
if (True == True) {
pushCont(co, _35clofun1099, 2, action, cc);
coraCall(co, 2, globalRef(intern("cadr")), action);
} else {
coraReturn(co, action);
return;
}
} else {
if (True == False) {
pushCont(co, _35clofun1101, 2, action, cc);
coraCall(co, 2, globalRef(intern("cadr")), action);
} else {
coraReturn(co, action);
return;
}
}
} else {
if (True == False) {
pushCont(co, _35clofun1103, 2, action, cc);
coraCall(co, 2, globalRef(intern("cadr")), action);
} else {
coraReturn(co, action);
return;
}
}
}

void _35clofun1103(struct Cora* co) {
Obj _35val341 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
pushCont(co, _35clofun1104, 2, cc, _35val341);
coraCall(co, 2, globalRef(intern("caddr")), action);
}

void _35clofun1104(struct Cora* co) {
Obj _35val342 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35val341 = co->stack[co->base + 1];
Obj _35reg343 = primCons(cc, Nil);
Obj _35reg344 = primCons(_35reg343, Nil);
Obj _35reg345 = primCons(_35val342, _35reg344);
Obj _35reg346 = primCons(_35val341, _35reg345);
Obj _35reg347 = primCons(intern("if"), _35reg346);
coraReturn(co, _35reg347);
return;
}

void _35clofun1101(struct Cora* co) {
Obj _35val334 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
pushCont(co, _35clofun1102, 2, cc, _35val334);
coraCall(co, 2, globalRef(intern("caddr")), action);
}

void _35clofun1102(struct Cora* co) {
Obj _35val335 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35val334 = co->stack[co->base + 1];
Obj _35reg336 = primCons(cc, Nil);
Obj _35reg337 = primCons(_35reg336, Nil);
Obj _35reg338 = primCons(_35val335, _35reg337);
Obj _35reg339 = primCons(_35val334, _35reg338);
Obj _35reg340 = primCons(intern("if"), _35reg339);
coraReturn(co, _35reg340);
return;
}

void _35clofun1099(struct Cora* co) {
Obj _35val327 = co->args[1];
Obj action = co->stack[co->base + 0];
Obj cc = co->stack[co->base + 1];
pushCont(co, _35clofun1100, 2, cc, _35val327);
coraCall(co, 2, globalRef(intern("caddr")), action);
}

void _35clofun1100(struct Cora* co) {
Obj _35val328 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35val327 = co->stack[co->base + 1];
Obj _35reg329 = primCons(cc, Nil);
Obj _35reg330 = primCons(_35reg329, Nil);
Obj _35reg331 = primCons(_35val328, _35reg330);
Obj _35reg332 = primCons(_35val327, _35reg331);
Obj _35reg333 = primCons(intern("if"), _35reg332);
coraReturn(co, _35reg333);
return;
}

void _35clofun1091(struct Cora* co) {
Obj pat = co->args[1];
Obj expr = co->args[2];
Obj body = co->args[3];
Obj cc = co->args[4];
Obj literal_63 = makeNative(_35clofun1092, 1, 0);
pushCont(co, _35clofun1094, 4, expr, body, cc, pat);
coraCall(co, 2, literal_63, pat);
}

void _35clofun1094(struct Cora* co) {
Obj _35val292 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj pat = co->stack[co->base + 3];
if (True == _35val292) {
Obj _35reg293 = primEQ(pat, expr);
if (True == _35reg293) {
coraReturn(co, body);
return;
} else {
Obj _35reg294 = primCons(expr, Nil);
Obj _35reg295 = primCons(pat, _35reg294);
Obj _35reg296 = primCons(intern("="), _35reg295);
Obj _35reg297 = primCons(cc, Nil);
Obj _35reg298 = primCons(_35reg297, Nil);
Obj _35reg299 = primCons(body, _35reg298);
Obj _35reg300 = primCons(_35reg296, _35reg299);
Obj _35reg301 = primCons(intern("if"), _35reg300);
coraReturn(co, _35reg301);
return;
}
} else {
Obj _35reg302 = primIsSymbol(pat);
if (True == _35reg302) {
Obj _35reg303 = primCons(body, Nil);
Obj _35reg304 = primCons(expr, _35reg303);
Obj _35reg305 = primCons(pat, _35reg304);
Obj _35reg306 = primCons(intern("let"), _35reg305);
coraReturn(co, _35reg306);
return;
} else {
pushCont(co, _35clofun1095, 4, expr, body, cc, pat);
coraCall(co, 2, globalRef(intern("pair?")), pat);
}
}
}

void _35clofun1095(struct Cora* co) {
Obj _35val307 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj pat = co->stack[co->base + 3];
if (True == _35val307) {
Obj _35reg308 = primCar(pat);
Obj _35reg309 = primEQ(_35reg308, intern("quote"));
if (True == _35reg309) {
Obj _35reg310 = primCons(expr, Nil);
Obj _35reg311 = primCons(pat, _35reg310);
Obj _35reg312 = primCons(intern("="), _35reg311);
Obj _35reg313 = primCons(cc, Nil);
Obj _35reg314 = primCons(_35reg313, Nil);
Obj _35reg315 = primCons(body, _35reg314);
Obj _35reg316 = primCons(_35reg312, _35reg315);
Obj _35reg317 = primCons(intern("if"), _35reg316);
coraReturn(co, _35reg317);
return;
} else {
Obj _35reg318 = primCar(pat);
Obj _35reg319 = primEQ(_35reg318, intern("cons"));
if (True == _35reg319) {
coraCall(co, 5, globalRef(intern("cora/init.match-cons-expander")), pat, expr, body, cc);
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
} else {
pushCont(co, _35clofun1096, 0);
coraCall(co, 3, globalRef(intern("str")), makeString1("match fail "), pat);
}
}

void _35clofun1096(struct Cora* co) {
Obj _35val320 = co->args[1];
coraCall(co, 2, globalRef(intern("error")), _35val320);
}

void _35clofun1092(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun1093, 1, x);
coraCall(co, 2, globalRef(intern("atom?")), x);
}

void _35clofun1093(struct Cora* co) {
Obj _35val289 = co->args[1];
Obj x = co->stack[co->base + 0];
if (True == _35val289) {
Obj _35reg290 = primIsSymbol(x);
Obj _35reg291 = primNot(_35reg290);
if (True == _35reg291) {
coraReturn(co, True);
return;
} else {
coraReturn(co, False);
return;
}
} else {
coraReturn(co, False);
return;
}
}

void _35clofun1073(struct Cora* co) {
Obj pat = co->args[1];
Obj expr = co->args[2];
Obj body = co->args[3];
Obj cc = co->args[4];
pushCont(co, _35clofun1074, 4, pat, expr, body, cc);
coraCall(co, 2, globalRef(intern("cadr")), pat);
}

void _35clofun1074(struct Cora* co) {
Obj _35val235 = co->args[1];
Obj pat = co->stack[co->base + 0];
Obj expr = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj x = _35val235;
pushCont(co, _35clofun1075, 4, expr, body, x, cc);
coraCall(co, 2, globalRef(intern("caddr")), pat);
}

void _35clofun1075(struct Cora* co) {
Obj _35val236 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj x = co->stack[co->base + 2];
Obj cc = co->stack[co->base + 3];
Obj y = _35val236;
Obj _35reg237 = primIsCons(expr);
if (True == _35reg237) {
Obj _35reg238 = primCar(expr);
Obj _35reg239 = primEQ(_35reg238, intern("cons"));
if (True == _35reg239) {
if (True == True) {
pushCont(co, _35clofun1076, 5, expr, y, body, x, cc);
coraCall(co, 2, globalRef(intern("cadr")), expr);
} else {
Obj _35reg243 = primCons(expr, Nil);
Obj _35reg244 = primCons(intern("cons?"), _35reg243);
Obj _35reg245 = primCons(expr, Nil);
Obj _35reg246 = primCons(intern("car"), _35reg245);
Obj _35reg247 = primCons(expr, Nil);
Obj _35reg248 = primCons(intern("cdr"), _35reg247);
pushCont(co, _35clofun1079, 4, x, _35reg246, cc, _35reg244);
coraCall(co, 5, globalRef(intern("cora/init.match1")), y, _35reg248, body, cc);
}
} else {
if (True == False) {
pushCont(co, _35clofun1081, 5, expr, y, body, x, cc);
coraCall(co, 2, globalRef(intern("cadr")), expr);
} else {
Obj _35reg259 = primCons(expr, Nil);
Obj _35reg260 = primCons(intern("cons?"), _35reg259);
Obj _35reg261 = primCons(expr, Nil);
Obj _35reg262 = primCons(intern("car"), _35reg261);
Obj _35reg263 = primCons(expr, Nil);
Obj _35reg264 = primCons(intern("cdr"), _35reg263);
pushCont(co, _35clofun1084, 4, x, _35reg262, cc, _35reg260);
coraCall(co, 5, globalRef(intern("cora/init.match1")), y, _35reg264, body, cc);
}
}
} else {
if (True == False) {
pushCont(co, _35clofun1086, 5, expr, y, body, x, cc);
coraCall(co, 2, globalRef(intern("cadr")), expr);
} else {
Obj _35reg275 = primCons(expr, Nil);
Obj _35reg276 = primCons(intern("cons?"), _35reg275);
Obj _35reg277 = primCons(expr, Nil);
Obj _35reg278 = primCons(intern("car"), _35reg277);
Obj _35reg279 = primCons(expr, Nil);
Obj _35reg280 = primCons(intern("cdr"), _35reg279);
pushCont(co, _35clofun1089, 4, x, _35reg278, cc, _35reg276);
coraCall(co, 5, globalRef(intern("cora/init.match1")), y, _35reg280, body, cc);
}
}
}

void _35clofun1089(struct Cora* co) {
Obj _35val281 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg278 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj _35reg276 = co->stack[co->base + 3];
pushCont(co, _35clofun1090, 2, cc, _35reg276);
coraCall(co, 5, globalRef(intern("cora/init.match1")), x, _35reg278, _35val281, cc);
}

void _35clofun1090(struct Cora* co) {
Obj _35val282 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35reg276 = co->stack[co->base + 1];
Obj _35reg283 = primCons(cc, Nil);
Obj _35reg284 = primCons(_35reg283, Nil);
Obj _35reg285 = primCons(_35val282, _35reg284);
Obj _35reg286 = primCons(_35reg276, _35reg285);
Obj _35reg287 = primCons(intern("if"), _35reg286);
coraReturn(co, _35reg287);
return;
}

void _35clofun1086(struct Cora* co) {
Obj _35val272 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj x = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e1 = _35val272;
pushCont(co, _35clofun1087, 5, y, body, x, e1, cc);
coraCall(co, 2, globalRef(intern("caddr")), expr);
}

void _35clofun1087(struct Cora* co) {
Obj _35val273 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj x = co->stack[co->base + 2];
Obj e1 = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e2 = _35val273;
pushCont(co, _35clofun1088, 3, x, e1, cc);
coraCall(co, 5, globalRef(intern("cora/init.match1")), y, e2, body, cc);
}

void _35clofun1088(struct Cora* co) {
Obj _35val274 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj e1 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
coraCall(co, 5, globalRef(intern("cora/init.match1")), x, e1, _35val274, cc);
}

void _35clofun1084(struct Cora* co) {
Obj _35val265 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg262 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj _35reg260 = co->stack[co->base + 3];
pushCont(co, _35clofun1085, 2, cc, _35reg260);
coraCall(co, 5, globalRef(intern("cora/init.match1")), x, _35reg262, _35val265, cc);
}

void _35clofun1085(struct Cora* co) {
Obj _35val266 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35reg260 = co->stack[co->base + 1];
Obj _35reg267 = primCons(cc, Nil);
Obj _35reg268 = primCons(_35reg267, Nil);
Obj _35reg269 = primCons(_35val266, _35reg268);
Obj _35reg270 = primCons(_35reg260, _35reg269);
Obj _35reg271 = primCons(intern("if"), _35reg270);
coraReturn(co, _35reg271);
return;
}

void _35clofun1081(struct Cora* co) {
Obj _35val256 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj x = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e1 = _35val256;
pushCont(co, _35clofun1082, 5, y, body, x, e1, cc);
coraCall(co, 2, globalRef(intern("caddr")), expr);
}

void _35clofun1082(struct Cora* co) {
Obj _35val257 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj x = co->stack[co->base + 2];
Obj e1 = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e2 = _35val257;
pushCont(co, _35clofun1083, 3, x, e1, cc);
coraCall(co, 5, globalRef(intern("cora/init.match1")), y, e2, body, cc);
}

void _35clofun1083(struct Cora* co) {
Obj _35val258 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj e1 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
coraCall(co, 5, globalRef(intern("cora/init.match1")), x, e1, _35val258, cc);
}

void _35clofun1079(struct Cora* co) {
Obj _35val249 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg246 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
Obj _35reg244 = co->stack[co->base + 3];
pushCont(co, _35clofun1080, 2, cc, _35reg244);
coraCall(co, 5, globalRef(intern("cora/init.match1")), x, _35reg246, _35val249, cc);
}

void _35clofun1080(struct Cora* co) {
Obj _35val250 = co->args[1];
Obj cc = co->stack[co->base + 0];
Obj _35reg244 = co->stack[co->base + 1];
Obj _35reg251 = primCons(cc, Nil);
Obj _35reg252 = primCons(_35reg251, Nil);
Obj _35reg253 = primCons(_35val250, _35reg252);
Obj _35reg254 = primCons(_35reg244, _35reg253);
Obj _35reg255 = primCons(intern("if"), _35reg254);
coraReturn(co, _35reg255);
return;
}

void _35clofun1076(struct Cora* co) {
Obj _35val240 = co->args[1];
Obj expr = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj x = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e1 = _35val240;
pushCont(co, _35clofun1077, 5, y, body, x, e1, cc);
coraCall(co, 2, globalRef(intern("caddr")), expr);
}

void _35clofun1077(struct Cora* co) {
Obj _35val241 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj x = co->stack[co->base + 2];
Obj e1 = co->stack[co->base + 3];
Obj cc = co->stack[co->base + 4];
Obj e2 = _35val241;
pushCont(co, _35clofun1078, 3, x, e1, cc);
coraCall(co, 5, globalRef(intern("cora/init.match1")), y, e2, body, cc);
}

void _35clofun1078(struct Cora* co) {
Obj _35val242 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj e1 = co->stack[co->base + 1];
Obj cc = co->stack[co->base + 2];
coraCall(co, 5, globalRef(intern("cora/init.match1")), x, e1, _35val242, cc);
}

void _35clofun1071(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg233 = primCdr(exp);
coraCall(co, 2, globalRef(intern("cora/init.rcons1")), _35reg233);
}

void _35clofun1068(struct Cora* co) {
Obj pat = co->args[1];
Obj _35reg223 = primCdr(pat);
pushCont(co, _35clofun1069, 1, pat);
coraCall(co, 2, globalRef(intern("null?")), _35reg223);
}

void _35clofun1069(struct Cora* co) {
Obj _35val224 = co->args[1];
Obj pat = co->stack[co->base + 0];
if (True == _35val224) {
Obj _35reg225 = primCar(pat);
coraReturn(co, _35reg225);
return;
} else {
Obj _35reg226 = primCar(pat);
Obj _35reg227 = primCdr(pat);
pushCont(co, _35clofun1070, 1, _35reg226);
coraCall(co, 2, globalRef(intern("cora/init.rcons1")), _35reg227);
}
}

void _35clofun1070(struct Cora* co) {
Obj _35val228 = co->args[1];
Obj _35reg226 = co->stack[co->base + 0];
Obj _35reg229 = primCons(_35val228, Nil);
Obj _35reg230 = primCons(_35reg226, _35reg229);
Obj _35reg231 = primCons(intern("cons"), _35reg230);
coraReturn(co, _35reg231);
return;
}

void _35clofun1067(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg220 = primEQ(x, True);
if (True == _35reg220) {
coraReturn(co, True);
return;
} else {
Obj _35reg221 = primEQ(x, False);
if (True == _35reg221) {
coraReturn(co, True);
return;
} else {
coraReturn(co, False);
return;
}
}
}

void _35clofun1065(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg218 = primCdr(exp);
coraCall(co, 2, globalRef(intern("cora/init.rewrite-and")), _35reg218);
}

void _35clofun1063(struct Cora* co) {
Obj l = co->args[1];
Obj _35reg206 = primEQ(Nil, l);
if (True == _35reg206) {
coraReturn(co, True);
return;
} else {
Obj _35reg207 = primCar(l);
Obj _35reg208 = primEQ(_35reg207, False);
if (True == _35reg208) {
coraReturn(co, False);
return;
} else {
Obj _35reg209 = primCdr(l);
pushCont(co, _35clofun1064, 1, l);
coraCall(co, 2, globalRef(intern("cora/init.rewrite-and")), _35reg209);
}
}
}

void _35clofun1064(struct Cora* co) {
Obj _35val210 = co->args[1];
Obj l = co->stack[co->base + 0];
Obj more = _35val210;
Obj _35reg211 = primEQ(more, False);
if (True == _35reg211) {
coraReturn(co, False);
return;
} else {
Obj _35reg212 = primCar(l);
Obj _35reg213 = primCons(False, Nil);
Obj _35reg214 = primCons(more, _35reg213);
Obj _35reg215 = primCons(_35reg212, _35reg214);
Obj _35reg216 = primCons(intern("if"), _35reg215);
coraReturn(co, _35reg216);
return;
}
}

void _35clofun1061(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg204 = primCdr(exp);
coraCall(co, 2, globalRef(intern("cora/init.rewrite-or")), _35reg204);
}

void _35clofun1059(struct Cora* co) {
Obj l = co->args[1];
Obj _35reg192 = primEQ(l, Nil);
if (True == _35reg192) {
coraReturn(co, False);
return;
} else {
Obj _35reg193 = primCar(l);
Obj _35reg194 = primEQ(_35reg193, True);
if (True == _35reg194) {
coraReturn(co, True);
return;
} else {
Obj _35reg195 = primCdr(l);
pushCont(co, _35clofun1060, 1, l);
coraCall(co, 2, globalRef(intern("cora/init.rewrite-or")), _35reg195);
}
}
}

void _35clofun1060(struct Cora* co) {
Obj _35val196 = co->args[1];
Obj l = co->stack[co->base + 0];
Obj more = _35val196;
Obj _35reg197 = primEQ(more, True);
if (True == _35reg197) {
coraReturn(co, True);
return;
} else {
Obj _35reg198 = primCar(l);
Obj _35reg199 = primCons(more, Nil);
Obj _35reg200 = primCons(True, _35reg199);
Obj _35reg201 = primCons(_35reg198, _35reg200);
Obj _35reg202 = primCons(intern("if"), _35reg201);
coraReturn(co, _35reg202);
return;
}
}

void _35clofun1054(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg178 = primCdr(exp);
Obj _35reg179 = primEQ(Nil, _35reg178);
if (True == _35reg179) {
Obj _35reg180 = primCons(makeString1("no cond match"), Nil);
Obj _35reg181 = primCons(intern("error"), _35reg180);
coraReturn(co, _35reg181);
return;
} else {
pushCont(co, _35clofun1055, 1, exp);
coraCall(co, 2, globalRef(intern("cadr")), exp);
}
}

void _35clofun1055(struct Cora* co) {
Obj _35val182 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj curr = _35val182;
Obj _35reg183 = primCar(curr);
pushCont(co, _35clofun1056, 2, exp, _35reg183);
coraCall(co, 2, globalRef(intern("cadr")), curr);
}

void _35clofun1056(struct Cora* co) {
Obj _35val184 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg183 = co->stack[co->base + 1];
pushCont(co, _35clofun1057, 2, _35val184, _35reg183);
coraCall(co, 2, globalRef(intern("cddr")), exp);
}

void _35clofun1057(struct Cora* co) {
Obj _35val185 = co->args[1];
Obj _35val184 = co->stack[co->base + 0];
Obj _35reg183 = co->stack[co->base + 1];
Obj _35reg186 = primCons(intern("cond"), _35val185);
Obj _35reg187 = primCons(_35reg186, Nil);
Obj _35reg188 = primCons(_35val184, _35reg187);
Obj _35reg189 = primCons(_35reg183, _35reg188);
Obj _35reg190 = primCons(intern("if"), _35reg189);
coraReturn(co, _35reg190);
return;
}

void _35clofun1052(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg176 = primCdr(exp);
coraCall(co, 2, globalRef(intern("cora/init.rewrite-let")), _35reg176);
}

void _35clofun1047(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg164 = primCdr(exp);
pushCont(co, _35clofun1048, 1, exp);
coraCall(co, 2, globalRef(intern("null?")), _35reg164);
}

void _35clofun1048(struct Cora* co) {
Obj _35val165 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val165) {
Obj _35reg166 = primCar(exp);
coraReturn(co, _35reg166);
return;
} else {
Obj _35reg167 = primCar(exp);
pushCont(co, _35clofun1049, 2, exp, _35reg167);
coraCall(co, 2, globalRef(intern("cadr")), exp);
}
}

void _35clofun1049(struct Cora* co) {
Obj _35val168 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg167 = co->stack[co->base + 1];
pushCont(co, _35clofun1050, 2, _35val168, _35reg167);
coraCall(co, 2, globalRef(intern("cddr")), exp);
}

void _35clofun1050(struct Cora* co) {
Obj _35val169 = co->args[1];
Obj _35val168 = co->stack[co->base + 0];
Obj _35reg167 = co->stack[co->base + 1];
pushCont(co, _35clofun1051, 2, _35val168, _35reg167);
coraCall(co, 2, globalRef(intern("cora/init.rewrite-let")), _35val169);
}

void _35clofun1051(struct Cora* co) {
Obj _35val170 = co->args[1];
Obj _35val168 = co->stack[co->base + 0];
Obj _35reg167 = co->stack[co->base + 1];
Obj _35reg171 = primCons(_35val170, Nil);
Obj _35reg172 = primCons(_35val168, _35reg171);
Obj _35reg173 = primCons(_35reg167, _35reg172);
Obj _35reg174 = primCons(intern("let"), _35reg173);
coraReturn(co, _35reg174);
return;
}

void _35clofun1046(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg161 = primIsCons(x);
Obj _35reg162 = primNot(_35reg161);
coraReturn(co, _35reg162);
return;
}

void _35clofun1045(struct Cora* co) {
Obj x = co->args[1];
Obj l = co->args[2];
Obj _35reg156 = primIsCons(l);
if (True == _35reg156) {
Obj _35reg157 = primCar(l);
Obj _35reg158 = primEQ(_35reg157, x);
if (True == _35reg158) {
coraReturn(co, True);
return;
} else {
Obj _35reg159 = primCdr(l);
coraCall(co, 3, globalRef(intern("elem?")), x, _35reg159);
}
} else {
coraReturn(co, False);
return;
}
}

void _35clofun1040(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun1041, 1, exp);
coraCall(co, 2, globalRef(intern("cadr")), exp);
}

void _35clofun1041(struct Cora* co) {
Obj _35val144 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg145 = primCons(_35val144, Nil);
Obj _35reg146 = primCons(intern("quote"), _35reg145);
pushCont(co, _35clofun1042, 2, exp, _35reg146);
coraCall(co, 2, globalRef(intern("caddr")), exp);
}

void _35clofun1042(struct Cora* co) {
Obj _35val147 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg146 = co->stack[co->base + 1];
pushCont(co, _35clofun1043, 2, _35val147, _35reg146);
coraCall(co, 2, globalRef(intern("cadddr")), exp);
}

void _35clofun1043(struct Cora* co) {
Obj _35val148 = co->args[1];
Obj _35val147 = co->stack[co->base + 0];
Obj _35reg146 = co->stack[co->base + 1];
Obj _35reg149 = primCons(_35val148, Nil);
Obj _35reg150 = primCons(_35val147, _35reg149);
Obj _35reg151 = primCons(intern("lambda"), _35reg150);
Obj _35reg152 = primCons(_35reg151, Nil);
Obj _35reg153 = primCons(_35reg146, _35reg152);
Obj _35reg154 = primCons(intern("set"), _35reg153);
coraReturn(co, _35reg154);
return;
}

void _35clofun1038(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg142 = primCdr(exp);
coraCall(co, 2, globalRef(intern("rcons")), _35reg142);
}

void _35clofun1033(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun1034, 1, exp);
coraCall(co, 2, globalRef(intern("cadr")), exp);
}

void _35clofun1034(struct Cora* co) {
Obj _35val130 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg131 = primCons(_35val130, Nil);
Obj _35reg132 = primCons(intern("quote"), _35reg131);
pushCont(co, _35clofun1035, 2, exp, _35reg132);
coraCall(co, 2, globalRef(intern("caddr")), exp);
}

void _35clofun1035(struct Cora* co) {
Obj _35val133 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg132 = co->stack[co->base + 1];
pushCont(co, _35clofun1036, 2, _35val133, _35reg132);
coraCall(co, 2, globalRef(intern("cdddr")), exp);
}

void _35clofun1036(struct Cora* co) {
Obj _35val134 = co->args[1];
Obj _35val133 = co->stack[co->base + 0];
Obj _35reg132 = co->stack[co->base + 1];
Obj _35reg135 = primCons(_35val133, _35val134);
Obj _35reg136 = primCons(intern("lambda"), _35reg135);
Obj _35reg137 = primCons(_35reg136, Nil);
Obj _35reg138 = primCons(_35reg132, _35reg137);
Obj _35reg139 = primCons(intern("cora/init.add-to-*macros*"), _35reg138);
coraReturn(co, _35reg139);
return;
}

void _35clofun1027(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg112 = primIsCons(exp);
if (True == _35reg112) {
Obj _35reg113 = primCar(exp);
Obj _35reg114 = primEQ(_35reg113, globalRef(intern("*protect-symbol*")));
if (True == _35reg114) {
Obj _35reg115 = primCdr(exp);
coraReturn(co, _35reg115);
return;
} else {
Obj _35reg116 = primCar(exp);
Obj _35reg117 = primEQ(_35reg116, intern("lambda"));
if (True == _35reg117) {
pushCont(co, _35clofun1028, 1, exp);
coraCall(co, 2, globalRef(intern("cadr")), exp);
} else {
Obj _35reg124 = primCar(exp);
Obj _35reg125 = primEQ(_35reg124, intern("quote"));
if (True == _35reg125) {
coraReturn(co, exp);
return;
} else {
pushCont(co, _35clofun1031, 1, exp);
coraCall(co, 2, globalRef(intern("cora/init.macroexpand1")), exp);
}
}
}
} else {
coraReturn(co, exp);
return;
}
}

void _35clofun1031(struct Cora* co) {
Obj _35val127 = co->args[1];
Obj exp = co->stack[co->base + 0];
coraCall(co, 2, makeNative(_35clofun1032, 1, 1, exp), _35val127);
}

void _35clofun1032(struct Cora* co) {
Obj exp1 = co->args[1];
Obj _35reg126 = primEQ(exp1, closureRef(co, 0));
if (True == _35reg126) {
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/init.macroexpand-boot")), exp1);
} else {
coraCall(co, 2, globalRef(intern("cora/init.macroexpand-boot")), exp1);
}
}

void _35clofun1028(struct Cora* co) {
Obj _35val118 = co->args[1];
Obj exp = co->stack[co->base + 0];
pushCont(co, _35clofun1029, 1, _35val118);
coraCall(co, 2, globalRef(intern("caddr")), exp);
}

void _35clofun1029(struct Cora* co) {
Obj _35val119 = co->args[1];
Obj _35val118 = co->stack[co->base + 0];
pushCont(co, _35clofun1030, 1, _35val118);
coraCall(co, 2, globalRef(intern("cora/init.macroexpand-boot")), _35val119);
}

void _35clofun1030(struct Cora* co) {
Obj _35val120 = co->args[1];
Obj _35val118 = co->stack[co->base + 0];
Obj _35reg121 = primCons(_35val120, Nil);
Obj _35reg122 = primCons(_35val118, _35reg121);
Obj _35reg123 = primCons(intern("lambda"), _35reg122);
coraReturn(co, _35reg123);
return;
}

void _35clofun1026(struct Cora* co) {
Obj exp = co->args[1];
coraCall(co, 3, globalRef(intern("cora/init.macroexpand1-h")), exp, globalRef(intern("*macros*")));
}

void _35clofun1024(struct Cora* co) {
Obj exp = co->args[1];
Obj macros = co->args[2];
Obj _35reg98 = primEQ(Nil, macros);
if (True == _35reg98) {
coraReturn(co, exp);
return;
} else {
Obj _35reg109 = primCar(macros);
coraCall(co, 2, makeNative(_35clofun1025, 1, 2, exp, macros), _35reg109);
}
}

void _35clofun1025(struct Cora* co) {
Obj item = co->args[1];
Obj _35reg99 = primIsCons(closureRef(co, 0));
if (True == _35reg99) {
Obj _35reg100 = primCar(closureRef(co, 0));
Obj _35reg101 = primCar(item);
Obj _35reg102 = primEQ(_35reg100, _35reg101);
if (True == _35reg102) {
if (True == True) {
Obj _35reg103 = primCdr(item);
coraCall(co, 2, _35reg103, closureRef(co, 0));
} else {
Obj _35reg104 = primCdr(closureRef(co, 1));
coraCall(co, 3, globalRef(intern("cora/init.macroexpand1-h")), closureRef(co, 0), _35reg104);
}
} else {
if (True == False) {
Obj _35reg105 = primCdr(item);
coraCall(co, 2, _35reg105, closureRef(co, 0));
} else {
Obj _35reg106 = primCdr(closureRef(co, 1));
coraCall(co, 3, globalRef(intern("cora/init.macroexpand1-h")), closureRef(co, 0), _35reg106);
}
}
} else {
if (True == False) {
Obj _35reg107 = primCdr(item);
coraCall(co, 2, _35reg107, closureRef(co, 0));
} else {
Obj _35reg108 = primCdr(closureRef(co, 1));
coraCall(co, 3, globalRef(intern("cora/init.macroexpand1-h")), closureRef(co, 0), _35reg108);
}
}
}

void _35clofun1023(struct Cora* co) {
Obj n = co->args[1];
Obj v = co->args[2];
Obj _35reg94 = primCons(n, v);
Obj _35reg95 = primCons(_35reg94, globalRef(intern("*macros*")));
Obj _35reg96 = primSet(intern("*macros*"), _35reg95);
coraReturn(co, _35reg96);
return;
}

void _35clofun1022(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg92 = primCons(globalRef(intern("*protect-symbol*")), x);
coraReturn(co, _35reg92);
return;
}

void _35clofun1021(struct Cora* co) {
Obj f = co->args[1];
Obj l = co->args[2];
coraCall(co, 4, globalRef(intern("map-h")), Nil, f, l);
}

void _35clofun1019(struct Cora* co) {
Obj res = co->args[1];
Obj f = co->args[2];
Obj l = co->args[3];
Obj _35reg82 = primIsCons(l);
if (True == _35reg82) {
Obj _35reg83 = primCar(l);
pushCont(co, _35clofun1020, 3, res, l, f);
coraCall(co, 2, f, _35reg83);
} else {
coraCall(co, 2, globalRef(intern("reverse")), res);
}
}

void _35clofun1020(struct Cora* co) {
Obj _35val84 = co->args[1];
Obj res = co->stack[co->base + 0];
Obj l = co->stack[co->base + 1];
Obj f = co->stack[co->base + 2];
Obj _35reg85 = primCons(_35val84, res);
Obj _35reg86 = primCdr(l);
coraCall(co, 4, globalRef(intern("map-h")), _35reg85, f, _35reg86);
}

void _35clofun1017(struct Cora* co) {
Obj res = co->args[1];
Obj l = co->args[2];
Obj _35reg75 = primIsCons(l);
if (True == _35reg75) {
Obj _35reg76 = primCar(l);
Obj _35reg77 = primCons(_35reg76, res);
Obj _35reg78 = primCdr(l);
coraCall(co, 3, globalRef(intern("cora/init.reverse-h")), _35reg77, _35reg78);
} else {
coraReturn(co, res);
return;
}
}

void _35clofun1016(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg73 = primIsCons(x);
coraReturn(co, _35reg73);
return;
}

void _35clofun1014(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg65 = primIsCons(exp);
if (True == _35reg65) {
Obj _35reg66 = primCar(exp);
Obj _35reg67 = primCdr(exp);
pushCont(co, _35clofun1015, 1, _35reg66);
coraCall(co, 2, globalRef(intern("rcons")), _35reg67);
} else {
coraReturn(co, Nil);
return;
}
}

void _35clofun1015(struct Cora* co) {
Obj _35val68 = co->args[1];
Obj _35reg66 = co->stack[co->base + 0];
Obj _35reg69 = primCons(_35val68, Nil);
Obj _35reg70 = primCons(_35reg66, _35reg69);
Obj _35reg71 = primCons(intern("cons"), _35reg70);
coraReturn(co, _35reg71);
return;
}

void _35clofun1013(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg61 = primCdr(x);
Obj _35reg62 = primCdr(_35reg61);
Obj _35reg63 = primCdr(_35reg62);
coraReturn(co, _35reg63);
return;
}

void _35clofun1012(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg56 = primCdr(x);
Obj _35reg57 = primCdr(_35reg56);
Obj _35reg58 = primCdr(_35reg57);
Obj _35reg59 = primCar(_35reg58);
coraReturn(co, _35reg59);
return;
}

void _35clofun1011(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg52 = primCdr(x);
Obj _35reg53 = primCdr(_35reg52);
Obj _35reg54 = primCar(_35reg53);
coraReturn(co, _35reg54);
return;
}

void _35clofun1010(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg49 = primCdr(x);
Obj _35reg50 = primCdr(_35reg49);
coraReturn(co, _35reg50);
return;
}

void _35clofun1009(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg46 = primCar(x);
Obj _35reg47 = primCdr(_35reg46);
coraReturn(co, _35reg47);
return;
}

void _35clofun1008(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg43 = primCar(x);
Obj _35reg44 = primCar(_35reg43);
coraReturn(co, _35reg44);
return;
}

void _35clofun1007(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg40 = primCdr(x);
Obj _35reg41 = primCar(_35reg40);
coraReturn(co, _35reg41);
return;
}

void _35clofun1006(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg38 = primEQ(x, Nil);
coraReturn(co, _35reg38);
return;
}

