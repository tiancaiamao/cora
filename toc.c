#include "types.h"
#include "runtime.h"

void entry(struct Cora* co);
void _35clofun2883(struct Cora* co);
void _35clofun2884(struct Cora* co);
void _35clofun3194(struct Cora* co);
void _35clofun3240(struct Cora* co);
void _35clofun3241(struct Cora* co);
void _35clofun3246(struct Cora* co);
void _35clofun3249(struct Cora* co);
void _35clofun3252(struct Cora* co);
void _35clofun3253(struct Cora* co);
void _35clofun3250(struct Cora* co);
void _35clofun3251(struct Cora* co);
void _35clofun3247(struct Cora* co);
void _35clofun3248(struct Cora* co);
void _35clofun3244(struct Cora* co);
void _35clofun3245(struct Cora* co);
void _35clofun3242(struct Cora* co);
void _35clofun3243(struct Cora* co);
void _35clofun3239(struct Cora* co);
void _35clofun3238(struct Cora* co);
void _35clofun3237(struct Cora* co);
void _35clofun3236(struct Cora* co);
void _35clofun3235(struct Cora* co);
void _35clofun3234(struct Cora* co);
void _35clofun3233(struct Cora* co);
void _35clofun3232(struct Cora* co);
void _35clofun3231(struct Cora* co);
void _35clofun3230(struct Cora* co);
void _35clofun3229(struct Cora* co);
void _35clofun3228(struct Cora* co);
void _35clofun3227(struct Cora* co);
void _35clofun3226(struct Cora* co);
void _35clofun3225(struct Cora* co);
void _35clofun3224(struct Cora* co);
void _35clofun3217(struct Cora* co);
void _35clofun3218(struct Cora* co);
void _35clofun3219(struct Cora* co);
void _35clofun3220(struct Cora* co);
void _35clofun3221(struct Cora* co);
void _35clofun3222(struct Cora* co);
void _35clofun3223(struct Cora* co);
void _35clofun3212(struct Cora* co);
void _35clofun3213(struct Cora* co);
void _35clofun3216(struct Cora* co);
void _35clofun3214(struct Cora* co);
void _35clofun3215(struct Cora* co);
void _35clofun3204(struct Cora* co);
void _35clofun3205(struct Cora* co);
void _35clofun3206(struct Cora* co);
void _35clofun3209(struct Cora* co);
void _35clofun3210(struct Cora* co);
void _35clofun3211(struct Cora* co);
void _35clofun3207(struct Cora* co);
void _35clofun3208(struct Cora* co);
void _35clofun3200(struct Cora* co);
void _35clofun3201(struct Cora* co);
void _35clofun3203(struct Cora* co);
void _35clofun3202(struct Cora* co);
void _35clofun3195(struct Cora* co);
void _35clofun3196(struct Cora* co);
void _35clofun3197(struct Cora* co);
void _35clofun3198(struct Cora* co);
void _35clofun3199(struct Cora* co);
void _35clofun3191(struct Cora* co);
void _35clofun3192(struct Cora* co);
void _35clofun3193(struct Cora* co);
void _35clofun3188(struct Cora* co);
void _35clofun3189(struct Cora* co);
void _35clofun3190(struct Cora* co);
void _35clofun3186(struct Cora* co);
void _35clofun3187(struct Cora* co);
void _35clofun3185(struct Cora* co);
void _35clofun3184(struct Cora* co);
void _35clofun3183(struct Cora* co);
void _35clofun3182(struct Cora* co);
void _35clofun3175(struct Cora* co);
void _35clofun3177(struct Cora* co);
void _35clofun3178(struct Cora* co);
void _35clofun3179(struct Cora* co);
void _35clofun3180(struct Cora* co);
void _35clofun3181(struct Cora* co);
void _35clofun3176(struct Cora* co);
void _35clofun3167(struct Cora* co);
void _35clofun3168(struct Cora* co);
void _35clofun3170(struct Cora* co);
void _35clofun3171(struct Cora* co);
void _35clofun3172(struct Cora* co);
void _35clofun3173(struct Cora* co);
void _35clofun3174(struct Cora* co);
void _35clofun3169(struct Cora* co);
void _35clofun3163(struct Cora* co);
void _35clofun3164(struct Cora* co);
void _35clofun3165(struct Cora* co);
void _35clofun3166(struct Cora* co);
void _35clofun3162(struct Cora* co);
void _35clofun3156(struct Cora* co);
void _35clofun3157(struct Cora* co);
void _35clofun3159(struct Cora* co);
void _35clofun3160(struct Cora* co);
void _35clofun3161(struct Cora* co);
void _35clofun3158(struct Cora* co);
void _35clofun3145(struct Cora* co);
void _35clofun3147(struct Cora* co);
void _35clofun3148(struct Cora* co);
void _35clofun3149(struct Cora* co);
void _35clofun3150(struct Cora* co);
void _35clofun3151(struct Cora* co);
void _35clofun3152(struct Cora* co);
void _35clofun3155(struct Cora* co);
void _35clofun3153(struct Cora* co);
void _35clofun3154(struct Cora* co);
void _35clofun3146(struct Cora* co);
void _35clofun3137(struct Cora* co);
void _35clofun3138(struct Cora* co);
void _35clofun3140(struct Cora* co);
void _35clofun3141(struct Cora* co);
void _35clofun3142(struct Cora* co);
void _35clofun3143(struct Cora* co);
void _35clofun3144(struct Cora* co);
void _35clofun3139(struct Cora* co);
void _35clofun3065(struct Cora* co);
void _35clofun3066(struct Cora* co);
void _35clofun3134(struct Cora* co);
void _35clofun3135(struct Cora* co);
void _35clofun3136(struct Cora* co);
void _35clofun3067(struct Cora* co);
void _35clofun3132(struct Cora* co);
void _35clofun3133(struct Cora* co);
void _35clofun3068(struct Cora* co);
void _35clofun3130(struct Cora* co);
void _35clofun3131(struct Cora* co);
void _35clofun3069(struct Cora* co);
void _35clofun3124(struct Cora* co);
void _35clofun3127(struct Cora* co);
void _35clofun3128(struct Cora* co);
void _35clofun3129(struct Cora* co);
void _35clofun3125(struct Cora* co);
void _35clofun3126(struct Cora* co);
void _35clofun3121(struct Cora* co);
void _35clofun3122(struct Cora* co);
void _35clofun3123(struct Cora* co);
void _35clofun3070(struct Cora* co);
void _35clofun3111(struct Cora* co);
void _35clofun3117(struct Cora* co);
void _35clofun3118(struct Cora* co);
void _35clofun3119(struct Cora* co);
void _35clofun3120(struct Cora* co);
void _35clofun3112(struct Cora* co);
void _35clofun3113(struct Cora* co);
void _35clofun3114(struct Cora* co);
void _35clofun3115(struct Cora* co);
void _35clofun3116(struct Cora* co);
void _35clofun3071(struct Cora* co);
void _35clofun3107(struct Cora* co);
void _35clofun3108(struct Cora* co);
void _35clofun3109(struct Cora* co);
void _35clofun3110(struct Cora* co);
void _35clofun3072(struct Cora* co);
void _35clofun3101(struct Cora* co);
void _35clofun3102(struct Cora* co);
void _35clofun3103(struct Cora* co);
void _35clofun3104(struct Cora* co);
void _35clofun3105(struct Cora* co);
void _35clofun3106(struct Cora* co);
void _35clofun3073(struct Cora* co);
void _35clofun3091(struct Cora* co);
void _35clofun3092(struct Cora* co);
void _35clofun3093(struct Cora* co);
void _35clofun3094(struct Cora* co);
void _35clofun3095(struct Cora* co);
void _35clofun3096(struct Cora* co);
void _35clofun3097(struct Cora* co);
void _35clofun3098(struct Cora* co);
void _35clofun3099(struct Cora* co);
void _35clofun3100(struct Cora* co);
void _35clofun3074(struct Cora* co);
void _35clofun3089(struct Cora* co);
void _35clofun3090(struct Cora* co);
void _35clofun3075(struct Cora* co);
void _35clofun3087(struct Cora* co);
void _35clofun3088(struct Cora* co);
void _35clofun3076(struct Cora* co);
void _35clofun3077(struct Cora* co);
void _35clofun3086(struct Cora* co);
void _35clofun3078(struct Cora* co);
void _35clofun3080(struct Cora* co);
void _35clofun3081(struct Cora* co);
void _35clofun3082(struct Cora* co);
void _35clofun3085(struct Cora* co);
void _35clofun3083(struct Cora* co);
void _35clofun3084(struct Cora* co);
void _35clofun3079(struct Cora* co);
void _35clofun3063(struct Cora* co);
void _35clofun3064(struct Cora* co);
void _35clofun3058(struct Cora* co);
void _35clofun3062(struct Cora* co);
void _35clofun3059(struct Cora* co);
void _35clofun3061(struct Cora* co);
void _35clofun3060(struct Cora* co);
void _35clofun3048(struct Cora* co);
void _35clofun3056(struct Cora* co);
void _35clofun3057(struct Cora* co);
void _35clofun3054(struct Cora* co);
void _35clofun3055(struct Cora* co);
void _35clofun3052(struct Cora* co);
void _35clofun3053(struct Cora* co);
void _35clofun3049(struct Cora* co);
void _35clofun3050(struct Cora* co);
void _35clofun3051(struct Cora* co);
void _35clofun3030(struct Cora* co);
void _35clofun3047(struct Cora* co);
void _35clofun3031(struct Cora* co);
void _35clofun3032(struct Cora* co);
void _35clofun3046(struct Cora* co);
void _35clofun3033(struct Cora* co);
void _35clofun3041(struct Cora* co);
void _35clofun3042(struct Cora* co);
void _35clofun3043(struct Cora* co);
void _35clofun3044(struct Cora* co);
void _35clofun3045(struct Cora* co);
void _35clofun3034(struct Cora* co);
void _35clofun3038(struct Cora* co);
void _35clofun3039(struct Cora* co);
void _35clofun3040(struct Cora* co);
void _35clofun3035(struct Cora* co);
void _35clofun3037(struct Cora* co);
void _35clofun3036(struct Cora* co);
void _35clofun3020(struct Cora* co);
void _35clofun3024(struct Cora* co);
void _35clofun3025(struct Cora* co);
void _35clofun3029(struct Cora* co);
void _35clofun3026(struct Cora* co);
void _35clofun3028(struct Cora* co);
void _35clofun3027(struct Cora* co);
void _35clofun3021(struct Cora* co);
void _35clofun3023(struct Cora* co);
void _35clofun3022(struct Cora* co);
void _35clofun3002(struct Cora* co);
void _35clofun3019(struct Cora* co);
void _35clofun3003(struct Cora* co);
void _35clofun3018(struct Cora* co);
void _35clofun3004(struct Cora* co);
void _35clofun3015(struct Cora* co);
void _35clofun3016(struct Cora* co);
void _35clofun3017(struct Cora* co);
void _35clofun3005(struct Cora* co);
void _35clofun3013(struct Cora* co);
void _35clofun3014(struct Cora* co);
void _35clofun3006(struct Cora* co);
void _35clofun3011(struct Cora* co);
void _35clofun3012(struct Cora* co);
void _35clofun3007(struct Cora* co);
void _35clofun3010(struct Cora* co);
void _35clofun3008(struct Cora* co);
void _35clofun3009(struct Cora* co);
void _35clofun3001(struct Cora* co);
void _35clofun2986(struct Cora* co);
void _35clofun3000(struct Cora* co);
void _35clofun2987(struct Cora* co);
void _35clofun2999(struct Cora* co);
void _35clofun2988(struct Cora* co);
void _35clofun2995(struct Cora* co);
void _35clofun2996(struct Cora* co);
void _35clofun2997(struct Cora* co);
void _35clofun2998(struct Cora* co);
void _35clofun2989(struct Cora* co);
void _35clofun2993(struct Cora* co);
void _35clofun2994(struct Cora* co);
void _35clofun2990(struct Cora* co);
void _35clofun2992(struct Cora* co);
void _35clofun2991(struct Cora* co);
void _35clofun2963(struct Cora* co);
void _35clofun2985(struct Cora* co);
void _35clofun2964(struct Cora* co);
void _35clofun2965(struct Cora* co);
void _35clofun2984(struct Cora* co);
void _35clofun2966(struct Cora* co);
void _35clofun2983(struct Cora* co);
void _35clofun2967(struct Cora* co);
void _35clofun2982(struct Cora* co);
void _35clofun2968(struct Cora* co);
void _35clofun2979(struct Cora* co);
void _35clofun2980(struct Cora* co);
void _35clofun2981(struct Cora* co);
void _35clofun2969(struct Cora* co);
void _35clofun2970(struct Cora* co);
void _35clofun2971(struct Cora* co);
void _35clofun2978(struct Cora* co);
void _35clofun2972(struct Cora* co);
void _35clofun2973(struct Cora* co);
void _35clofun2977(struct Cora* co);
void _35clofun2974(struct Cora* co);
void _35clofun2976(struct Cora* co);
void _35clofun2975(struct Cora* co);
void _35clofun2956(struct Cora* co);
void _35clofun2957(struct Cora* co);
void _35clofun2958(struct Cora* co);
void _35clofun2959(struct Cora* co);
void _35clofun2960(struct Cora* co);
void _35clofun2961(struct Cora* co);
void _35clofun2962(struct Cora* co);
void _35clofun2950(struct Cora* co);
void _35clofun2951(struct Cora* co);
void _35clofun2955(struct Cora* co);
void _35clofun2952(struct Cora* co);
void _35clofun2954(struct Cora* co);
void _35clofun2953(struct Cora* co);
void _35clofun2944(struct Cora* co);
void _35clofun2945(struct Cora* co);
void _35clofun2949(struct Cora* co);
void _35clofun2946(struct Cora* co);
void _35clofun2948(struct Cora* co);
void _35clofun2947(struct Cora* co);
void _35clofun2914(struct Cora* co);
void _35clofun2941(struct Cora* co);
void _35clofun2942(struct Cora* co);
void _35clofun2943(struct Cora* co);
void _35clofun2915(struct Cora* co);
void _35clofun2916(struct Cora* co);
void _35clofun2940(struct Cora* co);
void _35clofun2917(struct Cora* co);
void _35clofun2938(struct Cora* co);
void _35clofun2939(struct Cora* co);
void _35clofun2918(struct Cora* co);
void _35clofun2936(struct Cora* co);
void _35clofun2937(struct Cora* co);
void _35clofun2919(struct Cora* co);
void _35clofun2934(struct Cora* co);
void _35clofun2935(struct Cora* co);
void _35clofun2920(struct Cora* co);
void _35clofun2932(struct Cora* co);
void _35clofun2933(struct Cora* co);
void _35clofun2921(struct Cora* co);
void _35clofun2925(struct Cora* co);
void _35clofun2926(struct Cora* co);
void _35clofun2927(struct Cora* co);
void _35clofun2930(struct Cora* co);
void _35clofun2931(struct Cora* co);
void _35clofun2928(struct Cora* co);
void _35clofun2929(struct Cora* co);
void _35clofun2922(struct Cora* co);
void _35clofun2924(struct Cora* co);
void _35clofun2923(struct Cora* co);
void _35clofun2911(struct Cora* co);
void _35clofun2912(struct Cora* co);
void _35clofun2913(struct Cora* co);
void _35clofun2908(struct Cora* co);
void _35clofun2909(struct Cora* co);
void _35clofun2910(struct Cora* co);
void _35clofun2905(struct Cora* co);
void _35clofun2906(struct Cora* co);
void _35clofun2907(struct Cora* co);
void _35clofun2902(struct Cora* co);
void _35clofun2903(struct Cora* co);
void _35clofun2904(struct Cora* co);
void _35clofun2898(struct Cora* co);
void _35clofun2899(struct Cora* co);
void _35clofun2901(struct Cora* co);
void _35clofun2900(struct Cora* co);
void _35clofun2897(struct Cora* co);
void _35clofun2893(struct Cora* co);
void _35clofun2894(struct Cora* co);
void _35clofun2895(struct Cora* co);
void _35clofun2896(struct Cora* co);
void _35clofun2889(struct Cora* co);
void _35clofun2890(struct Cora* co);
void _35clofun2892(struct Cora* co);
void _35clofun2891(struct Cora* co);
void _35clofun2885(struct Cora* co);
void _35clofun2886(struct Cora* co);
void _35clofun2887(struct Cora* co);
void _35clofun2888(struct Cora* co);

void entry(struct Cora* co) {
pushCont(co, 0, _35clofun2883, 0);
coraCall(co, 2, globalRef(intern("import")), makeString1("cora/lib/toc/internal"));
}

void _35clofun2883(struct Cora* co) {
Obj _35val1408 = co->args[1];
pushCont(co, 0, _35clofun2884, 0);
coraCall(co, 2, globalRef(intern("import")), makeString1("cora/lib/io"));
}

void _35clofun2884(struct Cora* co) {
Obj _35val1409 = co->args[1];
Obj _35reg1424 = primSet(intern("cora/lib/toc.assq"), makeNative(0, _35clofun2885, 2, 0));
Obj _35reg1430 = primSet(intern("cora/lib/toc.foldl"), makeNative(0, _35clofun2889, 3, 0));
Obj _35reg1440 = primSet(intern("cora/lib/toc.pos-in-list0"), makeNative(0, _35clofun2893, 3, 0));
Obj _35reg1441 = primSet(intern("cora/lib/toc.index"), makeNative(0, _35clofun2897, 2, 0));
Obj _35reg1448 = primSet(intern("cora/lib/toc.exist-in-env"), makeNative(0, _35clofun2898, 2, 0));
Obj _35reg1449 = primCons(intern("primSet"), Nil);
Obj _35reg1450 = primCons(makeNumber(2), _35reg1449);
Obj _35reg1451 = primCons(intern("set"), _35reg1450);
Obj _35reg1452 = primCons(intern("primCar"), Nil);
Obj _35reg1453 = primCons(makeNumber(1), _35reg1452);
Obj _35reg1454 = primCons(intern("car"), _35reg1453);
Obj _35reg1455 = primCons(intern("primCdr"), Nil);
Obj _35reg1456 = primCons(makeNumber(1), _35reg1455);
Obj _35reg1457 = primCons(intern("cdr"), _35reg1456);
Obj _35reg1458 = primCons(intern("primCons"), Nil);
Obj _35reg1459 = primCons(makeNumber(2), _35reg1458);
Obj _35reg1460 = primCons(intern("cons"), _35reg1459);
Obj _35reg1461 = primCons(intern("primIsCons"), Nil);
Obj _35reg1462 = primCons(makeNumber(1), _35reg1461);
Obj _35reg1463 = primCons(intern("cons?"), _35reg1462);
Obj _35reg1464 = primCons(intern("primAdd"), Nil);
Obj _35reg1465 = primCons(makeNumber(2), _35reg1464);
Obj _35reg1466 = primCons(intern("+"), _35reg1465);
Obj _35reg1467 = primCons(intern("primSub"), Nil);
Obj _35reg1468 = primCons(makeNumber(2), _35reg1467);
Obj _35reg1469 = primCons(intern("-"), _35reg1468);
Obj _35reg1470 = primCons(intern("primMul"), Nil);
Obj _35reg1471 = primCons(makeNumber(2), _35reg1470);
Obj _35reg1472 = primCons(intern("*"), _35reg1471);
Obj _35reg1473 = primCons(intern("primDiv"), Nil);
Obj _35reg1474 = primCons(makeNumber(2), _35reg1473);
Obj _35reg1475 = primCons(intern("/"), _35reg1474);
Obj _35reg1476 = primCons(intern("primEQ"), Nil);
Obj _35reg1477 = primCons(makeNumber(2), _35reg1476);
Obj _35reg1478 = primCons(intern("="), _35reg1477);
Obj _35reg1479 = primCons(intern("primGT"), Nil);
Obj _35reg1480 = primCons(makeNumber(2), _35reg1479);
Obj _35reg1481 = primCons(intern(">"), _35reg1480);
Obj _35reg1482 = primCons(intern("primLT"), Nil);
Obj _35reg1483 = primCons(makeNumber(2), _35reg1482);
Obj _35reg1484 = primCons(intern("<"), _35reg1483);
Obj _35reg1485 = primCons(intern("primGenSym"), Nil);
Obj _35reg1486 = primCons(makeNumber(1), _35reg1485);
Obj _35reg1487 = primCons(intern("gensym"), _35reg1486);
Obj _35reg1488 = primCons(intern("primIsSymbol"), Nil);
Obj _35reg1489 = primCons(makeNumber(1), _35reg1488);
Obj _35reg1490 = primCons(intern("symbol?"), _35reg1489);
Obj _35reg1491 = primCons(intern("primNot"), Nil);
Obj _35reg1492 = primCons(makeNumber(1), _35reg1491);
Obj _35reg1493 = primCons(intern("not"), _35reg1492);
Obj _35reg1494 = primCons(intern("primIsNumber"), Nil);
Obj _35reg1495 = primCons(makeNumber(1), _35reg1494);
Obj _35reg1496 = primCons(intern("integer?"), _35reg1495);
Obj _35reg1497 = primCons(intern("primIsString"), Nil);
Obj _35reg1498 = primCons(makeNumber(1), _35reg1497);
Obj _35reg1499 = primCons(intern("string?"), _35reg1498);
Obj _35reg1500 = primCons(_35reg1499, Nil);
Obj _35reg1501 = primCons(_35reg1496, _35reg1500);
Obj _35reg1502 = primCons(_35reg1493, _35reg1501);
Obj _35reg1503 = primCons(_35reg1490, _35reg1502);
Obj _35reg1504 = primCons(_35reg1487, _35reg1503);
Obj _35reg1505 = primCons(_35reg1484, _35reg1504);
Obj _35reg1506 = primCons(_35reg1481, _35reg1505);
Obj _35reg1507 = primCons(_35reg1478, _35reg1506);
Obj _35reg1508 = primCons(_35reg1475, _35reg1507);
Obj _35reg1509 = primCons(_35reg1472, _35reg1508);
Obj _35reg1510 = primCons(_35reg1469, _35reg1509);
Obj _35reg1511 = primCons(_35reg1466, _35reg1510);
Obj _35reg1512 = primCons(_35reg1463, _35reg1511);
Obj _35reg1513 = primCons(_35reg1460, _35reg1512);
Obj _35reg1514 = primCons(_35reg1457, _35reg1513);
Obj _35reg1515 = primCons(_35reg1454, _35reg1514);
Obj _35reg1516 = primCons(_35reg1451, _35reg1515);
Obj _35reg1517 = primSet(intern("cora/lib/toc.*builtin-prims*"), _35reg1516);
Obj _35reg1521 = primSet(intern("builtin?"), makeNative(0, _35clofun2902, 1, 0));
Obj _35reg1524 = primSet(intern("cora/lib/toc.builtin->name"), makeNative(0, _35clofun2905, 1, 0));
Obj _35reg1527 = primSet(intern("cora/lib/toc.builtin->args"), makeNative(0, _35clofun2908, 1, 0));
Obj _35reg1532 = primSet(intern("cora/lib/toc.temp-list"), makeNative(0, _35clofun2911, 2, 0));
Obj _35reg1668 = primSet(intern("cora/lib/toc.parse"), makeNative(0, _35clofun2914, 2, 0));
Obj _35reg1679 = primSet(intern("cora/lib/toc.union"), makeNative(0, _35clofun2944, 2, 0));
Obj _35reg1690 = primSet(intern("cora/lib/toc.diff"), makeNative(0, _35clofun2950, 2, 0));
Obj _35reg1741 = primSet(intern("cora/lib/toc.convert-protect?"), makeNative(0, _35clofun2956, 1, 0));
Obj _35reg1916 = primSet(intern("cora/lib/toc.free-vars"), makeNative(0, _35clofun2963, 1, 0));
Obj _35reg1989 = primSet(intern("cora/lib/toc.closure-convert"), makeNative(0, _35clofun2986, 2, 0));
Obj _35reg1992 = primSet(intern("cora/lib/toc.id"), makeNative(0, _35clofun3001, 1, 0));
Obj _35reg2129 = primSet(intern("cora/lib/toc.tailify"), makeNative(0, _35clofun3002, 2, 0));
Obj _35reg2176 = primSet(intern("cora/lib/toc.tailify-list"), makeNative(0, _35clofun3020, 3, 0));
Obj _35reg2255 = primSet(intern("cora/lib/toc.explicit-stack"), makeNative(0, _35clofun3030, 2, 0));
Obj _35reg2362 = primSet(intern("cora/lib/toc.collect-lambda"), makeNative(0, _35clofun3048, 3, 0));
Obj _35reg2369 = primSet(intern("cora/lib/toc.collect-lambda-list"), makeNative(0, _35clofun3058, 4, 0));
Obj _35reg2376 = primSet(intern("cora/lib/toc.wrap-var"), makeNative(0, _35clofun3063, 2, 0));
Obj _35reg2627 = primSet(intern("cora/lib/toc.generate-inst"), makeNative(0, _35clofun3065, 3, 0));
Obj _35reg2638 = primSet(intern("cora/lib/toc.generate-call-args"), makeNative(0, _35clofun3137, 4, 0));
Obj _35reg2657 = primSet(intern("cora/lib/toc.generate-cont"), makeNative(0, _35clofun3145, 2, 0));
Obj _35reg2666 = primSet(intern("cora/lib/toc.generate-inst-list-h"), makeNative(0, _35clofun3156, 4, 0));
Obj _35reg2667 = primSet(intern("cora/lib/toc.generate-inst-list"), makeNative(0, _35clofun3162, 3, 0));
Obj _35reg2671 = primSet(intern("cora/lib/toc.code-gen-func-declare"), makeNative(0, _35clofun3163, 2, 0));
Obj _35reg2682 = primSet(intern("cora/lib/toc.generate-call-args-reverse"), makeNative(0, _35clofun3167, 5, 0));
Obj _35reg2739 = primSet(intern("cora/lib/toc.code-gen-toplevel"), makeNative(0, _35clofun3175, 2, 0));
Obj _35reg2740 = primSet(intern("cora/lib/toc.parse-pass"), makeNative(0, _35clofun3182, 1, 0));
Obj _35reg2741 = primSet(intern("cora/lib/toc.closure-convert-pass"), makeNative(0, _35clofun3183, 1, 0));
Obj _35reg2742 = primSet(intern("cora/lib/toc.tailify-pass"), makeNative(0, _35clofun3184, 1, 0));
Obj _35reg2743 = primSet(intern("cora/lib/toc.explicit-stack-pass"), makeNative(0, _35clofun3185, 1, 0));
Obj _35reg2751 = primSet(intern("cora/lib/toc.collect-lambda-pass"), makeNative(0, _35clofun3186, 1, 0));
Obj _35reg2758 = primSet(intern("cora/lib/toc.rewrite-->macro"), makeNative(0, _35clofun3188, 2, 0));
pushCont(co, 0, _35clofun3194, 0);
coraCall(co, 3, globalRef(intern("cora/init.add-to-*macros*")), intern("->"), makeNative(0, _35clofun3191, 1, 0));
}

void _35clofun3194(struct Cora* co) {
Obj _35val2761 = co->args[1];
Obj _35reg2766 = primSet(intern("cora/lib/toc.compile"), makeNative(0, _35clofun3195, 1, 0));
Obj _35reg2772 = primSet(intern("for-each"), makeNative(0, _35clofun3200, 2, 0));
Obj _35reg2779 = primSet(intern("cora/lib/toc.generate-c"), makeNative(0, _35clofun3204, 2, 0));
Obj _35reg2802 = primSet(intern("cora/lib/toc.handle-import-eagerly"), makeNative(0, _35clofun3212, 1, 0));
Obj _35reg2809 = primSet(intern("cora/lib/toc.compile-to-c"), makeNative(0, _35clofun3217, 3, 0));
Obj _35reg2811 = primSet(intern("set"), makeNative(0, _35clofun3224, 2, 0));
Obj _35reg2813 = primSet(intern("car"), makeNative(0, _35clofun3225, 1, 0));
Obj _35reg2815 = primSet(intern("cdr"), makeNative(0, _35clofun3226, 1, 0));
Obj _35reg2817 = primSet(intern("cons"), makeNative(0, _35clofun3227, 2, 0));
Obj _35reg2819 = primSet(intern("cons"), makeNative(0, _35clofun3228, 2, 0));
Obj _35reg2821 = primSet(intern("+"), makeNative(0, _35clofun3229, 2, 0));
Obj _35reg2823 = primSet(intern("-"), makeNative(0, _35clofun3230, 2, 0));
Obj _35reg2825 = primSet(intern("*"), makeNative(0, _35clofun3231, 2, 0));
Obj _35reg2827 = primSet(intern("/"), makeNative(0, _35clofun3232, 2, 0));
Obj _35reg2829 = primSet(intern("="), makeNative(0, _35clofun3233, 2, 0));
Obj _35reg2831 = primSet(intern(">"), makeNative(0, _35clofun3234, 2, 0));
Obj _35reg2833 = primSet(intern("<"), makeNative(0, _35clofun3235, 2, 0));
Obj _35reg2835 = primSet(intern("gensym"), makeNative(0, _35clofun3236, 1, 0));
Obj _35reg2837 = primSet(intern("symbol?"), makeNative(0, _35clofun3237, 1, 0));
Obj _35reg2839 = primSet(intern("not"), makeNative(0, _35clofun3238, 1, 0));
Obj _35reg2841 = primSet(intern("string?"), makeNative(0, _35clofun3239, 1, 0));
Obj _35reg2882 = primSet(intern("cora/lib/toc.eval0"), makeNative(0, _35clofun3240, 1, 0));
coraReturn(co, _35reg2882);
return;
}

void _35clofun3240(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg2842 = primIsSymbol(exp);
if (True == _35reg2842) {
coraCall(co, 2, globalRef(intern("value")), exp);
} else {
pushCont(co, 0, _35clofun3241, 1, exp);
coraCall(co, 2, globalRef(intern("number?")), exp);
}
}

void _35clofun3241(struct Cora* co) {
Obj _35val2843 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
if (True == _35val2843) {
if (True == True) {
coraReturn(co, exp);
return;
} else {
Obj _35reg2844 = primIsCons(exp);
if (True == _35reg2844) {
Obj _35reg2845 = primCar(exp);
Obj _35reg2846 = primEQ(_35reg2845, intern("quote"));
if (True == _35reg2846) {
coraCall(co, 2, globalRef(intern("cadr")), exp);
} else {
Obj _35reg2847 = primCar(exp);
pushCont(co, 0, _35clofun3242, 1, exp);
coraCall(co, 2, globalRef(intern("cora/lib/toc.eval0")), _35reg2847);
}
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
} else {
Obj _35reg2851 = primIsString(exp);
if (True == _35reg2851) {
if (True == True) {
coraReturn(co, exp);
return;
} else {
Obj _35reg2852 = primIsCons(exp);
if (True == _35reg2852) {
Obj _35reg2853 = primCar(exp);
Obj _35reg2854 = primEQ(_35reg2853, intern("quote"));
if (True == _35reg2854) {
coraCall(co, 2, globalRef(intern("cadr")), exp);
} else {
Obj _35reg2855 = primCar(exp);
pushCont(co, 0, _35clofun3244, 1, exp);
coraCall(co, 2, globalRef(intern("cora/lib/toc.eval0")), _35reg2855);
}
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
} else {
pushCont(co, 0, _35clofun3246, 1, exp);
coraCall(co, 2, globalRef(intern("boolean?")), exp);
}
}
}

void _35clofun3246(struct Cora* co) {
Obj _35val2859 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
if (True == _35val2859) {
if (True == True) {
coraReturn(co, exp);
return;
} else {
Obj _35reg2860 = primIsCons(exp);
if (True == _35reg2860) {
Obj _35reg2861 = primCar(exp);
Obj _35reg2862 = primEQ(_35reg2861, intern("quote"));
if (True == _35reg2862) {
coraCall(co, 2, globalRef(intern("cadr")), exp);
} else {
Obj _35reg2863 = primCar(exp);
pushCont(co, 0, _35clofun3247, 1, exp);
coraCall(co, 2, globalRef(intern("cora/lib/toc.eval0")), _35reg2863);
}
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
} else {
pushCont(co, 0, _35clofun3249, 1, exp);
coraCall(co, 2, globalRef(intern("null?")), exp);
}
}

void _35clofun3249(struct Cora* co) {
Obj _35val2867 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
if (True == _35val2867) {
if (True == True) {
coraReturn(co, exp);
return;
} else {
Obj _35reg2868 = primIsCons(exp);
if (True == _35reg2868) {
Obj _35reg2869 = primCar(exp);
Obj _35reg2870 = primEQ(_35reg2869, intern("quote"));
if (True == _35reg2870) {
coraCall(co, 2, globalRef(intern("cadr")), exp);
} else {
Obj _35reg2871 = primCar(exp);
pushCont(co, 0, _35clofun3250, 1, exp);
coraCall(co, 2, globalRef(intern("cora/lib/toc.eval0")), _35reg2871);
}
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
} else {
if (True == False) {
coraReturn(co, exp);
return;
} else {
Obj _35reg2875 = primIsCons(exp);
if (True == _35reg2875) {
Obj _35reg2876 = primCar(exp);
Obj _35reg2877 = primEQ(_35reg2876, intern("quote"));
if (True == _35reg2877) {
coraCall(co, 2, globalRef(intern("cadr")), exp);
} else {
Obj _35reg2878 = primCar(exp);
pushCont(co, 0, _35clofun3252, 1, exp);
coraCall(co, 2, globalRef(intern("cora/lib/toc.eval0")), _35reg2878);
}
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
}
}

void _35clofun3252(struct Cora* co) {
Obj _35val2879 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2880 = primCdr(exp);
pushCont(co, 0, _35clofun3253, 1, _35val2879);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.eval0")), _35reg2880);
}

void _35clofun3253(struct Cora* co) {
Obj _35val2881 = co->args[1];
Obj _35val2879 = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("apply")), _35val2879, _35val2881);
}

void _35clofun3250(struct Cora* co) {
Obj _35val2872 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2873 = primCdr(exp);
pushCont(co, 0, _35clofun3251, 1, _35val2872);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.eval0")), _35reg2873);
}

void _35clofun3251(struct Cora* co) {
Obj _35val2874 = co->args[1];
Obj _35val2872 = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("apply")), _35val2872, _35val2874);
}

void _35clofun3247(struct Cora* co) {
Obj _35val2864 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2865 = primCdr(exp);
pushCont(co, 0, _35clofun3248, 1, _35val2864);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.eval0")), _35reg2865);
}

void _35clofun3248(struct Cora* co) {
Obj _35val2866 = co->args[1];
Obj _35val2864 = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("apply")), _35val2864, _35val2866);
}

void _35clofun3244(struct Cora* co) {
Obj _35val2856 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2857 = primCdr(exp);
pushCont(co, 0, _35clofun3245, 1, _35val2856);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.eval0")), _35reg2857);
}

void _35clofun3245(struct Cora* co) {
Obj _35val2858 = co->args[1];
Obj _35val2856 = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("apply")), _35val2856, _35val2858);
}

void _35clofun3242(struct Cora* co) {
Obj _35val2848 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2849 = primCdr(exp);
pushCont(co, 0, _35clofun3243, 1, _35val2848);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.eval0")), _35reg2849);
}

void _35clofun3243(struct Cora* co) {
Obj _35val2850 = co->args[1];
Obj _35val2848 = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("apply")), _35val2848, _35val2850);
}

void _35clofun3239(struct Cora* co) {
Obj _35tmp1407 = co->args[1];
Obj _35reg2840 = primIsString(_35tmp1407);
coraReturn(co, _35reg2840);
return;
}

void _35clofun3238(struct Cora* co) {
Obj _35tmp1406 = co->args[1];
Obj _35reg2838 = primNot(_35tmp1406);
coraReturn(co, _35reg2838);
return;
}

void _35clofun3237(struct Cora* co) {
Obj _35tmp1405 = co->args[1];
Obj _35reg2836 = primIsSymbol(_35tmp1405);
coraReturn(co, _35reg2836);
return;
}

void _35clofun3236(struct Cora* co) {
Obj _35tmp1404 = co->args[1];
Obj _35reg2834 = primGenSym(_35tmp1404);
coraReturn(co, _35reg2834);
return;
}

void _35clofun3235(struct Cora* co) {
Obj _35tmp1403 = co->args[1];
Obj _35tmp1402 = co->args[2];
Obj _35reg2832 = primLT(_35tmp1403, _35tmp1402);
coraReturn(co, _35reg2832);
return;
}

void _35clofun3234(struct Cora* co) {
Obj _35tmp1401 = co->args[1];
Obj _35tmp1400 = co->args[2];
Obj _35reg2830 = primGT(_35tmp1401, _35tmp1400);
coraReturn(co, _35reg2830);
return;
}

void _35clofun3233(struct Cora* co) {
Obj _35tmp1399 = co->args[1];
Obj _35tmp1398 = co->args[2];
Obj _35reg2828 = primEQ(_35tmp1399, _35tmp1398);
coraReturn(co, _35reg2828);
return;
}

void _35clofun3232(struct Cora* co) {
Obj _35tmp1397 = co->args[1];
Obj _35tmp1396 = co->args[2];
Obj _35reg2826 = primDiv(_35tmp1397, _35tmp1396);
coraReturn(co, _35reg2826);
return;
}

void _35clofun3231(struct Cora* co) {
Obj _35tmp1395 = co->args[1];
Obj _35tmp1394 = co->args[2];
Obj _35reg2824 = primMul(_35tmp1395, _35tmp1394);
coraReturn(co, _35reg2824);
return;
}

void _35clofun3230(struct Cora* co) {
Obj _35tmp1393 = co->args[1];
Obj _35tmp1392 = co->args[2];
Obj _35reg2822 = primSub(_35tmp1393, _35tmp1392);
coraReturn(co, _35reg2822);
return;
}

void _35clofun3229(struct Cora* co) {
Obj _35tmp1391 = co->args[1];
Obj _35tmp1390 = co->args[2];
Obj _35reg2820 = primAdd(_35tmp1391, _35tmp1390);
coraReturn(co, _35reg2820);
return;
}

void _35clofun3228(struct Cora* co) {
Obj _35tmp1389 = co->args[1];
Obj _35tmp1388 = co->args[2];
Obj _35reg2818 = primCons(_35tmp1389, _35tmp1388);
coraReturn(co, _35reg2818);
return;
}

void _35clofun3227(struct Cora* co) {
Obj _35tmp1387 = co->args[1];
Obj _35tmp1386 = co->args[2];
Obj _35reg2816 = primCons(_35tmp1387, _35tmp1386);
coraReturn(co, _35reg2816);
return;
}

void _35clofun3226(struct Cora* co) {
Obj _35tmp1385 = co->args[1];
Obj _35reg2814 = primCdr(_35tmp1385);
coraReturn(co, _35reg2814);
return;
}

void _35clofun3225(struct Cora* co) {
Obj _35tmp1384 = co->args[1];
Obj _35reg2812 = primCar(_35tmp1384);
coraReturn(co, _35reg2812);
return;
}

void _35clofun3224(struct Cora* co) {
Obj _35tmp1383 = co->args[1];
Obj _35tmp1382 = co->args[2];
Obj _35reg2810 = primSet(_35tmp1383, _35tmp1382);
coraReturn(co, _35reg2810);
return;
}

void _35clofun3217(struct Cora* co) {
Obj from = co->args[1];
Obj to = co->args[2];
Obj pkg_45str = co->args[3];
pushCont(co, 0, _35clofun3218, 1, to);
coraCall(co, 3, globalRef(intern("read-file-as-sexp")), from, pkg_45str);
}

void _35clofun3218(struct Cora* co) {
Obj _35val2803 = co->args[1];
Obj to = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj sexp = _35val2803;
pushCont(co, 0, _35clofun3219, 2, sexp, to);
coraCall(co, 2, globalRef(intern("cora/lib/toc.handle-import-eagerly")), sexp);
}

void _35clofun3219(struct Cora* co) {
Obj _35val2804 = co->args[1];
Obj sexp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj to = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3220, 1, to);
coraCall(co, 2, globalRef(intern("macroexpand")), sexp);
}

void _35clofun3220(struct Cora* co) {
Obj _35val2805 = co->args[1];
Obj to = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj input = _35val2805;
pushCont(co, 0, _35clofun3221, 1, to);
coraCall(co, 2, globalRef(intern("cora/lib/toc.compile")), input);
}

void _35clofun3221(struct Cora* co) {
Obj _35val2806 = co->args[1];
Obj to = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj bc = _35val2806;
pushCont(co, 0, _35clofun3222, 1, bc);
coraCall(co, 2, globalRef(intern("cora/lib/io.open-output-file")), to);
}

void _35clofun3222(struct Cora* co) {
Obj _35val2807 = co->args[1];
Obj bc = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj stream = _35val2807;
pushCont(co, 0, _35clofun3223, 1, stream);
coraCall(co, 3, globalRef(intern("cora/lib/toc.generate-c")), stream, bc);
}

void _35clofun3223(struct Cora* co) {
Obj _35val2808 = co->args[1];
Obj stream = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 2, globalRef(intern("cora/lib/io.close-output-file")), stream);
}

void _35clofun3212(struct Cora* co) {
Obj _35p1378 = co->args[1];
Obj _35cc1379 = makeNative(0, _35clofun3213, 0, 1, _35p1378);
Obj _35reg2798 = primIsCons(_35p1378);
if (True == _35reg2798) {
Obj _35reg2799 = primCar(_35p1378);
Obj _35reg2800 = primEQ(intern("begin"), _35reg2799);
if (True == _35reg2800) {
Obj _35reg2801 = primCdr(_35p1378);
Obj remain = _35reg2801;
coraCall(co, 2, globalRef(intern("cora/lib/toc.handle-import-eagerly")), remain);
} else {
coraCall(co, 1, _35cc1379);
}
} else {
coraCall(co, 1, _35cc1379);
}
}

void _35clofun3213(struct Cora* co) {
Obj _35cc1380 = makeNative(0, _35clofun3214, 0, 1, closureRef(co, 0));
Obj _35reg2780 = primIsCons(closureRef(co, 0));
if (True == _35reg2780) {
Obj _35reg2781 = primCar(closureRef(co, 0));
Obj _35reg2782 = primIsCons(_35reg2781);
if (True == _35reg2782) {
Obj _35reg2783 = primCar(closureRef(co, 0));
Obj _35reg2784 = primCar(_35reg2783);
Obj _35reg2785 = primEQ(intern("import"), _35reg2784);
if (True == _35reg2785) {
Obj _35reg2786 = primCar(closureRef(co, 0));
Obj _35reg2787 = primCdr(_35reg2786);
Obj _35reg2788 = primIsCons(_35reg2787);
if (True == _35reg2788) {
Obj _35reg2789 = primCar(closureRef(co, 0));
Obj _35reg2790 = primCdr(_35reg2789);
Obj _35reg2791 = primCar(_35reg2790);
Obj pkg = _35reg2791;
Obj _35reg2792 = primCar(closureRef(co, 0));
Obj _35reg2793 = primCdr(_35reg2792);
Obj _35reg2794 = primCdr(_35reg2793);
Obj _35reg2795 = primEQ(Nil, _35reg2794);
if (True == _35reg2795) {
Obj _35reg2796 = primCdr(closureRef(co, 0));
Obj remain = _35reg2796;
pushCont(co, 0, _35clofun3216, 1, remain);
coraCall(co, 2, globalRef(intern("import")), pkg);
} else {
coraCall(co, 1, _35cc1380);
}
} else {
coraCall(co, 1, _35cc1380);
}
} else {
coraCall(co, 1, _35cc1380);
}
} else {
coraCall(co, 1, _35cc1380);
}
} else {
coraCall(co, 1, _35cc1380);
}
}

void _35clofun3216(struct Cora* co) {
Obj _35val2797 = co->args[1];
Obj remain = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 2, globalRef(intern("cora/lib/toc.handle-import-eagerly")), remain);
}

void _35clofun3214(struct Cora* co) {
Obj _35cc1381 = makeNative(0, _35clofun3215, 0, 0);
Obj __ = closureRef(co, 0);
coraReturn(co, Nil);
return;
}

void _35clofun3215(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3204(struct Cora* co) {
Obj to = co->args[1];
Obj bc = co->args[2];
pushCont(co, 0, _35clofun3205, 2, to, bc);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), to, makeString1("#include \"types.h\"\n"));
}

void _35clofun3205(struct Cora* co) {
Obj _35val2773 = co->args[1];
Obj to = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj bc = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3206, 2, to, bc);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), to, makeString1("#include \"runtime.h\"\n\n"));
}

void _35clofun3206(struct Cora* co) {
Obj _35val2774 = co->args[1];
Obj to = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj bc = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3209, 2, to, bc);
coraCall(co, 3, globalRef(intern("for-each")), makeNative(0, _35clofun3207, 1, 1, to), bc);
}

void _35clofun3209(struct Cora* co) {
Obj _35val2777 = co->args[1];
Obj to = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj bc = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3210, 2, to, bc);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), to, makeString1("\n"));
}

void _35clofun3210(struct Cora* co) {
Obj _35val2778 = co->args[1];
Obj to = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj bc = co->ctx.stk.stack[co->ctx.stk.base + 1];
coraCall(co, 3, globalRef(intern("for-each")), makeNative(0, _35clofun3211, 1, 1, to), bc);
}

void _35clofun3211(struct Cora* co) {
Obj x = co->args[1];
coraCall(co, 3, globalRef(intern("cora/lib/toc.code-gen-toplevel")), closureRef(co, 0), x);
}

void _35clofun3207(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg2775 = primCar(x);
pushCont(co, 0, _35clofun3208, 0);
coraCall(co, 3, globalRef(intern("cora/lib/toc.code-gen-func-declare")), closureRef(co, 0), _35reg2775);
}

void _35clofun3208(struct Cora* co) {
Obj _35val2776 = co->args[1];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), closureRef(co, 0), makeString1(";\n"));
}

void _35clofun3200(struct Cora* co) {
Obj _35p1374 = co->args[1];
Obj _35p1375 = co->args[2];
Obj _35cc1376 = makeNative(0, _35clofun3201, 0, 2, _35p1374, _35p1375);
Obj fn = _35p1374;
Obj _35reg2771 = primEQ(Nil, _35p1375);
if (True == _35reg2771) {
coraReturn(co, Nil);
return;
} else {
coraCall(co, 1, _35cc1376);
}
}

void _35clofun3201(struct Cora* co) {
Obj _35cc1377 = makeNative(0, _35clofun3202, 0, 0);
Obj fn = closureRef(co, 0);
Obj _35reg2767 = primIsCons(closureRef(co, 1));
if (True == _35reg2767) {
Obj _35reg2768 = primCar(closureRef(co, 1));
Obj x = _35reg2768;
Obj _35reg2769 = primCdr(closureRef(co, 1));
Obj y = _35reg2769;
pushCont(co, 0, _35clofun3203, 2, fn, y);
coraCall(co, 2, fn, x);
} else {
coraCall(co, 1, _35cc1377);
}
}

void _35clofun3203(struct Cora* co) {
Obj _35val2770 = co->args[1];
Obj fn = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj y = co->ctx.stk.stack[co->ctx.stk.base + 1];
coraCall(co, 3, globalRef(intern("for-each")), fn, y);
}

void _35clofun3202(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3195(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, 0, _35clofun3196, 0);
coraCall(co, 2, globalRef(intern("cora/lib/toc.parse-pass")), exp);
}

void _35clofun3196(struct Cora* co) {
Obj _35val2762 = co->args[1];
pushCont(co, 0, _35clofun3197, 0);
coraCall(co, 2, globalRef(intern("cora/lib/toc.closure-convert-pass")), _35val2762);
}

void _35clofun3197(struct Cora* co) {
Obj _35val2763 = co->args[1];
pushCont(co, 0, _35clofun3198, 0);
coraCall(co, 2, globalRef(intern("cora/lib/toc.tailify-pass")), _35val2763);
}

void _35clofun3198(struct Cora* co) {
Obj _35val2764 = co->args[1];
pushCont(co, 0, _35clofun3199, 0);
coraCall(co, 2, globalRef(intern("cora/lib/toc.explicit-stack-pass")), _35val2764);
}

void _35clofun3199(struct Cora* co) {
Obj _35val2765 = co->args[1];
coraCall(co, 2, globalRef(intern("cora/lib/toc.collect-lambda-pass")), _35val2765);
}

void _35clofun3191(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, 0, _35clofun3192, 1, exp);
coraCall(co, 2, globalRef(intern("cadr")), exp);
}

void _35clofun3192(struct Cora* co) {
Obj _35val2759 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj obj = _35val2759;
pushCont(co, 0, _35clofun3193, 1, obj);
coraCall(co, 2, globalRef(intern("cddr")), exp);
}

void _35clofun3193(struct Cora* co) {
Obj _35val2760 = co->args[1];
Obj obj = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj fns = _35val2760;
coraCall(co, 3, globalRef(intern("cora/lib/toc.rewrite-->macro")), obj, fns);
}

void _35clofun3188(struct Cora* co) {
Obj _35p1370 = co->args[1];
Obj _35p1371 = co->args[2];
Obj _35cc1372 = makeNative(0, _35clofun3189, 0, 2, _35p1370, _35p1371);
Obj obj = _35p1370;
Obj _35reg2757 = primEQ(Nil, _35p1371);
if (True == _35reg2757) {
coraReturn(co, obj);
return;
} else {
coraCall(co, 1, _35cc1372);
}
}

void _35clofun3189(struct Cora* co) {
Obj _35cc1373 = makeNative(0, _35clofun3190, 0, 0);
Obj obj = closureRef(co, 0);
Obj _35reg2752 = primIsCons(closureRef(co, 1));
if (True == _35reg2752) {
Obj _35reg2753 = primCar(closureRef(co, 1));
Obj hd = _35reg2753;
Obj _35reg2754 = primCdr(closureRef(co, 1));
Obj more = _35reg2754;
Obj _35reg2755 = primCons(obj, Nil);
Obj _35reg2756 = primCons(hd, _35reg2755);
coraCall(co, 3, globalRef(intern("cora/lib/toc.rewrite-->macro")), _35reg2756, more);
} else {
coraCall(co, 1, _35cc1373);
}
}

void _35clofun3190(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3186(struct Cora* co) {
Obj exp = co->args[1];
coraCall(co, 4, globalRef(intern("cora/lib/toc.collect-lambda")), Nil, exp, makeNative(0, _35clofun3187, 2, 0));
}

void _35clofun3187(struct Cora* co) {
Obj ls = co->args[1];
Obj e1 = co->args[2];
Obj _35reg2744 = primCons(e1, Nil);
Obj _35reg2745 = primCons(Nil, _35reg2744);
Obj _35reg2746 = primCons(Nil, _35reg2745);
Obj _35reg2747 = primCons(intern("lambda"), _35reg2746);
Obj _35reg2748 = primCons(_35reg2747, Nil);
Obj _35reg2749 = primCons(intern("entry"), _35reg2748);
Obj _35reg2750 = primCons(_35reg2749, ls);
coraReturn(co, _35reg2750);
return;
}

void _35clofun3185(struct Cora* co) {
Obj exp = co->args[1];
coraCall(co, 3, globalRef(intern("cora/lib/toc.explicit-stack")), Nil, exp);
}

void _35clofun3184(struct Cora* co) {
Obj exp = co->args[1];
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), exp, globalRef(intern("cora/lib/toc.id")));
}

void _35clofun3183(struct Cora* co) {
Obj exp = co->args[1];
coraCall(co, 3, globalRef(intern("cora/lib/toc.closure-convert")), Nil, exp);
}

void _35clofun3182(struct Cora* co) {
Obj exp = co->args[1];
coraCall(co, 3, globalRef(intern("cora/lib/toc.parse")), Nil, exp);
}

void _35clofun3175(struct Cora* co) {
Obj _35p1367 = co->args[1];
Obj _35p1368 = co->args[2];
Obj _35cc1369 = makeNative(0, _35clofun3176, 0, 0);
Obj w = _35p1367;
Obj _35reg2683 = primIsCons(_35p1368);
if (True == _35reg2683) {
Obj _35reg2684 = primCar(_35p1368);
Obj name = _35reg2684;
Obj _35reg2685 = primCdr(_35p1368);
Obj _35reg2686 = primIsCons(_35reg2685);
if (True == _35reg2686) {
Obj _35reg2687 = primCdr(_35p1368);
Obj _35reg2688 = primCar(_35reg2687);
Obj _35reg2689 = primIsCons(_35reg2688);
if (True == _35reg2689) {
Obj _35reg2690 = primCdr(_35p1368);
Obj _35reg2691 = primCar(_35reg2690);
Obj _35reg2692 = primCar(_35reg2691);
Obj _35reg2693 = primEQ(intern("lambda"), _35reg2692);
if (True == _35reg2693) {
Obj _35reg2694 = primCdr(_35p1368);
Obj _35reg2695 = primCar(_35reg2694);
Obj _35reg2696 = primCdr(_35reg2695);
Obj _35reg2697 = primIsCons(_35reg2696);
if (True == _35reg2697) {
Obj _35reg2698 = primCdr(_35p1368);
Obj _35reg2699 = primCar(_35reg2698);
Obj _35reg2700 = primCdr(_35reg2699);
Obj _35reg2701 = primCar(_35reg2700);
Obj params = _35reg2701;
Obj _35reg2702 = primCdr(_35p1368);
Obj _35reg2703 = primCar(_35reg2702);
Obj _35reg2704 = primCdr(_35reg2703);
Obj _35reg2705 = primCdr(_35reg2704);
Obj _35reg2706 = primIsCons(_35reg2705);
if (True == _35reg2706) {
Obj _35reg2707 = primCdr(_35p1368);
Obj _35reg2708 = primCar(_35reg2707);
Obj _35reg2709 = primCdr(_35reg2708);
Obj _35reg2710 = primCdr(_35reg2709);
Obj _35reg2711 = primCar(_35reg2710);
Obj actives = _35reg2711;
Obj _35reg2712 = primCdr(_35p1368);
Obj _35reg2713 = primCar(_35reg2712);
Obj _35reg2714 = primCdr(_35reg2713);
Obj _35reg2715 = primCdr(_35reg2714);
Obj _35reg2716 = primCdr(_35reg2715);
Obj _35reg2717 = primIsCons(_35reg2716);
if (True == _35reg2717) {
Obj _35reg2718 = primCdr(_35p1368);
Obj _35reg2719 = primCar(_35reg2718);
Obj _35reg2720 = primCdr(_35reg2719);
Obj _35reg2721 = primCdr(_35reg2720);
Obj _35reg2722 = primCdr(_35reg2721);
Obj _35reg2723 = primCar(_35reg2722);
Obj body = _35reg2723;
Obj _35reg2724 = primCdr(_35p1368);
Obj _35reg2725 = primCar(_35reg2724);
Obj _35reg2726 = primCdr(_35reg2725);
Obj _35reg2727 = primCdr(_35reg2726);
Obj _35reg2728 = primCdr(_35reg2727);
Obj _35reg2729 = primCdr(_35reg2728);
Obj _35reg2730 = primEQ(Nil, _35reg2729);
if (True == _35reg2730) {
Obj _35reg2731 = primCdr(_35p1368);
Obj _35reg2732 = primCdr(_35reg2731);
Obj _35reg2733 = primEQ(Nil, _35reg2732);
if (True == _35reg2733) {
pushCont(co, 0, _35clofun3177, 4, actives, params, body, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc.code-gen-func-declare")), w, name);
} else {
coraCall(co, 1, _35cc1369);
}
} else {
coraCall(co, 1, _35cc1369);
}
} else {
coraCall(co, 1, _35cc1369);
}
} else {
coraCall(co, 1, _35cc1369);
}
} else {
coraCall(co, 1, _35cc1369);
}
} else {
coraCall(co, 1, _35cc1369);
}
} else {
coraCall(co, 1, _35cc1369);
}
} else {
coraCall(co, 1, _35cc1369);
}
} else {
coraCall(co, 1, _35cc1369);
}
}

void _35clofun3177(struct Cora* co) {
Obj _35val2734 = co->args[1];
Obj actives = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj params = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3178, 4, actives, params, body, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(" {\n"));
}

void _35clofun3178(struct Cora* co) {
Obj _35val2735 = co->args[1];
Obj actives = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj params = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3179, 4, actives, params, body, w);
coraCall(co, 6, globalRef(intern("cora/lib/toc.generate-call-args-reverse")), Nil, w, makeString1(" = co->args["), makeNumber(1), params);
}

void _35clofun3179(struct Cora* co) {
Obj _35val2736 = co->args[1];
Obj actives = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj params = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3180, 3, params, body, w);
coraCall(co, 6, globalRef(intern("cora/lib/toc.generate-call-args-reverse")), Nil, w, makeString1(" = co->ctx.stk.stack[co->ctx.stk.base + "), makeNumber(0), actives);
}

void _35clofun3180(struct Cora* co) {
Obj _35val2737 = co->args[1];
Obj params = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3181, 1, w);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), params, w, body);
}

void _35clofun3181(struct Cora* co) {
Obj _35val2738 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("}\n\n"));
}

void _35clofun3176(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3167(struct Cora* co) {
Obj _35p1360 = co->args[1];
Obj _35p1361 = co->args[2];
Obj _35p1362 = co->args[3];
Obj _35p1363 = co->args[4];
Obj _35p1364 = co->args[5];
Obj _35cc1365 = makeNative(0, _35clofun3168, 0, 5, _35p1360, _35p1361, _35p1362, _35p1363, _35p1364);
Obj env = _35p1360;
Obj w = _35p1361;
Obj dest_45str = _35p1362;
Obj idx = _35p1363;
Obj _35reg2681 = primEQ(Nil, _35p1364);
if (True == _35reg2681) {
coraReturn(co, Nil);
return;
} else {
coraCall(co, 1, _35cc1365);
}
}

void _35clofun3168(struct Cora* co) {
Obj _35cc1366 = makeNative(0, _35clofun3169, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj dest_45str = closureRef(co, 2);
Obj idx = closureRef(co, 3);
Obj _35reg2672 = primIsCons(closureRef(co, 4));
if (True == _35reg2672) {
Obj _35reg2673 = primCar(closureRef(co, 4));
Obj a = _35reg2673;
Obj _35reg2674 = primCdr(closureRef(co, 4));
Obj b = _35reg2674;
pushCont(co, 0, _35clofun3170, 6, a, idx, env, w, dest_45str, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("Obj "));
} else {
coraCall(co, 1, _35cc1366);
}
}

void _35clofun3170(struct Cora* co) {
Obj _35val2675 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj dest_45str = co->ctx.stk.stack[co->ctx.stk.base + 4];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 5];
pushCont(co, 0, _35clofun3171, 5, idx, env, w, dest_45str, b);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, a);
}

void _35clofun3171(struct Cora* co) {
Obj _35val2676 = co->args[1];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj dest_45str = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3172, 5, idx, env, w, dest_45str, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, dest_45str);
}

void _35clofun3172(struct Cora* co) {
Obj _35val2677 = co->args[1];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj dest_45str = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3173, 5, idx, env, w, dest_45str, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, idx);
}

void _35clofun3173(struct Cora* co) {
Obj _35val2678 = co->args[1];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj dest_45str = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3174, 5, idx, env, w, dest_45str, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("];\n"));
}

void _35clofun3174(struct Cora* co) {
Obj _35val2679 = co->args[1];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj dest_45str = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 4];
Obj _35reg2680 = primAdd(idx, makeNumber(1));
coraCall(co, 6, globalRef(intern("cora/lib/toc.generate-call-args-reverse")), env, w, dest_45str, _35reg2680, b);
}

void _35clofun3169(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3163(struct Cora* co) {
Obj w = co->args[1];
Obj name = co->args[2];
pushCont(co, 0, _35clofun3164, 2, name, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("void "));
}

void _35clofun3164(struct Cora* co) {
Obj _35val2668 = co->args[1];
Obj name = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3165, 1, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-sym")), w, name);
}

void _35clofun3165(struct Cora* co) {
Obj _35val2669 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
pushCont(co, 0, _35clofun3166, 1, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("(struct Cora* co"));
}

void _35clofun3166(struct Cora* co) {
Obj _35val2670 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(")"));
}

void _35clofun3162(struct Cora* co) {
Obj env = co->args[1];
Obj w = co->args[2];
Obj l = co->args[3];
coraCall(co, 5, globalRef(intern("cora/lib/toc.generate-inst-list-h")), env, globalRef(intern("cora/lib/toc.generate-inst")), w, l);
}

void _35clofun3156(struct Cora* co) {
Obj _35p1354 = co->args[1];
Obj _35p1355 = co->args[2];
Obj _35p1356 = co->args[3];
Obj _35p1357 = co->args[4];
Obj _35cc1358 = makeNative(0, _35clofun3157, 0, 4, _35p1354, _35p1355, _35p1356, _35p1357);
Obj env = _35p1354;
Obj fn = _35p1355;
Obj w = _35p1356;
Obj _35reg2665 = primEQ(Nil, _35p1357);
if (True == _35reg2665) {
coraReturn(co, Nil);
return;
} else {
coraCall(co, 1, _35cc1358);
}
}

void _35clofun3157(struct Cora* co) {
Obj _35cc1359 = makeNative(0, _35clofun3158, 0, 0);
Obj env = closureRef(co, 0);
Obj fn = closureRef(co, 1);
Obj w = closureRef(co, 2);
Obj _35reg2658 = primIsCons(closureRef(co, 3));
if (True == _35reg2658) {
Obj _35reg2659 = primCar(closureRef(co, 3));
Obj a = _35reg2659;
Obj _35reg2660 = primCdr(closureRef(co, 3));
Obj b = _35reg2660;
pushCont(co, 0, _35clofun3159, 4, env, fn, w, b);
coraCall(co, 4, fn, env, w, a);
} else {
coraCall(co, 1, _35cc1359);
}
}

void _35clofun3159(struct Cora* co) {
Obj _35val2661 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj fn = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3160, 4, env, fn, w, b);
coraCall(co, 2, globalRef(intern("null?")), b);
}

void _35clofun3160(struct Cora* co) {
Obj _35val2662 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj fn = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj _35reg2663 = primNot(_35val2662);
if (True == _35reg2663) {
pushCont(co, 0, _35clofun3161, 4, env, fn, w, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(", "));
} else {
Nil;
coraCall(co, 5, globalRef(intern("cora/lib/toc.generate-inst-list-h")), env, fn, w, b);
}
}

void _35clofun3161(struct Cora* co) {
Obj _35val2664 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj fn = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 3];
coraCall(co, 5, globalRef(intern("cora/lib/toc.generate-inst-list-h")), env, fn, w, b);
}

void _35clofun3158(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3145(struct Cora* co) {
Obj _35p1351 = co->args[1];
Obj _35p1352 = co->args[2];
Obj _35cc1353 = makeNative(0, _35clofun3146, 0, 0);
Obj w = _35p1351;
Obj _35reg2639 = primIsCons(_35p1352);
if (True == _35reg2639) {
Obj _35reg2640 = primCar(_35p1352);
Obj _35reg2641 = primEQ(intern("%continuation"), _35reg2640);
if (True == _35reg2641) {
Obj _35reg2642 = primCdr(_35p1352);
Obj _35reg2643 = primIsCons(_35reg2642);
if (True == _35reg2643) {
Obj _35reg2644 = primCdr(_35p1352);
Obj _35reg2645 = primCar(_35reg2644);
Obj label = _35reg2645;
Obj _35reg2646 = primCdr(_35p1352);
Obj _35reg2647 = primCdr(_35reg2646);
Obj stacks = _35reg2647;
pushCont(co, 0, _35clofun3147, 3, label, stacks, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("pushCont(co, 0, "));
} else {
coraCall(co, 1, _35cc1353);
}
} else {
coraCall(co, 1, _35cc1353);
}
} else {
coraCall(co, 1, _35cc1353);
}
}

void _35clofun3147(struct Cora* co) {
Obj _35val2648 = co->args[1];
Obj label = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj stacks = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3148, 2, stacks, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-sym")), w, label);
}

void _35clofun3148(struct Cora* co) {
Obj _35val2649 = co->args[1];
Obj stacks = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3149, 2, stacks, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(", "));
}

void _35clofun3149(struct Cora* co) {
Obj _35val2650 = co->args[1];
Obj stacks = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3150, 2, stacks, w);
coraCall(co, 2, globalRef(intern("length")), stacks);
}

void _35clofun3150(struct Cora* co) {
Obj _35val2651 = co->args[1];
Obj stacks = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3151, 2, stacks, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, _35val2651);
}

void _35clofun3151(struct Cora* co) {
Obj _35val2652 = co->args[1];
Obj stacks = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3152, 2, stacks, w);
coraCall(co, 2, globalRef(intern("null?")), stacks);
}

void _35clofun3152(struct Cora* co) {
Obj _35val2653 = co->args[1];
Obj stacks = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2654 = primNot(_35val2653);
if (True == _35reg2654) {
pushCont(co, 0, _35clofun3155, 1, w);
coraCall(co, 3, globalRef(intern("for-each")), makeNative(0, _35clofun3153, 1, 1, w), stacks);
} else {
Nil;
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(");\n"));
}
}

void _35clofun3155(struct Cora* co) {
Obj _35val2656 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(");\n"));
}

void _35clofun3153(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, 0, _35clofun3154, 1, x);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), closureRef(co, 0), makeString1(", "));
}

void _35clofun3154(struct Cora* co) {
Obj _35val2655 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), Nil, closureRef(co, 0), x);
}

void _35clofun3146(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3137(struct Cora* co) {
Obj _35p1345 = co->args[1];
Obj _35p1346 = co->args[2];
Obj _35p1347 = co->args[3];
Obj _35p1348 = co->args[4];
Obj _35cc1349 = makeNative(0, _35clofun3138, 0, 4, _35p1345, _35p1346, _35p1347, _35p1348);
Obj env = _35p1345;
Obj w = _35p1346;
Obj idx = _35p1347;
Obj _35reg2637 = primEQ(Nil, _35p1348);
if (True == _35reg2637) {
coraReturn(co, Nil);
return;
} else {
coraCall(co, 1, _35cc1349);
}
}

void _35clofun3138(struct Cora* co) {
Obj _35cc1350 = makeNative(0, _35clofun3139, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj idx = closureRef(co, 2);
Obj _35reg2628 = primIsCons(closureRef(co, 3));
if (True == _35reg2628) {
Obj _35reg2629 = primCar(closureRef(co, 3));
Obj a = _35reg2629;
Obj _35reg2630 = primCdr(closureRef(co, 3));
Obj b = _35reg2630;
pushCont(co, 0, _35clofun3140, 5, a, idx, env, w, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("co->args["));
} else {
coraCall(co, 1, _35cc1350);
}
}

void _35clofun3140(struct Cora* co) {
Obj _35val2631 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3141, 5, a, idx, env, w, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, idx);
}

void _35clofun3141(struct Cora* co) {
Obj _35val2632 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3142, 5, a, idx, env, w, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("] = "));
}

void _35clofun3142(struct Cora* co) {
Obj _35val2633 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3143, 4, idx, env, w, b);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, a);
}

void _35clofun3143(struct Cora* co) {
Obj _35val2634 = co->args[1];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3144, 4, idx, env, w, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(";\n"));
}

void _35clofun3144(struct Cora* co) {
Obj _35val2635 = co->args[1];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj _35reg2636 = primAdd(idx, makeNumber(1));
coraCall(co, 5, globalRef(intern("cora/lib/toc.generate-call-args")), env, w, _35reg2636, b);
}

void _35clofun3139(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3065(struct Cora* co) {
Obj _35p1328 = co->args[1];
Obj _35p1329 = co->args[2];
Obj _35p1330 = co->args[3];
Obj _35cc1331 = makeNative(0, _35clofun3066, 0, 3, _35p1328, _35p1329, _35p1330);
Obj env = _35p1328;
Obj w = _35p1329;
Obj x = _35p1330;
Obj _35reg2626 = primIsSymbol(x);
if (True == _35reg2626) {
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-sym")), w, x);
} else {
coraCall(co, 1, _35cc1331);
}
}

void _35clofun3066(struct Cora* co) {
Obj _35cc1332 = makeNative(0, _35clofun3067, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2613 = primIsCons(closureRef(co, 2));
if (True == _35reg2613) {
Obj _35reg2614 = primCar(closureRef(co, 2));
Obj _35reg2615 = primEQ(intern("%global"), _35reg2614);
if (True == _35reg2615) {
Obj _35reg2616 = primCdr(closureRef(co, 2));
Obj _35reg2617 = primIsCons(_35reg2616);
if (True == _35reg2617) {
Obj _35reg2618 = primCdr(closureRef(co, 2));
Obj _35reg2619 = primCar(_35reg2618);
Obj x = _35reg2619;
Obj _35reg2620 = primCdr(closureRef(co, 2));
Obj _35reg2621 = primCdr(_35reg2620);
Obj _35reg2622 = primEQ(Nil, _35reg2621);
if (True == _35reg2622) {
pushCont(co, 0, _35clofun3134, 2, x, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("globalRef(intern(\""));
} else {
coraCall(co, 1, _35cc1332);
}
} else {
coraCall(co, 1, _35cc1332);
}
} else {
coraCall(co, 1, _35cc1332);
}
} else {
coraCall(co, 1, _35cc1332);
}
}

void _35clofun3134(struct Cora* co) {
Obj _35val2623 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3135, 1, w);
coraCall(co, 2, globalRef(intern("symbol->string")), x);
}

void _35clofun3135(struct Cora* co) {
Obj _35val2624 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
pushCont(co, 0, _35clofun3136, 1, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, _35val2624);
}

void _35clofun3136(struct Cora* co) {
Obj _35val2625 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("\"))"));
}

void _35clofun3067(struct Cora* co) {
Obj _35cc1333 = makeNative(0, _35clofun3068, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2601 = primIsCons(closureRef(co, 2));
if (True == _35reg2601) {
Obj _35reg2602 = primCar(closureRef(co, 2));
Obj _35reg2603 = primEQ(intern("%closure-ref"), _35reg2602);
if (True == _35reg2603) {
Obj _35reg2604 = primCdr(closureRef(co, 2));
Obj _35reg2605 = primIsCons(_35reg2604);
if (True == _35reg2605) {
Obj _35reg2606 = primCdr(closureRef(co, 2));
Obj _35reg2607 = primCar(_35reg2606);
Obj idx = _35reg2607;
Obj _35reg2608 = primCdr(closureRef(co, 2));
Obj _35reg2609 = primCdr(_35reg2608);
Obj _35reg2610 = primEQ(Nil, _35reg2609);
if (True == _35reg2610) {
pushCont(co, 0, _35clofun3132, 2, idx, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("closureRef(co, "));
} else {
coraCall(co, 1, _35cc1333);
}
} else {
coraCall(co, 1, _35cc1333);
}
} else {
coraCall(co, 1, _35cc1333);
}
} else {
coraCall(co, 1, _35cc1333);
}
}

void _35clofun3132(struct Cora* co) {
Obj _35val2611 = co->args[1];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3133, 1, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, idx);
}

void _35clofun3133(struct Cora* co) {
Obj _35val2612 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(")"));
}

void _35clofun3068(struct Cora* co) {
Obj _35cc1334 = makeNative(0, _35clofun3069, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2589 = primIsCons(closureRef(co, 2));
if (True == _35reg2589) {
Obj _35reg2590 = primCar(closureRef(co, 2));
Obj _35reg2591 = primEQ(intern("%stack-ref"), _35reg2590);
if (True == _35reg2591) {
Obj _35reg2592 = primCdr(closureRef(co, 2));
Obj _35reg2593 = primIsCons(_35reg2592);
if (True == _35reg2593) {
Obj _35reg2594 = primCdr(closureRef(co, 2));
Obj _35reg2595 = primCar(_35reg2594);
Obj idx = _35reg2595;
Obj _35reg2596 = primCdr(closureRef(co, 2));
Obj _35reg2597 = primCdr(_35reg2596);
Obj _35reg2598 = primEQ(Nil, _35reg2597);
if (True == _35reg2598) {
pushCont(co, 0, _35clofun3130, 2, idx, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("stackRef(co, "));
} else {
coraCall(co, 1, _35cc1334);
}
} else {
coraCall(co, 1, _35cc1334);
}
} else {
coraCall(co, 1, _35cc1334);
}
} else {
coraCall(co, 1, _35cc1334);
}
}

void _35clofun3130(struct Cora* co) {
Obj _35val2599 = co->args[1];
Obj idx = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3131, 1, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, idx);
}

void _35clofun3131(struct Cora* co) {
Obj _35val2600 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(")"));
}

void _35clofun3069(struct Cora* co) {
Obj _35cc1335 = makeNative(0, _35clofun3070, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2565 = primIsCons(closureRef(co, 2));
if (True == _35reg2565) {
Obj _35reg2566 = primCar(closureRef(co, 2));
Obj _35reg2567 = primEQ(intern("%const"), _35reg2566);
if (True == _35reg2567) {
Obj _35reg2568 = primCdr(closureRef(co, 2));
Obj _35reg2569 = primIsCons(_35reg2568);
if (True == _35reg2569) {
Obj _35reg2570 = primCdr(closureRef(co, 2));
Obj _35reg2571 = primCar(_35reg2570);
Obj x = _35reg2571;
Obj _35reg2572 = primCdr(closureRef(co, 2));
Obj _35reg2573 = primCdr(_35reg2572);
Obj _35reg2574 = primEQ(Nil, _35reg2573);
if (True == _35reg2574) {
Obj _35reg2575 = primIsSymbol(x);
if (True == _35reg2575) {
pushCont(co, 0, _35clofun3121, 2, x, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("intern(\""));
} else {
pushCont(co, 0, _35clofun3124, 2, x, w);
coraCall(co, 2, globalRef(intern("number?")), x);
}
} else {
coraCall(co, 1, _35cc1335);
}
} else {
coraCall(co, 1, _35cc1335);
}
} else {
coraCall(co, 1, _35cc1335);
}
} else {
coraCall(co, 1, _35cc1335);
}
}

void _35clofun3124(struct Cora* co) {
Obj _35val2579 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
if (True == _35val2579) {
pushCont(co, 0, _35clofun3125, 2, x, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("makeNumber("));
} else {
Obj _35reg2582 = primIsString(x);
if (True == _35reg2582) {
pushCont(co, 0, _35clofun3127, 2, x, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("makeString1(\""));
} else {
Obj _35reg2586 = primEQ(x, Nil);
if (True == _35reg2586) {
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("Nil"));
} else {
Obj _35reg2587 = primEQ(x, True);
if (True == _35reg2587) {
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("True"));
} else {
Obj _35reg2588 = primEQ(x, False);
if (True == _35reg2588) {
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("False"));
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("no cond match"));
}
}
}
}
}
}

void _35clofun3127(struct Cora* co) {
Obj _35val2583 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3128, 1, w);
coraCall(co, 2, globalRef(intern("cora/lib/toc/internal.escape-str")), x);
}

void _35clofun3128(struct Cora* co) {
Obj _35val2584 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
pushCont(co, 0, _35clofun3129, 1, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, _35val2584);
}

void _35clofun3129(struct Cora* co) {
Obj _35val2585 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("\")"));
}

void _35clofun3125(struct Cora* co) {
Obj _35val2580 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3126, 1, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, x);
}

void _35clofun3126(struct Cora* co) {
Obj _35val2581 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(")"));
}

void _35clofun3121(struct Cora* co) {
Obj _35val2576 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3122, 1, w);
coraCall(co, 2, globalRef(intern("symbol->string")), x);
}

void _35clofun3122(struct Cora* co) {
Obj _35val2577 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
pushCont(co, 0, _35clofun3123, 1, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, _35val2577);
}

void _35clofun3123(struct Cora* co) {
Obj _35val2578 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("\")"));
}

void _35clofun3070(struct Cora* co) {
Obj _35cc1336 = makeNative(0, _35clofun3071, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2526 = primIsCons(closureRef(co, 2));
if (True == _35reg2526) {
Obj _35reg2527 = primCar(closureRef(co, 2));
Obj _35reg2528 = primEQ(intern("let"), _35reg2527);
if (True == _35reg2528) {
Obj _35reg2529 = primCdr(closureRef(co, 2));
Obj _35reg2530 = primIsCons(_35reg2529);
if (True == _35reg2530) {
Obj _35reg2531 = primCdr(closureRef(co, 2));
Obj _35reg2532 = primCar(_35reg2531);
Obj a = _35reg2532;
Obj _35reg2533 = primCdr(closureRef(co, 2));
Obj _35reg2534 = primCdr(_35reg2533);
Obj _35reg2535 = primIsCons(_35reg2534);
if (True == _35reg2535) {
Obj _35reg2536 = primCdr(closureRef(co, 2));
Obj _35reg2537 = primCdr(_35reg2536);
Obj _35reg2538 = primCar(_35reg2537);
Obj b = _35reg2538;
Obj _35reg2539 = primCdr(closureRef(co, 2));
Obj _35reg2540 = primCdr(_35reg2539);
Obj _35reg2541 = primCdr(_35reg2540);
Obj _35reg2542 = primIsCons(_35reg2541);
if (True == _35reg2542) {
Obj _35reg2543 = primCdr(closureRef(co, 2));
Obj _35reg2544 = primCdr(_35reg2543);
Obj _35reg2545 = primCdr(_35reg2544);
Obj _35reg2546 = primCar(_35reg2545);
Obj c = _35reg2546;
Obj _35reg2547 = primCdr(closureRef(co, 2));
Obj _35reg2548 = primCdr(_35reg2547);
Obj _35reg2549 = primCdr(_35reg2548);
Obj _35reg2550 = primCdr(_35reg2549);
Obj _35reg2551 = primEQ(Nil, _35reg2550);
if (True == _35reg2551) {
pushCont(co, 0, _35clofun3111, 5, b, a, env, w, c);
coraCall(co, 3, globalRef(intern("cora/lib/toc.index")), a, env);
} else {
coraCall(co, 1, _35cc1336);
}
} else {
coraCall(co, 1, _35cc1336);
}
} else {
coraCall(co, 1, _35cc1336);
}
} else {
coraCall(co, 1, _35cc1336);
}
} else {
coraCall(co, 1, _35cc1336);
}
} else {
coraCall(co, 1, _35cc1336);
}
}

void _35clofun3111(struct Cora* co) {
Obj _35val2552 = co->args[1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 4];
Obj idx = _35val2552;
Obj _35reg2553 = primLT(idx, makeNumber(0));
if (True == _35reg2553) {
pushCont(co, 0, _35clofun3112, 5, b, a, env, w, c);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("Obj "));
} else {
Nil;
pushCont(co, 0, _35clofun3117, 5, b, a, env, w, c);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-sym")), w, a);
}
}

void _35clofun3117(struct Cora* co) {
Obj _35val2560 = co->args[1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3118, 5, b, a, env, w, c);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(" = "));
}

void _35clofun3118(struct Cora* co) {
Obj _35val2561 = co->args[1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3119, 4, a, env, w, c);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, b);
}

void _35clofun3119(struct Cora* co) {
Obj _35val2562 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3120, 4, a, env, w, c);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(";\n"));
}

void _35clofun3120(struct Cora* co) {
Obj _35val2563 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj _35reg2564 = primCons(a, env);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), _35reg2564, w, c);
}

void _35clofun3112(struct Cora* co) {
Obj _35val2554 = co->args[1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3113, 5, b, a, env, w, c);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-sym")), w, a);
}

void _35clofun3113(struct Cora* co) {
Obj _35val2555 = co->args[1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3114, 5, b, a, env, w, c);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(" = "));
}

void _35clofun3114(struct Cora* co) {
Obj _35val2556 = co->args[1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3115, 4, a, env, w, c);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, b);
}

void _35clofun3115(struct Cora* co) {
Obj _35val2557 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3116, 4, a, env, w, c);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(";\n"));
}

void _35clofun3116(struct Cora* co) {
Obj _35val2558 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj _35reg2559 = primCons(a, env);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), _35reg2559, w, c);
}

void _35clofun3071(struct Cora* co) {
Obj _35cc1337 = makeNative(0, _35clofun3072, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2505 = primIsCons(closureRef(co, 2));
if (True == _35reg2505) {
Obj _35reg2506 = primCar(closureRef(co, 2));
Obj _35reg2507 = primIsCons(_35reg2506);
if (True == _35reg2507) {
Obj _35reg2508 = primCar(closureRef(co, 2));
Obj _35reg2509 = primCar(_35reg2508);
Obj _35reg2510 = primEQ(intern("%builtin"), _35reg2509);
if (True == _35reg2510) {
Obj _35reg2511 = primCar(closureRef(co, 2));
Obj _35reg2512 = primCdr(_35reg2511);
Obj _35reg2513 = primIsCons(_35reg2512);
if (True == _35reg2513) {
Obj _35reg2514 = primCar(closureRef(co, 2));
Obj _35reg2515 = primCdr(_35reg2514);
Obj _35reg2516 = primCar(_35reg2515);
Obj f = _35reg2516;
Obj _35reg2517 = primCar(closureRef(co, 2));
Obj _35reg2518 = primCdr(_35reg2517);
Obj _35reg2519 = primCdr(_35reg2518);
Obj _35reg2520 = primEQ(Nil, _35reg2519);
if (True == _35reg2520) {
Obj _35reg2521 = primCdr(closureRef(co, 2));
Obj args = _35reg2521;
pushCont(co, 0, _35clofun3107, 3, env, args, w);
coraCall(co, 2, globalRef(intern("cora/lib/toc.builtin->name")), f);
} else {
coraCall(co, 1, _35cc1337);
}
} else {
coraCall(co, 1, _35cc1337);
}
} else {
coraCall(co, 1, _35cc1337);
}
} else {
coraCall(co, 1, _35cc1337);
}
} else {
coraCall(co, 1, _35cc1337);
}
}

void _35clofun3107(struct Cora* co) {
Obj _35val2522 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3108, 3, env, args, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-sym")), w, _35val2522);
}

void _35clofun3108(struct Cora* co) {
Obj _35val2523 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3109, 3, env, args, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("("));
}

void _35clofun3109(struct Cora* co) {
Obj _35val2524 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3110, 1, w);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst-list")), env, w, args);
}

void _35clofun3110(struct Cora* co) {
Obj _35val2525 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(")"));
}

void _35clofun3072(struct Cora* co) {
Obj _35cc1338 = makeNative(0, _35clofun3073, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2473 = primIsCons(closureRef(co, 2));
if (True == _35reg2473) {
Obj _35reg2474 = primCar(closureRef(co, 2));
Obj _35reg2475 = primEQ(intern("if"), _35reg2474);
if (True == _35reg2475) {
Obj _35reg2476 = primCdr(closureRef(co, 2));
Obj _35reg2477 = primIsCons(_35reg2476);
if (True == _35reg2477) {
Obj _35reg2478 = primCdr(closureRef(co, 2));
Obj _35reg2479 = primCar(_35reg2478);
Obj a = _35reg2479;
Obj _35reg2480 = primCdr(closureRef(co, 2));
Obj _35reg2481 = primCdr(_35reg2480);
Obj _35reg2482 = primIsCons(_35reg2481);
if (True == _35reg2482) {
Obj _35reg2483 = primCdr(closureRef(co, 2));
Obj _35reg2484 = primCdr(_35reg2483);
Obj _35reg2485 = primCar(_35reg2484);
Obj b = _35reg2485;
Obj _35reg2486 = primCdr(closureRef(co, 2));
Obj _35reg2487 = primCdr(_35reg2486);
Obj _35reg2488 = primCdr(_35reg2487);
Obj _35reg2489 = primIsCons(_35reg2488);
if (True == _35reg2489) {
Obj _35reg2490 = primCdr(closureRef(co, 2));
Obj _35reg2491 = primCdr(_35reg2490);
Obj _35reg2492 = primCdr(_35reg2491);
Obj _35reg2493 = primCar(_35reg2492);
Obj c = _35reg2493;
Obj _35reg2494 = primCdr(closureRef(co, 2));
Obj _35reg2495 = primCdr(_35reg2494);
Obj _35reg2496 = primCdr(_35reg2495);
Obj _35reg2497 = primCdr(_35reg2496);
Obj _35reg2498 = primEQ(Nil, _35reg2497);
if (True == _35reg2498) {
pushCont(co, 0, _35clofun3101, 5, a, b, env, c, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("if (True == "));
} else {
coraCall(co, 1, _35cc1338);
}
} else {
coraCall(co, 1, _35cc1338);
}
} else {
coraCall(co, 1, _35cc1338);
}
} else {
coraCall(co, 1, _35cc1338);
}
} else {
coraCall(co, 1, _35cc1338);
}
} else {
coraCall(co, 1, _35cc1338);
}
}

void _35clofun3101(struct Cora* co) {
Obj _35val2499 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3102, 4, b, env, c, w);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, a);
}

void _35clofun3102(struct Cora* co) {
Obj _35val2500 = co->args[1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3103, 4, b, env, c, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(") {\n"));
}

void _35clofun3103(struct Cora* co) {
Obj _35val2501 = co->args[1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3104, 3, env, c, w);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, b);
}

void _35clofun3104(struct Cora* co) {
Obj _35val2502 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3105, 3, env, c, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("} else {\n"));
}

void _35clofun3105(struct Cora* co) {
Obj _35val2503 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3106, 1, w);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, c);
}

void _35clofun3106(struct Cora* co) {
Obj _35val2504 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("}\n"));
}

void _35clofun3073(struct Cora* co) {
Obj _35cc1339 = makeNative(0, _35clofun3074, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2446 = primIsCons(closureRef(co, 2));
if (True == _35reg2446) {
Obj _35reg2447 = primCar(closureRef(co, 2));
Obj _35reg2448 = primEQ(intern("%closure"), _35reg2447);
if (True == _35reg2448) {
Obj _35reg2449 = primCdr(closureRef(co, 2));
Obj _35reg2450 = primIsCons(_35reg2449);
if (True == _35reg2450) {
Obj _35reg2451 = primCdr(closureRef(co, 2));
Obj _35reg2452 = primCar(_35reg2451);
Obj label = _35reg2452;
Obj _35reg2453 = primCdr(closureRef(co, 2));
Obj _35reg2454 = primCdr(_35reg2453);
Obj _35reg2455 = primIsCons(_35reg2454);
if (True == _35reg2455) {
Obj _35reg2456 = primCdr(closureRef(co, 2));
Obj _35reg2457 = primCdr(_35reg2456);
Obj _35reg2458 = primCar(_35reg2457);
Obj nargs = _35reg2458;
Obj _35reg2459 = primCdr(closureRef(co, 2));
Obj _35reg2460 = primCdr(_35reg2459);
Obj _35reg2461 = primCdr(_35reg2460);
Obj frees = _35reg2461;
pushCont(co, 0, _35clofun3091, 5, label, nargs, env, frees, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("makeNative(0, "));
} else {
coraCall(co, 1, _35cc1339);
}
} else {
coraCall(co, 1, _35cc1339);
}
} else {
coraCall(co, 1, _35cc1339);
}
} else {
coraCall(co, 1, _35cc1339);
}
}

void _35clofun3091(struct Cora* co) {
Obj _35val2462 = co->args[1];
Obj label = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj nargs = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 4];
pushCont(co, 0, _35clofun3092, 4, nargs, env, frees, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-sym")), w, label);
}

void _35clofun3092(struct Cora* co) {
Obj _35val2463 = co->args[1];
Obj nargs = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3093, 4, nargs, env, frees, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(", "));
}

void _35clofun3093(struct Cora* co) {
Obj _35val2464 = co->args[1];
Obj nargs = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 3];
pushCont(co, 0, _35clofun3094, 3, env, frees, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, nargs);
}

void _35clofun3094(struct Cora* co) {
Obj _35val2465 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3095, 3, env, frees, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(", "));
}

void _35clofun3095(struct Cora* co) {
Obj _35val2466 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3096, 3, env, frees, w);
coraCall(co, 2, globalRef(intern("length")), frees);
}

void _35clofun3096(struct Cora* co) {
Obj _35val2467 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3097, 3, env, frees, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, _35val2467);
}

void _35clofun3097(struct Cora* co) {
Obj _35val2468 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3098, 3, env, frees, w);
coraCall(co, 2, globalRef(intern("null?")), frees);
}

void _35clofun3098(struct Cora* co) {
Obj _35val2469 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj _35reg2470 = primNot(_35val2469);
if (True == _35reg2470) {
pushCont(co, 0, _35clofun3099, 3, env, frees, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(", "));
} else {
Nil;
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(")"));
}
}

void _35clofun3099(struct Cora* co) {
Obj _35val2471 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3100, 1, w);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst-list")), env, w, frees);
}

void _35clofun3100(struct Cora* co) {
Obj _35val2472 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(")"));
}

void _35clofun3074(struct Cora* co) {
Obj _35cc1340 = makeNative(0, _35clofun3075, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2427 = primIsCons(closureRef(co, 2));
if (True == _35reg2427) {
Obj _35reg2428 = primCar(closureRef(co, 2));
Obj _35reg2429 = primEQ(intern("do"), _35reg2428);
if (True == _35reg2429) {
Obj _35reg2430 = primCdr(closureRef(co, 2));
Obj _35reg2431 = primIsCons(_35reg2430);
if (True == _35reg2431) {
Obj _35reg2432 = primCdr(closureRef(co, 2));
Obj _35reg2433 = primCar(_35reg2432);
Obj a = _35reg2433;
Obj _35reg2434 = primCdr(closureRef(co, 2));
Obj _35reg2435 = primCdr(_35reg2434);
Obj _35reg2436 = primIsCons(_35reg2435);
if (True == _35reg2436) {
Obj _35reg2437 = primCdr(closureRef(co, 2));
Obj _35reg2438 = primCdr(_35reg2437);
Obj _35reg2439 = primCar(_35reg2438);
Obj b = _35reg2439;
Obj _35reg2440 = primCdr(closureRef(co, 2));
Obj _35reg2441 = primCdr(_35reg2440);
Obj _35reg2442 = primCdr(_35reg2441);
Obj _35reg2443 = primEQ(Nil, _35reg2442);
if (True == _35reg2443) {
pushCont(co, 0, _35clofun3089, 3, env, w, b);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, a);
} else {
coraCall(co, 1, _35cc1340);
}
} else {
coraCall(co, 1, _35cc1340);
}
} else {
coraCall(co, 1, _35cc1340);
}
} else {
coraCall(co, 1, _35cc1340);
}
} else {
coraCall(co, 1, _35cc1340);
}
}

void _35clofun3089(struct Cora* co) {
Obj _35val2444 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3090, 3, env, w, b);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(";\n"));
}

void _35clofun3090(struct Cora* co) {
Obj _35val2445 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj b = co->ctx.stk.stack[co->ctx.stk.base + 2];
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, b);
}

void _35clofun3075(struct Cora* co) {
Obj _35cc1341 = makeNative(0, _35clofun3076, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2415 = primIsCons(closureRef(co, 2));
if (True == _35reg2415) {
Obj _35reg2416 = primCar(closureRef(co, 2));
Obj _35reg2417 = primEQ(intern("return"), _35reg2416);
if (True == _35reg2417) {
Obj _35reg2418 = primCdr(closureRef(co, 2));
Obj _35reg2419 = primIsCons(_35reg2418);
if (True == _35reg2419) {
Obj _35reg2420 = primCdr(closureRef(co, 2));
Obj _35reg2421 = primCar(_35reg2420);
Obj x = _35reg2421;
Obj _35reg2422 = primCdr(closureRef(co, 2));
Obj _35reg2423 = primCdr(_35reg2422);
Obj _35reg2424 = primEQ(Nil, _35reg2423);
if (True == _35reg2424) {
pushCont(co, 0, _35clofun3087, 3, env, x, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("coraReturn(co, "));
} else {
coraCall(co, 1, _35cc1341);
}
} else {
coraCall(co, 1, _35cc1341);
}
} else {
coraCall(co, 1, _35cc1341);
}
} else {
coraCall(co, 1, _35cc1341);
}
}

void _35clofun3087(struct Cora* co) {
Obj _35val2425 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3088, 1, w);
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, x);
}

void _35clofun3088(struct Cora* co) {
Obj _35val2426 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(");\nreturn;\n"));
}

void _35clofun3076(struct Cora* co) {
Obj _35cc1342 = makeNative(0, _35clofun3077, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2405 = primIsCons(closureRef(co, 2));
if (True == _35reg2405) {
Obj _35reg2406 = primCar(closureRef(co, 2));
Obj _35reg2407 = primEQ(intern("tailcall"), _35reg2406);
if (True == _35reg2407) {
Obj _35reg2408 = primCdr(closureRef(co, 2));
Obj _35reg2409 = primIsCons(_35reg2408);
if (True == _35reg2409) {
Obj _35reg2410 = primCdr(closureRef(co, 2));
Obj _35reg2411 = primCar(_35reg2410);
Obj exp = _35reg2411;
Obj _35reg2412 = primCdr(closureRef(co, 2));
Obj _35reg2413 = primCdr(_35reg2412);
Obj _35reg2414 = primEQ(Nil, _35reg2413);
if (True == _35reg2414) {
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, exp);
} else {
coraCall(co, 1, _35cc1342);
}
} else {
coraCall(co, 1, _35cc1342);
}
} else {
coraCall(co, 1, _35cc1342);
}
} else {
coraCall(co, 1, _35cc1342);
}
}

void _35clofun3077(struct Cora* co) {
Obj _35cc1343 = makeNative(0, _35clofun3078, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2387 = primIsCons(closureRef(co, 2));
if (True == _35reg2387) {
Obj _35reg2388 = primCar(closureRef(co, 2));
Obj _35reg2389 = primEQ(intern("call"), _35reg2388);
if (True == _35reg2389) {
Obj _35reg2390 = primCdr(closureRef(co, 2));
Obj _35reg2391 = primIsCons(_35reg2390);
if (True == _35reg2391) {
Obj _35reg2392 = primCdr(closureRef(co, 2));
Obj _35reg2393 = primCar(_35reg2392);
Obj exp = _35reg2393;
Obj _35reg2394 = primCdr(closureRef(co, 2));
Obj _35reg2395 = primCdr(_35reg2394);
Obj _35reg2396 = primIsCons(_35reg2395);
if (True == _35reg2396) {
Obj _35reg2397 = primCdr(closureRef(co, 2));
Obj _35reg2398 = primCdr(_35reg2397);
Obj _35reg2399 = primCar(_35reg2398);
Obj cont = _35reg2399;
Obj _35reg2400 = primCdr(closureRef(co, 2));
Obj _35reg2401 = primCdr(_35reg2400);
Obj _35reg2402 = primCdr(_35reg2401);
Obj _35reg2403 = primEQ(Nil, _35reg2402);
if (True == _35reg2403) {
pushCont(co, 0, _35clofun3086, 3, env, w, exp);
coraCall(co, 3, globalRef(intern("cora/lib/toc.generate-cont")), w, cont);
} else {
coraCall(co, 1, _35cc1343);
}
} else {
coraCall(co, 1, _35cc1343);
}
} else {
coraCall(co, 1, _35cc1343);
}
} else {
coraCall(co, 1, _35cc1343);
}
} else {
coraCall(co, 1, _35cc1343);
}
}

void _35clofun3086(struct Cora* co) {
Obj _35val2404 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 2];
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), env, w, exp);
}

void _35clofun3078(struct Cora* co) {
Obj _35cc1344 = makeNative(0, _35clofun3079, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2377 = primIsCons(closureRef(co, 2));
if (True == _35reg2377) {
Obj _35reg2378 = primCar(closureRef(co, 2));
Obj f = _35reg2378;
Obj _35reg2379 = primCdr(closureRef(co, 2));
Obj args = _35reg2379;
pushCont(co, 0, _35clofun3080, 3, f, args, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1("coraCall(co, "));
} else {
coraCall(co, 1, _35cc1344);
}
}

void _35clofun3080(struct Cora* co) {
Obj _35val2380 = co->args[1];
Obj f = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3081, 3, f, args, w);
coraCall(co, 2, globalRef(intern("length")), args);
}

void _35clofun3081(struct Cora* co) {
Obj _35val2381 = co->args[1];
Obj f = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj _35reg2382 = primAdd(makeNumber(1), _35val2381);
pushCont(co, 0, _35clofun3082, 3, f, args, w);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-num")), w, _35reg2382);
}

void _35clofun3082(struct Cora* co) {
Obj _35val2383 = co->args[1];
Obj f = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj _35reg2385 = primCons(f, args);
pushCont(co, 0, _35clofun3085, 1, w);
coraCall(co, 3, globalRef(intern("for-each")), makeNative(0, _35clofun3083, 1, 1, w), _35reg2385);
}

void _35clofun3085(struct Cora* co) {
Obj _35val2386 = co->args[1];
Obj w = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), w, makeString1(");\n"));
}

void _35clofun3083(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, 0, _35clofun3084, 1, x);
coraCall(co, 3, globalRef(intern("cora/lib/toc/internal.generate-str")), closureRef(co, 0), makeString1(", "));
}

void _35clofun3084(struct Cora* co) {
Obj _35val2384 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 4, globalRef(intern("cora/lib/toc.generate-inst")), Nil, closureRef(co, 0), x);
}

void _35clofun3079(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3063(struct Cora* co) {
Obj x = co->args[1];
Obj k = co->args[2];
Obj _35reg2370 = primGenSym(intern("reg"));
Obj tmp = _35reg2370;
pushCont(co, 0, _35clofun3064, 2, x, tmp);
coraCall(co, 2, k, tmp);
}

void _35clofun3064(struct Cora* co) {
Obj _35val2371 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj tmp = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2372 = primCons(_35val2371, Nil);
Obj _35reg2373 = primCons(x, _35reg2372);
Obj _35reg2374 = primCons(tmp, _35reg2373);
Obj _35reg2375 = primCons(intern("let"), _35reg2374);
coraReturn(co, _35reg2375);
return;
}

void _35clofun3058(struct Cora* co) {
Obj _35p1322 = co->args[1];
Obj _35p1323 = co->args[2];
Obj _35p1324 = co->args[3];
Obj _35p1325 = co->args[4];
Obj _35cc1326 = makeNative(0, _35clofun3059, 0, 4, _35p1322, _35p1323, _35p1324, _35p1325);
Obj res = _35p1322;
Obj init = _35p1323;
Obj _35reg2367 = primEQ(Nil, _35p1324);
if (True == _35reg2367) {
Obj k = _35p1325;
pushCont(co, 0, _35clofun3062, 2, k, init);
coraCall(co, 2, globalRef(intern("reverse")), res);
} else {
coraCall(co, 1, _35cc1326);
}
}

void _35clofun3062(struct Cora* co) {
Obj _35val2368 = co->args[1];
Obj k = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj init = co->ctx.stk.stack[co->ctx.stk.base + 1];
coraCall(co, 3, k, init, _35val2368);
}

void _35clofun3059(struct Cora* co) {
Obj _35cc1327 = makeNative(0, _35clofun3060, 0, 0);
Obj res = closureRef(co, 0);
Obj init = closureRef(co, 1);
Obj _35reg2363 = primIsCons(closureRef(co, 2));
if (True == _35reg2363) {
Obj _35reg2364 = primCar(closureRef(co, 2));
Obj x = _35reg2364;
Obj _35reg2365 = primCdr(closureRef(co, 2));
Obj y = _35reg2365;
Obj k = closureRef(co, 3);
coraCall(co, 4, globalRef(intern("cora/lib/toc.collect-lambda")), init, x, makeNative(0, _35clofun3061, 2, 3, res, y, k));
} else {
coraCall(co, 1, _35cc1327);
}
}

void _35clofun3061(struct Cora* co) {
Obj init1 = co->args[1];
Obj x1 = co->args[2];
Obj _35reg2366 = primCons(x1, closureRef(co, 0));
coraCall(co, 5, globalRef(intern("cora/lib/toc.collect-lambda-list")), _35reg2366, init1, closureRef(co, 1), closureRef(co, 2));
}

void _35clofun3060(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3048(struct Cora* co) {
Obj _35p1316 = co->args[1];
Obj _35p1317 = co->args[2];
Obj _35p1318 = co->args[3];
Obj _35cc1319 = makeNative(0, _35clofun3049, 0, 3, _35p1316, _35p1317, _35p1318);
Obj res = _35p1316;
Obj _35reg2257 = primIsCons(_35p1317);
if (True == _35reg2257) {
Obj _35reg2258 = primCar(_35p1317);
Obj clo_45or_45cont = _35reg2258;
Obj _35reg2259 = primCdr(_35p1317);
Obj _35reg2260 = primIsCons(_35reg2259);
if (True == _35reg2260) {
Obj _35reg2261 = primCdr(_35p1317);
Obj _35reg2262 = primCar(_35reg2261);
Obj _35reg2263 = primIsCons(_35reg2262);
if (True == _35reg2263) {
Obj _35reg2264 = primCdr(_35p1317);
Obj _35reg2265 = primCar(_35reg2264);
Obj _35reg2266 = primCar(_35reg2265);
Obj _35reg2267 = primEQ(intern("lambda"), _35reg2266);
if (True == _35reg2267) {
Obj _35reg2268 = primCdr(_35p1317);
Obj _35reg2269 = primCar(_35reg2268);
Obj _35reg2270 = primCdr(_35reg2269);
Obj _35reg2271 = primIsCons(_35reg2270);
if (True == _35reg2271) {
Obj _35reg2272 = primCdr(_35p1317);
Obj _35reg2273 = primCar(_35reg2272);
Obj _35reg2274 = primCdr(_35reg2273);
Obj _35reg2275 = primCar(_35reg2274);
Obj params = _35reg2275;
Obj _35reg2276 = primCdr(_35p1317);
Obj _35reg2277 = primCar(_35reg2276);
Obj _35reg2278 = primCdr(_35reg2277);
Obj _35reg2279 = primCdr(_35reg2278);
Obj _35reg2280 = primIsCons(_35reg2279);
if (True == _35reg2280) {
Obj _35reg2281 = primCdr(_35p1317);
Obj _35reg2282 = primCar(_35reg2281);
Obj _35reg2283 = primCdr(_35reg2282);
Obj _35reg2284 = primCdr(_35reg2283);
Obj _35reg2285 = primCar(_35reg2284);
Obj body = _35reg2285;
Obj _35reg2286 = primCdr(_35p1317);
Obj _35reg2287 = primCar(_35reg2286);
Obj _35reg2288 = primCdr(_35reg2287);
Obj _35reg2289 = primCdr(_35reg2288);
Obj _35reg2290 = primCdr(_35reg2289);
Obj _35reg2291 = primEQ(Nil, _35reg2290);
if (True == _35reg2291) {
Obj _35reg2292 = primCdr(_35p1317);
Obj _35reg2293 = primCdr(_35reg2292);
Obj fvs = _35reg2293;
Obj k = _35p1318;
Obj _35reg2294 = primEQ(clo_45or_45cont, intern("%closure"));
if (True == _35reg2294) {
if (True == True) {
Obj _35reg2295 = primGenSym(intern("clofun"));
Obj name = _35reg2295;
coraCall(co, 4, globalRef(intern("cora/lib/toc.collect-lambda")), res, body, makeNative(0, _35clofun3052, 2, 5, k, params, clo_45or_45cont, name, fvs));
} else {
coraCall(co, 1, _35cc1319);
}
} else {
Obj _35reg2317 = primEQ(clo_45or_45cont, intern("%continuation"));
if (True == _35reg2317) {
if (True == True) {
Obj _35reg2318 = primGenSym(intern("clofun"));
Obj name = _35reg2318;
coraCall(co, 4, globalRef(intern("cora/lib/toc.collect-lambda")), res, body, makeNative(0, _35clofun3054, 2, 5, k, params, clo_45or_45cont, name, fvs));
} else {
coraCall(co, 1, _35cc1319);
}
} else {
if (True == False) {
Obj _35reg2340 = primGenSym(intern("clofun"));
Obj name = _35reg2340;
coraCall(co, 4, globalRef(intern("cora/lib/toc.collect-lambda")), res, body, makeNative(0, _35clofun3056, 2, 5, k, params, clo_45or_45cont, name, fvs));
} else {
coraCall(co, 1, _35cc1319);
}
}
}
} else {
coraCall(co, 1, _35cc1319);
}
} else {
coraCall(co, 1, _35cc1319);
}
} else {
coraCall(co, 1, _35cc1319);
}
} else {
coraCall(co, 1, _35cc1319);
}
} else {
coraCall(co, 1, _35cc1319);
}
} else {
coraCall(co, 1, _35cc1319);
}
} else {
coraCall(co, 1, _35cc1319);
}
}

void _35clofun3056(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2341 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2341) {
Obj _35reg2342 = primCons(body1, Nil);
Obj _35reg2343 = primCons(Nil, _35reg2342);
Obj _35reg2344 = primCons(closureRef(co, 1), _35reg2343);
Obj _35reg2345 = primCons(intern("lambda"), _35reg2344);
Obj _35reg2346 = primCons(_35reg2345, Nil);
Obj _35reg2347 = primCons(closureRef(co, 3), _35reg2346);
Obj _35reg2348 = primCons(_35reg2347, res1);
pushCont(co, 0, _35clofun3057, 1, _35reg2348);
coraCall(co, 2, globalRef(intern("length")), closureRef(co, 1));
} else {
Obj _35reg2353 = primCons(body1, Nil);
Obj _35reg2354 = primCons(closureRef(co, 4), _35reg2353);
Obj _35reg2355 = primCons(closureRef(co, 1), _35reg2354);
Obj _35reg2356 = primCons(intern("lambda"), _35reg2355);
Obj _35reg2357 = primCons(_35reg2356, Nil);
Obj _35reg2358 = primCons(closureRef(co, 3), _35reg2357);
Obj _35reg2359 = primCons(_35reg2358, res1);
Obj _35reg2360 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2361 = primCons(closureRef(co, 2), _35reg2360);
coraCall(co, 3, closureRef(co, 0), _35reg2359, _35reg2361);
}
}

void _35clofun3057(struct Cora* co) {
Obj _35val2349 = co->args[1];
Obj _35reg2348 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2350 = primCons(_35val2349, closureRef(co, 4));
Obj _35reg2351 = primCons(closureRef(co, 3), _35reg2350);
Obj _35reg2352 = primCons(closureRef(co, 2), _35reg2351);
coraCall(co, 3, closureRef(co, 0), _35reg2348, _35reg2352);
}

void _35clofun3054(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2319 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2319) {
Obj _35reg2320 = primCons(body1, Nil);
Obj _35reg2321 = primCons(Nil, _35reg2320);
Obj _35reg2322 = primCons(closureRef(co, 1), _35reg2321);
Obj _35reg2323 = primCons(intern("lambda"), _35reg2322);
Obj _35reg2324 = primCons(_35reg2323, Nil);
Obj _35reg2325 = primCons(closureRef(co, 3), _35reg2324);
Obj _35reg2326 = primCons(_35reg2325, res1);
pushCont(co, 0, _35clofun3055, 1, _35reg2326);
coraCall(co, 2, globalRef(intern("length")), closureRef(co, 1));
} else {
Obj _35reg2331 = primCons(body1, Nil);
Obj _35reg2332 = primCons(closureRef(co, 4), _35reg2331);
Obj _35reg2333 = primCons(closureRef(co, 1), _35reg2332);
Obj _35reg2334 = primCons(intern("lambda"), _35reg2333);
Obj _35reg2335 = primCons(_35reg2334, Nil);
Obj _35reg2336 = primCons(closureRef(co, 3), _35reg2335);
Obj _35reg2337 = primCons(_35reg2336, res1);
Obj _35reg2338 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2339 = primCons(closureRef(co, 2), _35reg2338);
coraCall(co, 3, closureRef(co, 0), _35reg2337, _35reg2339);
}
}

void _35clofun3055(struct Cora* co) {
Obj _35val2327 = co->args[1];
Obj _35reg2326 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2328 = primCons(_35val2327, closureRef(co, 4));
Obj _35reg2329 = primCons(closureRef(co, 3), _35reg2328);
Obj _35reg2330 = primCons(closureRef(co, 2), _35reg2329);
coraCall(co, 3, closureRef(co, 0), _35reg2326, _35reg2330);
}

void _35clofun3052(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2296 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2296) {
Obj _35reg2297 = primCons(body1, Nil);
Obj _35reg2298 = primCons(Nil, _35reg2297);
Obj _35reg2299 = primCons(closureRef(co, 1), _35reg2298);
Obj _35reg2300 = primCons(intern("lambda"), _35reg2299);
Obj _35reg2301 = primCons(_35reg2300, Nil);
Obj _35reg2302 = primCons(closureRef(co, 3), _35reg2301);
Obj _35reg2303 = primCons(_35reg2302, res1);
pushCont(co, 0, _35clofun3053, 1, _35reg2303);
coraCall(co, 2, globalRef(intern("length")), closureRef(co, 1));
} else {
Obj _35reg2308 = primCons(body1, Nil);
Obj _35reg2309 = primCons(closureRef(co, 4), _35reg2308);
Obj _35reg2310 = primCons(closureRef(co, 1), _35reg2309);
Obj _35reg2311 = primCons(intern("lambda"), _35reg2310);
Obj _35reg2312 = primCons(_35reg2311, Nil);
Obj _35reg2313 = primCons(closureRef(co, 3), _35reg2312);
Obj _35reg2314 = primCons(_35reg2313, res1);
Obj _35reg2315 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2316 = primCons(closureRef(co, 2), _35reg2315);
coraCall(co, 3, closureRef(co, 0), _35reg2314, _35reg2316);
}
}

void _35clofun3053(struct Cora* co) {
Obj _35val2304 = co->args[1];
Obj _35reg2303 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2305 = primCons(_35val2304, closureRef(co, 4));
Obj _35reg2306 = primCons(closureRef(co, 3), _35reg2305);
Obj _35reg2307 = primCons(closureRef(co, 2), _35reg2306);
coraCall(co, 3, closureRef(co, 0), _35reg2303, _35reg2307);
}

void _35clofun3049(struct Cora* co) {
Obj _35cc1320 = makeNative(0, _35clofun3050, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj res = closureRef(co, 0);
Obj f_45args = closureRef(co, 1);
Obj k = closureRef(co, 2);
Obj _35reg2256 = primIsCons(f_45args);
if (True == _35reg2256) {
coraCall(co, 5, globalRef(intern("cora/lib/toc.collect-lambda-list")), Nil, res, f_45args, k);
} else {
coraCall(co, 1, _35cc1320);
}
}

void _35clofun3050(struct Cora* co) {
Obj _35cc1321 = makeNative(0, _35clofun3051, 0, 0);
Obj res = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj k = closureRef(co, 2);
coraCall(co, 3, k, res, x);
}

void _35clofun3051(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3030(struct Cora* co) {
Obj _35p1308 = co->args[1];
Obj _35p1309 = co->args[2];
Obj _35cc1310 = makeNative(0, _35clofun3031, 0, 2, _35p1308, _35p1309);
Obj __ = _35p1308;
Obj x = _35p1309;
pushCont(co, 0, _35clofun3047, 2, x, _35cc1310);
coraCall(co, 2, globalRef(intern("cora/lib/toc.convert-protect?")), x);
}

void _35clofun3047(struct Cora* co) {
Obj _35val2254 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35cc1310 = co->ctx.stk.stack[co->ctx.stk.base + 1];
if (True == _35val2254) {
coraReturn(co, x);
return;
} else {
coraCall(co, 1, _35cc1310);
}
}

void _35clofun3031(struct Cora* co) {
Obj _35cc1311 = makeNative(0, _35clofun3032, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj var = closureRef(co, 1);
Obj _35reg2253 = primIsSymbol(var);
if (True == _35reg2253) {
coraReturn(co, var);
return;
} else {
coraCall(co, 1, _35cc1311);
}
}

void _35clofun3032(struct Cora* co) {
Obj _35cc1312 = makeNative(0, _35clofun3033, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2232 = primIsCons(closureRef(co, 1));
if (True == _35reg2232) {
Obj _35reg2233 = primCar(closureRef(co, 1));
Obj _35reg2234 = primEQ(intern("lambda"), _35reg2233);
if (True == _35reg2234) {
Obj _35reg2235 = primCdr(closureRef(co, 1));
Obj _35reg2236 = primIsCons(_35reg2235);
if (True == _35reg2236) {
Obj _35reg2237 = primCdr(closureRef(co, 1));
Obj _35reg2238 = primCar(_35reg2237);
Obj args = _35reg2238;
Obj _35reg2239 = primCdr(closureRef(co, 1));
Obj _35reg2240 = primCdr(_35reg2239);
Obj _35reg2241 = primIsCons(_35reg2240);
if (True == _35reg2241) {
Obj _35reg2242 = primCdr(closureRef(co, 1));
Obj _35reg2243 = primCdr(_35reg2242);
Obj _35reg2244 = primCar(_35reg2243);
Obj body = _35reg2244;
Obj _35reg2245 = primCdr(closureRef(co, 1));
Obj _35reg2246 = primCdr(_35reg2245);
Obj _35reg2247 = primCdr(_35reg2246);
Obj _35reg2248 = primEQ(Nil, _35reg2247);
if (True == _35reg2248) {
pushCont(co, 0, _35clofun3046, 1, args);
coraCall(co, 3, globalRef(intern("cora/lib/toc.explicit-stack")), fvs, body);
} else {
coraCall(co, 1, _35cc1312);
}
} else {
coraCall(co, 1, _35cc1312);
}
} else {
coraCall(co, 1, _35cc1312);
}
} else {
coraCall(co, 1, _35cc1312);
}
} else {
coraCall(co, 1, _35cc1312);
}
}

void _35clofun3046(struct Cora* co) {
Obj _35val2249 = co->args[1];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2250 = primCons(_35val2249, Nil);
Obj _35reg2251 = primCons(args, _35reg2250);
Obj _35reg2252 = primCons(intern("lambda"), _35reg2251);
coraReturn(co, _35reg2252);
return;
}

void _35clofun3033(struct Cora* co) {
Obj _35cc1313 = makeNative(0, _35clofun3034, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2205 = primIsCons(closureRef(co, 1));
if (True == _35reg2205) {
Obj _35reg2206 = primCar(closureRef(co, 1));
Obj _35reg2207 = primEQ(intern("continuation"), _35reg2206);
if (True == _35reg2207) {
Obj _35reg2208 = primCdr(closureRef(co, 1));
Obj _35reg2209 = primIsCons(_35reg2208);
if (True == _35reg2209) {
Obj _35reg2210 = primCdr(closureRef(co, 1));
Obj _35reg2211 = primCar(_35reg2210);
Obj val = _35reg2211;
Obj _35reg2212 = primCdr(closureRef(co, 1));
Obj _35reg2213 = primCdr(_35reg2212);
Obj _35reg2214 = primIsCons(_35reg2213);
if (True == _35reg2214) {
Obj _35reg2215 = primCdr(closureRef(co, 1));
Obj _35reg2216 = primCdr(_35reg2215);
Obj _35reg2217 = primCar(_35reg2216);
Obj body = _35reg2217;
Obj _35reg2218 = primCdr(closureRef(co, 1));
Obj _35reg2219 = primCdr(_35reg2218);
Obj _35reg2220 = primCdr(_35reg2219);
Obj _35reg2221 = primEQ(Nil, _35reg2220);
if (True == _35reg2221) {
pushCont(co, 0, _35clofun3041, 3, fvs, body, val);
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), body);
} else {
coraCall(co, 1, _35cc1313);
}
} else {
coraCall(co, 1, _35cc1313);
}
} else {
coraCall(co, 1, _35cc1313);
}
} else {
coraCall(co, 1, _35cc1313);
}
} else {
coraCall(co, 1, _35cc1313);
}
}

void _35clofun3041(struct Cora* co) {
Obj _35val2222 = co->args[1];
Obj fvs = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj val = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3042, 3, fvs, body, val);
coraCall(co, 3, globalRef(intern("cora/lib/toc.diff")), _35val2222, val);
}

void _35clofun3042(struct Cora* co) {
Obj _35val2223 = co->args[1];
Obj fvs = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj val = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj fvs1 = _35val2223;
pushCont(co, 0, _35clofun3043, 3, fvs1, body, val);
coraCall(co, 2, globalRef(intern("cora/lib/toc.explicit-stack")), fvs);
}

void _35clofun3043(struct Cora* co) {
Obj _35val2224 = co->args[1];
Obj fvs1 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj val = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3044, 3, fvs1, body, val);
coraCall(co, 3, globalRef(intern("map")), _35val2224, fvs1);
}

void _35clofun3044(struct Cora* co) {
Obj _35val2225 = co->args[1];
Obj fvs1 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj val = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj fvs2 = _35val2225;
pushCont(co, 0, _35clofun3045, 2, val, fvs2);
coraCall(co, 3, globalRef(intern("cora/lib/toc.explicit-stack")), fvs1, body);
}

void _35clofun3045(struct Cora* co) {
Obj _35val2226 = co->args[1];
Obj val = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj fvs2 = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2227 = primCons(_35val2226, Nil);
Obj _35reg2228 = primCons(val, _35reg2227);
Obj _35reg2229 = primCons(intern("lambda"), _35reg2228);
Obj _35reg2230 = primCons(_35reg2229, fvs2);
Obj _35reg2231 = primCons(intern("%continuation"), _35reg2230);
coraReturn(co, _35reg2231);
return;
}

void _35clofun3034(struct Cora* co) {
Obj _35cc1314 = makeNative(0, _35clofun3035, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2182 = primIsCons(closureRef(co, 1));
if (True == _35reg2182) {
Obj _35reg2183 = primCar(closureRef(co, 1));
Obj _35reg2184 = primEQ(intern("call"), _35reg2183);
if (True == _35reg2184) {
Obj _35reg2185 = primCdr(closureRef(co, 1));
Obj _35reg2186 = primIsCons(_35reg2185);
if (True == _35reg2186) {
Obj _35reg2187 = primCdr(closureRef(co, 1));
Obj _35reg2188 = primCar(_35reg2187);
Obj exp = _35reg2188;
Obj _35reg2189 = primCdr(closureRef(co, 1));
Obj _35reg2190 = primCdr(_35reg2189);
Obj _35reg2191 = primIsCons(_35reg2190);
if (True == _35reg2191) {
Obj _35reg2192 = primCdr(closureRef(co, 1));
Obj _35reg2193 = primCdr(_35reg2192);
Obj _35reg2194 = primCar(_35reg2193);
Obj cont = _35reg2194;
Obj _35reg2195 = primCdr(closureRef(co, 1));
Obj _35reg2196 = primCdr(_35reg2195);
Obj _35reg2197 = primCdr(_35reg2196);
Obj _35reg2198 = primEQ(Nil, _35reg2197);
if (True == _35reg2198) {
pushCont(co, 0, _35clofun3038, 3, exp, fvs, cont);
coraCall(co, 2, globalRef(intern("cora/lib/toc.explicit-stack")), fvs);
} else {
coraCall(co, 1, _35cc1314);
}
} else {
coraCall(co, 1, _35cc1314);
}
} else {
coraCall(co, 1, _35cc1314);
}
} else {
coraCall(co, 1, _35cc1314);
}
} else {
coraCall(co, 1, _35cc1314);
}
}

void _35clofun3038(struct Cora* co) {
Obj _35val2199 = co->args[1];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj fvs = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj cont = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun3039, 2, fvs, cont);
coraCall(co, 3, globalRef(intern("map")), _35val2199, exp);
}

void _35clofun3039(struct Cora* co) {
Obj _35val2200 = co->args[1];
Obj fvs = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj cont = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun3040, 1, _35val2200);
coraCall(co, 3, globalRef(intern("cora/lib/toc.explicit-stack")), fvs, cont);
}

void _35clofun3040(struct Cora* co) {
Obj _35val2201 = co->args[1];
Obj _35val2200 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2202 = primCons(_35val2201, Nil);
Obj _35reg2203 = primCons(_35val2200, _35reg2202);
Obj _35reg2204 = primCons(intern("call"), _35reg2203);
coraReturn(co, _35reg2204);
return;
}

void _35clofun3035(struct Cora* co) {
Obj _35cc1315 = makeNative(0, _35clofun3036, 0, 0);
Obj fvs = closureRef(co, 0);
Obj _35reg2177 = primIsCons(closureRef(co, 1));
if (True == _35reg2177) {
Obj _35reg2178 = primCar(closureRef(co, 1));
Obj f = _35reg2178;
Obj _35reg2179 = primCdr(closureRef(co, 1));
Obj args = _35reg2179;
pushCont(co, 0, _35clofun3037, 2, f, args);
coraCall(co, 2, globalRef(intern("cora/lib/toc.explicit-stack")), fvs);
} else {
coraCall(co, 1, _35cc1315);
}
}

void _35clofun3037(struct Cora* co) {
Obj _35val2180 = co->args[1];
Obj f = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2181 = primCons(f, args);
coraCall(co, 3, globalRef(intern("map")), _35val2180, _35reg2181);
}

void _35clofun3036(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3020(struct Cora* co) {
Obj _35p1303 = co->args[1];
Obj _35p1304 = co->args[2];
Obj _35p1305 = co->args[3];
Obj _35cc1306 = makeNative(0, _35clofun3021, 0, 3, _35p1303, _35p1304, _35p1305);
Obj _35reg2134 = primEQ(Nil, _35p1303);
if (True == _35reg2134) {
Obj ls = _35p1304;
Obj next = _35p1305;
pushCont(co, 0, _35clofun3024, 1, next);
coraCall(co, 2, globalRef(intern("reverse")), ls);
} else {
coraCall(co, 1, _35cc1306);
}
}

void _35clofun3024(struct Cora* co) {
Obj _35val2135 = co->args[1];
Obj next = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj exp = _35val2135;
Obj _35reg2136 = primCar(exp);
pushCont(co, 0, _35clofun3025, 2, next, exp);
coraCall(co, 2, globalRef(intern("pair?")), _35reg2136);
}

void _35clofun3025(struct Cora* co) {
Obj _35val2137 = co->args[1];
Obj next = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 1];
if (True == _35val2137) {
pushCont(co, 0, _35clofun3026, 2, next, exp);
coraCall(co, 2, globalRef(intern("caar")), exp);
} else {
if (True == False) {
coraCall(co, 3, globalRef(intern("cora/lib/toc.wrap-var")), exp, next);
} else {
Obj _35reg2164 = primEQ(next, globalRef(intern("cora/lib/toc.id")));
if (True == _35reg2164) {
Obj _35reg2165 = primCons(exp, Nil);
Obj _35reg2166 = primCons(intern("tailcall"), _35reg2165);
coraReturn(co, _35reg2166);
return;
} else {
Obj _35reg2167 = primGenSym(intern("val"));
Obj val = _35reg2167;
Obj _35reg2168 = primCons(val, Nil);
pushCont(co, 0, _35clofun3029, 2, _35reg2168, exp);
coraCall(co, 2, next, val);
}
}
}
}

void _35clofun3029(struct Cora* co) {
Obj _35val2169 = co->args[1];
Obj _35reg2168 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2170 = primCons(_35val2169, Nil);
Obj _35reg2171 = primCons(_35reg2168, _35reg2170);
Obj _35reg2172 = primCons(intern("continuation"), _35reg2171);
Obj _35reg2173 = primCons(_35reg2172, Nil);
Obj _35reg2174 = primCons(exp, _35reg2173);
Obj _35reg2175 = primCons(intern("call"), _35reg2174);
coraReturn(co, _35reg2175);
return;
}

void _35clofun3026(struct Cora* co) {
Obj _35val2138 = co->args[1];
Obj next = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2139 = primEQ(_35val2138, intern("%builtin"));
if (True == _35reg2139) {
if (True == True) {
coraCall(co, 3, globalRef(intern("cora/lib/toc.wrap-var")), exp, next);
} else {
Obj _35reg2140 = primEQ(next, globalRef(intern("cora/lib/toc.id")));
if (True == _35reg2140) {
Obj _35reg2141 = primCons(exp, Nil);
Obj _35reg2142 = primCons(intern("tailcall"), _35reg2141);
coraReturn(co, _35reg2142);
return;
} else {
Obj _35reg2143 = primGenSym(intern("val"));
Obj val = _35reg2143;
Obj _35reg2144 = primCons(val, Nil);
pushCont(co, 0, _35clofun3027, 2, _35reg2144, exp);
coraCall(co, 2, next, val);
}
}
} else {
if (True == False) {
coraCall(co, 3, globalRef(intern("cora/lib/toc.wrap-var")), exp, next);
} else {
Obj _35reg2152 = primEQ(next, globalRef(intern("cora/lib/toc.id")));
if (True == _35reg2152) {
Obj _35reg2153 = primCons(exp, Nil);
Obj _35reg2154 = primCons(intern("tailcall"), _35reg2153);
coraReturn(co, _35reg2154);
return;
} else {
Obj _35reg2155 = primGenSym(intern("val"));
Obj val = _35reg2155;
Obj _35reg2156 = primCons(val, Nil);
pushCont(co, 0, _35clofun3028, 2, _35reg2156, exp);
coraCall(co, 2, next, val);
}
}
}
}

void _35clofun3028(struct Cora* co) {
Obj _35val2157 = co->args[1];
Obj _35reg2156 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2158 = primCons(_35val2157, Nil);
Obj _35reg2159 = primCons(_35reg2156, _35reg2158);
Obj _35reg2160 = primCons(intern("continuation"), _35reg2159);
Obj _35reg2161 = primCons(_35reg2160, Nil);
Obj _35reg2162 = primCons(exp, _35reg2161);
Obj _35reg2163 = primCons(intern("call"), _35reg2162);
coraReturn(co, _35reg2163);
return;
}

void _35clofun3027(struct Cora* co) {
Obj _35val2145 = co->args[1];
Obj _35reg2144 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj exp = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2146 = primCons(_35val2145, Nil);
Obj _35reg2147 = primCons(_35reg2144, _35reg2146);
Obj _35reg2148 = primCons(intern("continuation"), _35reg2147);
Obj _35reg2149 = primCons(_35reg2148, Nil);
Obj _35reg2150 = primCons(exp, _35reg2149);
Obj _35reg2151 = primCons(intern("call"), _35reg2150);
coraReturn(co, _35reg2151);
return;
}

void _35clofun3021(struct Cora* co) {
Obj _35cc1307 = makeNative(0, _35clofun3022, 0, 0);
Obj _35reg2130 = primIsCons(closureRef(co, 0));
if (True == _35reg2130) {
Obj _35reg2131 = primCar(closureRef(co, 0));
Obj hd = _35reg2131;
Obj _35reg2132 = primCdr(closureRef(co, 0));
Obj tl = _35reg2132;
Obj ls = closureRef(co, 1);
Obj next = closureRef(co, 2);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), hd, makeNative(0, _35clofun3023, 1, 3, tl, ls, next));
} else {
coraCall(co, 1, _35cc1307);
}
}

void _35clofun3023(struct Cora* co) {
Obj hd1 = co->args[1];
Obj _35reg2133 = primCons(hd1, closureRef(co, 1));
coraCall(co, 4, globalRef(intern("cora/lib/toc.tailify-list")), closureRef(co, 0), _35reg2133, closureRef(co, 2));
}

void _35clofun3022(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3002(struct Cora* co) {
Obj _35p1294 = co->args[1];
Obj _35p1295 = co->args[2];
Obj _35cc1296 = makeNative(0, _35clofun3003, 0, 2, _35p1294, _35p1295);
Obj x = _35p1294;
Obj next = _35p1295;
Obj _35reg2127 = primIsSymbol(x);
if (True == _35reg2127) {
if (True == True) {
coraCall(co, 2, next, x);
} else {
coraCall(co, 1, _35cc1296);
}
} else {
pushCont(co, 0, _35clofun3019, 3, next, x, _35cc1296);
coraCall(co, 2, globalRef(intern("cora/lib/toc.convert-protect?")), x);
}
}

void _35clofun3019(struct Cora* co) {
Obj _35val2128 = co->args[1];
Obj next = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35cc1296 = co->ctx.stk.stack[co->ctx.stk.base + 2];
if (True == _35val2128) {
if (True == True) {
coraCall(co, 2, next, x);
} else {
coraCall(co, 1, _35cc1296);
}
} else {
if (True == False) {
coraCall(co, 2, next, x);
} else {
coraCall(co, 1, _35cc1296);
}
}
}

void _35clofun3003(struct Cora* co) {
Obj _35cc1297 = makeNative(0, _35clofun3004, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj x = closureRef(co, 0);
Obj __ = closureRef(co, 1);
pushCont(co, 0, _35clofun3018, 2, x, _35cc1297);
coraCall(co, 2, globalRef(intern("cora/lib/toc.convert-protect?")), x);
}

void _35clofun3018(struct Cora* co) {
Obj _35val2126 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35cc1297 = co->ctx.stk.stack[co->ctx.stk.base + 1];
if (True == _35val2126) {
coraReturn(co, x);
return;
} else {
coraCall(co, 1, _35cc1297);
}
}

void _35clofun3004(struct Cora* co) {
Obj _35cc1298 = makeNative(0, _35clofun3005, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2094 = primIsCons(closureRef(co, 0));
if (True == _35reg2094) {
Obj _35reg2095 = primCar(closureRef(co, 0));
Obj _35reg2096 = primEQ(intern("if"), _35reg2095);
if (True == _35reg2096) {
Obj _35reg2097 = primCdr(closureRef(co, 0));
Obj _35reg2098 = primIsCons(_35reg2097);
if (True == _35reg2098) {
Obj _35reg2099 = primCdr(closureRef(co, 0));
Obj _35reg2100 = primCar(_35reg2099);
Obj a = _35reg2100;
Obj _35reg2101 = primCdr(closureRef(co, 0));
Obj _35reg2102 = primCdr(_35reg2101);
Obj _35reg2103 = primIsCons(_35reg2102);
if (True == _35reg2103) {
Obj _35reg2104 = primCdr(closureRef(co, 0));
Obj _35reg2105 = primCdr(_35reg2104);
Obj _35reg2106 = primCar(_35reg2105);
Obj b = _35reg2106;
Obj _35reg2107 = primCdr(closureRef(co, 0));
Obj _35reg2108 = primCdr(_35reg2107);
Obj _35reg2109 = primCdr(_35reg2108);
Obj _35reg2110 = primIsCons(_35reg2109);
if (True == _35reg2110) {
Obj _35reg2111 = primCdr(closureRef(co, 0));
Obj _35reg2112 = primCdr(_35reg2111);
Obj _35reg2113 = primCdr(_35reg2112);
Obj _35reg2114 = primCar(_35reg2113);
Obj c = _35reg2114;
Obj _35reg2115 = primCdr(closureRef(co, 0));
Obj _35reg2116 = primCdr(_35reg2115);
Obj _35reg2117 = primCdr(_35reg2116);
Obj _35reg2118 = primCdr(_35reg2117);
Obj _35reg2119 = primEQ(Nil, _35reg2118);
if (True == _35reg2119) {
Obj next = closureRef(co, 1);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), a, makeNative(0, _35clofun3015, 1, 3, b, c, next));
} else {
coraCall(co, 1, _35cc1298);
}
} else {
coraCall(co, 1, _35cc1298);
}
} else {
coraCall(co, 1, _35cc1298);
}
} else {
coraCall(co, 1, _35cc1298);
}
} else {
coraCall(co, 1, _35cc1298);
}
} else {
coraCall(co, 1, _35cc1298);
}
}

void _35clofun3015(struct Cora* co) {
Obj ra = co->args[1];
pushCont(co, 0, _35clofun3016, 1, ra);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), closureRef(co, 0), closureRef(co, 2));
}

void _35clofun3016(struct Cora* co) {
Obj _35val2120 = co->args[1];
Obj ra = co->ctx.stk.stack[co->ctx.stk.base + 0];
pushCont(co, 0, _35clofun3017, 2, _35val2120, ra);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), closureRef(co, 1), closureRef(co, 2));
}

void _35clofun3017(struct Cora* co) {
Obj _35val2121 = co->args[1];
Obj _35val2120 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj ra = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg2122 = primCons(_35val2121, Nil);
Obj _35reg2123 = primCons(_35val2120, _35reg2122);
Obj _35reg2124 = primCons(ra, _35reg2123);
Obj _35reg2125 = primCons(intern("if"), _35reg2124);
coraReturn(co, _35reg2125);
return;
}

void _35clofun3005(struct Cora* co) {
Obj _35cc1299 = makeNative(0, _35clofun3006, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2072 = primIsCons(closureRef(co, 0));
if (True == _35reg2072) {
Obj _35reg2073 = primCar(closureRef(co, 0));
Obj _35reg2074 = primEQ(intern("do"), _35reg2073);
if (True == _35reg2074) {
Obj _35reg2075 = primCdr(closureRef(co, 0));
Obj _35reg2076 = primIsCons(_35reg2075);
if (True == _35reg2076) {
Obj _35reg2077 = primCdr(closureRef(co, 0));
Obj _35reg2078 = primCar(_35reg2077);
Obj a = _35reg2078;
Obj _35reg2079 = primCdr(closureRef(co, 0));
Obj _35reg2080 = primCdr(_35reg2079);
Obj _35reg2081 = primIsCons(_35reg2080);
if (True == _35reg2081) {
Obj _35reg2082 = primCdr(closureRef(co, 0));
Obj _35reg2083 = primCdr(_35reg2082);
Obj _35reg2084 = primCar(_35reg2083);
Obj b = _35reg2084;
Obj _35reg2085 = primCdr(closureRef(co, 0));
Obj _35reg2086 = primCdr(_35reg2085);
Obj _35reg2087 = primCdr(_35reg2086);
Obj _35reg2088 = primEQ(Nil, _35reg2087);
if (True == _35reg2088) {
Obj next = closureRef(co, 1);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), a, makeNative(0, _35clofun3013, 1, 2, b, next));
} else {
coraCall(co, 1, _35cc1299);
}
} else {
coraCall(co, 1, _35cc1299);
}
} else {
coraCall(co, 1, _35cc1299);
}
} else {
coraCall(co, 1, _35cc1299);
}
} else {
coraCall(co, 1, _35cc1299);
}
}

void _35clofun3013(struct Cora* co) {
Obj ra = co->args[1];
Obj _35reg2089 = primIsSymbol(ra);
if (True == _35reg2089) {
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), closureRef(co, 0), closureRef(co, 1));
} else {
pushCont(co, 0, _35clofun3014, 1, ra);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), closureRef(co, 0), closureRef(co, 1));
}
}

void _35clofun3014(struct Cora* co) {
Obj _35val2090 = co->args[1];
Obj ra = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2091 = primCons(_35val2090, Nil);
Obj _35reg2092 = primCons(ra, _35reg2091);
Obj _35reg2093 = primCons(intern("do"), _35reg2092);
coraReturn(co, _35reg2093);
return;
}

void _35clofun3006(struct Cora* co) {
Obj _35cc1300 = makeNative(0, _35clofun3007, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2041 = primIsCons(closureRef(co, 0));
if (True == _35reg2041) {
Obj _35reg2042 = primCar(closureRef(co, 0));
Obj _35reg2043 = primEQ(intern("let"), _35reg2042);
if (True == _35reg2043) {
Obj _35reg2044 = primCdr(closureRef(co, 0));
Obj _35reg2045 = primIsCons(_35reg2044);
if (True == _35reg2045) {
Obj _35reg2046 = primCdr(closureRef(co, 0));
Obj _35reg2047 = primCar(_35reg2046);
Obj a = _35reg2047;
Obj _35reg2048 = primCdr(closureRef(co, 0));
Obj _35reg2049 = primCdr(_35reg2048);
Obj _35reg2050 = primIsCons(_35reg2049);
if (True == _35reg2050) {
Obj _35reg2051 = primCdr(closureRef(co, 0));
Obj _35reg2052 = primCdr(_35reg2051);
Obj _35reg2053 = primCar(_35reg2052);
Obj b = _35reg2053;
Obj _35reg2054 = primCdr(closureRef(co, 0));
Obj _35reg2055 = primCdr(_35reg2054);
Obj _35reg2056 = primCdr(_35reg2055);
Obj _35reg2057 = primIsCons(_35reg2056);
if (True == _35reg2057) {
Obj _35reg2058 = primCdr(closureRef(co, 0));
Obj _35reg2059 = primCdr(_35reg2058);
Obj _35reg2060 = primCdr(_35reg2059);
Obj _35reg2061 = primCar(_35reg2060);
Obj c = _35reg2061;
Obj _35reg2062 = primCdr(closureRef(co, 0));
Obj _35reg2063 = primCdr(_35reg2062);
Obj _35reg2064 = primCdr(_35reg2063);
Obj _35reg2065 = primCdr(_35reg2064);
Obj _35reg2066 = primEQ(Nil, _35reg2065);
if (True == _35reg2066) {
Obj next = closureRef(co, 1);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), b, makeNative(0, _35clofun3011, 1, 3, a, c, next));
} else {
coraCall(co, 1, _35cc1300);
}
} else {
coraCall(co, 1, _35cc1300);
}
} else {
coraCall(co, 1, _35cc1300);
}
} else {
coraCall(co, 1, _35cc1300);
}
} else {
coraCall(co, 1, _35cc1300);
}
} else {
coraCall(co, 1, _35cc1300);
}
}

void _35clofun3011(struct Cora* co) {
Obj rb = co->args[1];
pushCont(co, 0, _35clofun3012, 1, rb);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), closureRef(co, 1), closureRef(co, 2));
}

void _35clofun3012(struct Cora* co) {
Obj _35val2067 = co->args[1];
Obj rb = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg2068 = primCons(_35val2067, Nil);
Obj _35reg2069 = primCons(rb, _35reg2068);
Obj _35reg2070 = primCons(closureRef(co, 0), _35reg2069);
Obj _35reg2071 = primCons(intern("let"), _35reg2070);
coraReturn(co, _35reg2071);
return;
}

void _35clofun3007(struct Cora* co) {
Obj _35cc1301 = makeNative(0, _35clofun3008, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1997 = primIsCons(closureRef(co, 0));
if (True == _35reg1997) {
Obj _35reg1998 = primCar(closureRef(co, 0));
Obj _35reg1999 = primEQ(intern("%closure"), _35reg1998);
if (True == _35reg1999) {
Obj _35reg2000 = primCdr(closureRef(co, 0));
Obj _35reg2001 = primIsCons(_35reg2000);
if (True == _35reg2001) {
Obj _35reg2002 = primCdr(closureRef(co, 0));
Obj _35reg2003 = primCar(_35reg2002);
Obj _35reg2004 = primIsCons(_35reg2003);
if (True == _35reg2004) {
Obj _35reg2005 = primCdr(closureRef(co, 0));
Obj _35reg2006 = primCar(_35reg2005);
Obj _35reg2007 = primCar(_35reg2006);
Obj _35reg2008 = primEQ(intern("lambda"), _35reg2007);
if (True == _35reg2008) {
Obj _35reg2009 = primCdr(closureRef(co, 0));
Obj _35reg2010 = primCar(_35reg2009);
Obj _35reg2011 = primCdr(_35reg2010);
Obj _35reg2012 = primIsCons(_35reg2011);
if (True == _35reg2012) {
Obj _35reg2013 = primCdr(closureRef(co, 0));
Obj _35reg2014 = primCar(_35reg2013);
Obj _35reg2015 = primCdr(_35reg2014);
Obj _35reg2016 = primCar(_35reg2015);
Obj args = _35reg2016;
Obj _35reg2017 = primCdr(closureRef(co, 0));
Obj _35reg2018 = primCar(_35reg2017);
Obj _35reg2019 = primCdr(_35reg2018);
Obj _35reg2020 = primCdr(_35reg2019);
Obj _35reg2021 = primIsCons(_35reg2020);
if (True == _35reg2021) {
Obj _35reg2022 = primCdr(closureRef(co, 0));
Obj _35reg2023 = primCar(_35reg2022);
Obj _35reg2024 = primCdr(_35reg2023);
Obj _35reg2025 = primCdr(_35reg2024);
Obj _35reg2026 = primCar(_35reg2025);
Obj body = _35reg2026;
Obj _35reg2027 = primCdr(closureRef(co, 0));
Obj _35reg2028 = primCar(_35reg2027);
Obj _35reg2029 = primCdr(_35reg2028);
Obj _35reg2030 = primCdr(_35reg2029);
Obj _35reg2031 = primCdr(_35reg2030);
Obj _35reg2032 = primEQ(Nil, _35reg2031);
if (True == _35reg2032) {
Obj _35reg2033 = primCdr(closureRef(co, 0));
Obj _35reg2034 = primCdr(_35reg2033);
Obj frees = _35reg2034;
Obj next = closureRef(co, 1);
pushCont(co, 0, _35clofun3010, 3, args, frees, next);
coraCall(co, 3, globalRef(intern("cora/lib/toc.tailify")), body, globalRef(intern("cora/lib/toc.id")));
} else {
coraCall(co, 1, _35cc1301);
}
} else {
coraCall(co, 1, _35cc1301);
}
} else {
coraCall(co, 1, _35cc1301);
}
} else {
coraCall(co, 1, _35cc1301);
}
} else {
coraCall(co, 1, _35cc1301);
}
} else {
coraCall(co, 1, _35cc1301);
}
} else {
coraCall(co, 1, _35cc1301);
}
} else {
coraCall(co, 1, _35cc1301);
}
}

void _35clofun3010(struct Cora* co) {
Obj _35val2035 = co->args[1];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj frees = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj next = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj _35reg2036 = primCons(_35val2035, Nil);
Obj _35reg2037 = primCons(args, _35reg2036);
Obj _35reg2038 = primCons(intern("lambda"), _35reg2037);
Obj _35reg2039 = primCons(_35reg2038, frees);
Obj _35reg2040 = primCons(intern("%closure"), _35reg2039);
coraCall(co, 2, next, _35reg2040);
}

void _35clofun3008(struct Cora* co) {
Obj _35cc1302 = makeNative(0, _35clofun3009, 0, 0);
Obj _35reg1993 = primIsCons(closureRef(co, 0));
if (True == _35reg1993) {
Obj _35reg1994 = primCar(closureRef(co, 0));
Obj f = _35reg1994;
Obj _35reg1995 = primCdr(closureRef(co, 0));
Obj args = _35reg1995;
Obj next = closureRef(co, 1);
Obj _35reg1996 = primCons(f, args);
coraCall(co, 4, globalRef(intern("cora/lib/toc.tailify-list")), _35reg1996, Nil, next);
} else {
coraCall(co, 1, _35cc1302);
}
}

void _35clofun3009(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun3001(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg1990 = primCons(x, Nil);
Obj _35reg1991 = primCons(intern("return"), _35reg1990);
coraReturn(co, _35reg1991);
return;
}

void _35clofun2986(struct Cora* co) {
Obj _35p1287 = co->args[1];
Obj _35p1288 = co->args[2];
Obj _35cc1289 = makeNative(0, _35clofun2987, 0, 2, _35p1287, _35p1288);
Obj __ = _35p1287;
Obj x = _35p1288;
pushCont(co, 0, _35clofun3000, 2, x, _35cc1289);
coraCall(co, 2, globalRef(intern("cora/lib/toc.convert-protect?")), x);
}

void _35clofun3000(struct Cora* co) {
Obj _35val1988 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35cc1289 = co->ctx.stk.stack[co->ctx.stk.base + 1];
if (True == _35val1988) {
coraReturn(co, x);
return;
} else {
coraCall(co, 1, _35cc1289);
}
}

void _35clofun2987(struct Cora* co) {
Obj _35cc1290 = makeNative(0, _35clofun2988, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj var = closureRef(co, 1);
Obj _35reg1983 = primIsSymbol(var);
if (True == _35reg1983) {
pushCont(co, 0, _35clofun2999, 1, var);
coraCall(co, 3, globalRef(intern("cora/lib/toc.index")), var, fvs);
} else {
coraCall(co, 1, _35cc1290);
}
}

void _35clofun2999(struct Cora* co) {
Obj _35val1984 = co->args[1];
Obj var = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj pos = _35val1984;
Obj _35reg1985 = primEQ(makeNumber(-1), pos);
if (True == _35reg1985) {
coraReturn(co, var);
return;
} else {
Obj _35reg1986 = primCons(pos, Nil);
Obj _35reg1987 = primCons(intern("%closure-ref"), _35reg1986);
coraReturn(co, _35reg1987);
return;
}
}

void _35clofun2988(struct Cora* co) {
Obj _35cc1291 = makeNative(0, _35clofun2989, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg1954 = primIsCons(closureRef(co, 1));
if (True == _35reg1954) {
Obj _35reg1955 = primCar(closureRef(co, 1));
Obj _35reg1956 = primEQ(intern("lambda"), _35reg1955);
if (True == _35reg1956) {
Obj _35reg1957 = primCdr(closureRef(co, 1));
Obj _35reg1958 = primIsCons(_35reg1957);
if (True == _35reg1958) {
Obj _35reg1959 = primCdr(closureRef(co, 1));
Obj _35reg1960 = primCar(_35reg1959);
Obj args = _35reg1960;
Obj _35reg1961 = primCdr(closureRef(co, 1));
Obj _35reg1962 = primCdr(_35reg1961);
Obj _35reg1963 = primIsCons(_35reg1962);
if (True == _35reg1963) {
Obj _35reg1964 = primCdr(closureRef(co, 1));
Obj _35reg1965 = primCdr(_35reg1964);
Obj _35reg1966 = primCar(_35reg1965);
Obj body = _35reg1966;
Obj _35reg1967 = primCdr(closureRef(co, 1));
Obj _35reg1968 = primCdr(_35reg1967);
Obj _35reg1969 = primCdr(_35reg1968);
Obj _35reg1970 = primEQ(Nil, _35reg1969);
if (True == _35reg1970) {
Obj _35reg1971 = primCons(body, Nil);
Obj _35reg1972 = primCons(args, _35reg1971);
Obj _35reg1973 = primCons(intern("lambda"), _35reg1972);
pushCont(co, 0, _35clofun2995, 3, body, args, fvs);
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), _35reg1973);
} else {
coraCall(co, 1, _35cc1291);
}
} else {
coraCall(co, 1, _35cc1291);
}
} else {
coraCall(co, 1, _35cc1291);
}
} else {
coraCall(co, 1, _35cc1291);
}
} else {
coraCall(co, 1, _35cc1291);
}
}

void _35clofun2995(struct Cora* co) {
Obj _35val1974 = co->args[1];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj fvs = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj fvs1 = _35val1974;
pushCont(co, 0, _35clofun2996, 3, args, fvs, fvs1);
coraCall(co, 3, globalRef(intern("cora/lib/toc.closure-convert")), fvs1, body);
}

void _35clofun2996(struct Cora* co) {
Obj _35val1975 = co->args[1];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj fvs = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj fvs1 = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj _35reg1976 = primCons(_35val1975, Nil);
Obj _35reg1977 = primCons(args, _35reg1976);
Obj _35reg1978 = primCons(intern("lambda"), _35reg1977);
pushCont(co, 0, _35clofun2997, 2, fvs1, _35reg1978);
coraCall(co, 2, globalRef(intern("cora/lib/toc.closure-convert")), fvs);
}

void _35clofun2997(struct Cora* co) {
Obj _35val1979 = co->args[1];
Obj fvs1 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg1978 = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun2998, 1, _35reg1978);
coraCall(co, 3, globalRef(intern("map")), _35val1979, fvs1);
}

void _35clofun2998(struct Cora* co) {
Obj _35val1980 = co->args[1];
Obj _35reg1978 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg1981 = primCons(_35reg1978, _35val1980);
Obj _35reg1982 = primCons(intern("%closure"), _35reg1981);
coraReturn(co, _35reg1982);
return;
}

void _35clofun2989(struct Cora* co) {
Obj _35cc1292 = makeNative(0, _35clofun2990, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg1922 = primIsCons(closureRef(co, 1));
if (True == _35reg1922) {
Obj _35reg1923 = primCar(closureRef(co, 1));
Obj _35reg1924 = primEQ(intern("let"), _35reg1923);
if (True == _35reg1924) {
Obj _35reg1925 = primCdr(closureRef(co, 1));
Obj _35reg1926 = primIsCons(_35reg1925);
if (True == _35reg1926) {
Obj _35reg1927 = primCdr(closureRef(co, 1));
Obj _35reg1928 = primCar(_35reg1927);
Obj a = _35reg1928;
Obj _35reg1929 = primCdr(closureRef(co, 1));
Obj _35reg1930 = primCdr(_35reg1929);
Obj _35reg1931 = primIsCons(_35reg1930);
if (True == _35reg1931) {
Obj _35reg1932 = primCdr(closureRef(co, 1));
Obj _35reg1933 = primCdr(_35reg1932);
Obj _35reg1934 = primCar(_35reg1933);
Obj b = _35reg1934;
Obj _35reg1935 = primCdr(closureRef(co, 1));
Obj _35reg1936 = primCdr(_35reg1935);
Obj _35reg1937 = primCdr(_35reg1936);
Obj _35reg1938 = primIsCons(_35reg1937);
if (True == _35reg1938) {
Obj _35reg1939 = primCdr(closureRef(co, 1));
Obj _35reg1940 = primCdr(_35reg1939);
Obj _35reg1941 = primCdr(_35reg1940);
Obj _35reg1942 = primCar(_35reg1941);
Obj c = _35reg1942;
Obj _35reg1943 = primCdr(closureRef(co, 1));
Obj _35reg1944 = primCdr(_35reg1943);
Obj _35reg1945 = primCdr(_35reg1944);
Obj _35reg1946 = primCdr(_35reg1945);
Obj _35reg1947 = primEQ(Nil, _35reg1946);
if (True == _35reg1947) {
pushCont(co, 0, _35clofun2993, 3, fvs, c, a);
coraCall(co, 3, globalRef(intern("cora/lib/toc.closure-convert")), fvs, b);
} else {
coraCall(co, 1, _35cc1292);
}
} else {
coraCall(co, 1, _35cc1292);
}
} else {
coraCall(co, 1, _35cc1292);
}
} else {
coraCall(co, 1, _35cc1292);
}
} else {
coraCall(co, 1, _35cc1292);
}
} else {
coraCall(co, 1, _35cc1292);
}
}

void _35clofun2993(struct Cora* co) {
Obj _35val1948 = co->args[1];
Obj fvs = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 2];
pushCont(co, 0, _35clofun2994, 2, _35val1948, a);
coraCall(co, 3, globalRef(intern("cora/lib/toc.closure-convert")), fvs, c);
}

void _35clofun2994(struct Cora* co) {
Obj _35val1949 = co->args[1];
Obj _35val1948 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg1950 = primCons(_35val1949, Nil);
Obj _35reg1951 = primCons(_35val1948, _35reg1950);
Obj _35reg1952 = primCons(a, _35reg1951);
Obj _35reg1953 = primCons(intern("let"), _35reg1952);
coraReturn(co, _35reg1953);
return;
}

void _35clofun2990(struct Cora* co) {
Obj _35cc1293 = makeNative(0, _35clofun2991, 0, 0);
Obj fvs = closureRef(co, 0);
Obj _35reg1917 = primIsCons(closureRef(co, 1));
if (True == _35reg1917) {
Obj _35reg1918 = primCar(closureRef(co, 1));
Obj f = _35reg1918;
Obj _35reg1919 = primCdr(closureRef(co, 1));
Obj args = _35reg1919;
pushCont(co, 0, _35clofun2992, 2, f, args);
coraCall(co, 2, globalRef(intern("cora/lib/toc.closure-convert")), fvs);
} else {
coraCall(co, 1, _35cc1293);
}
}

void _35clofun2992(struct Cora* co) {
Obj _35val1920 = co->args[1];
Obj f = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg1921 = primCons(f, args);
coraCall(co, 3, globalRef(intern("map")), _35val1920, _35reg1921);
}

void _35clofun2991(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2963(struct Cora* co) {
Obj _35p1274 = co->args[1];
Obj _35cc1275 = makeNative(0, _35clofun2964, 0, 1, _35p1274);
Obj x = _35p1274;
pushCont(co, 0, _35clofun2985, 1, _35cc1275);
coraCall(co, 2, globalRef(intern("cora/lib/toc.convert-protect?")), x);
}

void _35clofun2985(struct Cora* co) {
Obj _35val1915 = co->args[1];
Obj _35cc1275 = co->ctx.stk.stack[co->ctx.stk.base + 0];
if (True == _35val1915) {
coraReturn(co, Nil);
return;
} else {
coraCall(co, 1, _35cc1275);
}
}

void _35clofun2964(struct Cora* co) {
Obj _35cc1276 = makeNative(0, _35clofun2965, 0, 1, closureRef(co, 0));
Obj x = closureRef(co, 0);
Obj _35reg1913 = primIsSymbol(x);
if (True == _35reg1913) {
Obj _35reg1914 = primCons(x, Nil);
coraReturn(co, _35reg1914);
return;
} else {
coraCall(co, 1, _35cc1276);
}
}

void _35clofun2965(struct Cora* co) {
Obj _35cc1277 = makeNative(0, _35clofun2966, 0, 1, closureRef(co, 0));
Obj _35reg1895 = primIsCons(closureRef(co, 0));
if (True == _35reg1895) {
Obj _35reg1896 = primCar(closureRef(co, 0));
Obj _35reg1897 = primEQ(intern("lambda"), _35reg1896);
if (True == _35reg1897) {
Obj _35reg1898 = primCdr(closureRef(co, 0));
Obj _35reg1899 = primIsCons(_35reg1898);
if (True == _35reg1899) {
Obj _35reg1900 = primCdr(closureRef(co, 0));
Obj _35reg1901 = primCar(_35reg1900);
Obj args = _35reg1901;
Obj _35reg1902 = primCdr(closureRef(co, 0));
Obj _35reg1903 = primCdr(_35reg1902);
Obj _35reg1904 = primIsCons(_35reg1903);
if (True == _35reg1904) {
Obj _35reg1905 = primCdr(closureRef(co, 0));
Obj _35reg1906 = primCdr(_35reg1905);
Obj _35reg1907 = primCar(_35reg1906);
Obj body = _35reg1907;
Obj _35reg1908 = primCdr(closureRef(co, 0));
Obj _35reg1909 = primCdr(_35reg1908);
Obj _35reg1910 = primCdr(_35reg1909);
Obj _35reg1911 = primEQ(Nil, _35reg1910);
if (True == _35reg1911) {
pushCont(co, 0, _35clofun2984, 1, args);
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), body);
} else {
coraCall(co, 1, _35cc1277);
}
} else {
coraCall(co, 1, _35cc1277);
}
} else {
coraCall(co, 1, _35cc1277);
}
} else {
coraCall(co, 1, _35cc1277);
}
} else {
coraCall(co, 1, _35cc1277);
}
}

void _35clofun2984(struct Cora* co) {
Obj _35val1912 = co->args[1];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc.diff")), _35val1912, args);
}

void _35clofun2966(struct Cora* co) {
Obj _35cc1278 = makeNative(0, _35clofun2967, 0, 1, closureRef(co, 0));
Obj _35reg1865 = primIsCons(closureRef(co, 0));
if (True == _35reg1865) {
Obj _35reg1866 = primCar(closureRef(co, 0));
Obj _35reg1867 = primEQ(intern("if"), _35reg1866);
if (True == _35reg1867) {
Obj _35reg1868 = primCdr(closureRef(co, 0));
Obj _35reg1869 = primIsCons(_35reg1868);
if (True == _35reg1869) {
Obj _35reg1870 = primCdr(closureRef(co, 0));
Obj _35reg1871 = primCar(_35reg1870);
Obj x = _35reg1871;
Obj _35reg1872 = primCdr(closureRef(co, 0));
Obj _35reg1873 = primCdr(_35reg1872);
Obj _35reg1874 = primIsCons(_35reg1873);
if (True == _35reg1874) {
Obj _35reg1875 = primCdr(closureRef(co, 0));
Obj _35reg1876 = primCdr(_35reg1875);
Obj _35reg1877 = primCar(_35reg1876);
Obj y = _35reg1877;
Obj _35reg1878 = primCdr(closureRef(co, 0));
Obj _35reg1879 = primCdr(_35reg1878);
Obj _35reg1880 = primCdr(_35reg1879);
Obj _35reg1881 = primIsCons(_35reg1880);
if (True == _35reg1881) {
Obj _35reg1882 = primCdr(closureRef(co, 0));
Obj _35reg1883 = primCdr(_35reg1882);
Obj _35reg1884 = primCdr(_35reg1883);
Obj _35reg1885 = primCar(_35reg1884);
Obj z = _35reg1885;
Obj _35reg1886 = primCdr(closureRef(co, 0));
Obj _35reg1887 = primCdr(_35reg1886);
Obj _35reg1888 = primCdr(_35reg1887);
Obj _35reg1889 = primCdr(_35reg1888);
Obj _35reg1890 = primEQ(Nil, _35reg1889);
if (True == _35reg1890) {
Obj _35reg1891 = primCons(z, Nil);
Obj _35reg1892 = primCons(y, _35reg1891);
Obj _35reg1893 = primCons(x, _35reg1892);
pushCont(co, 0, _35clofun2983, 0);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.free-vars")), _35reg1893);
} else {
coraCall(co, 1, _35cc1278);
}
} else {
coraCall(co, 1, _35cc1278);
}
} else {
coraCall(co, 1, _35cc1278);
}
} else {
coraCall(co, 1, _35cc1278);
}
} else {
coraCall(co, 1, _35cc1278);
}
} else {
coraCall(co, 1, _35cc1278);
}
}

void _35clofun2983(struct Cora* co) {
Obj _35val1894 = co->args[1];
coraCall(co, 4, globalRef(intern("cora/lib/toc.foldl")), globalRef(intern("cora/lib/toc.union")), Nil, _35val1894);
}

void _35clofun2967(struct Cora* co) {
Obj _35cc1279 = makeNative(0, _35clofun2968, 0, 1, closureRef(co, 0));
Obj _35reg1845 = primIsCons(closureRef(co, 0));
if (True == _35reg1845) {
Obj _35reg1846 = primCar(closureRef(co, 0));
Obj _35reg1847 = primEQ(intern("do"), _35reg1846);
if (True == _35reg1847) {
Obj _35reg1848 = primCdr(closureRef(co, 0));
Obj _35reg1849 = primIsCons(_35reg1848);
if (True == _35reg1849) {
Obj _35reg1850 = primCdr(closureRef(co, 0));
Obj _35reg1851 = primCar(_35reg1850);
Obj x = _35reg1851;
Obj _35reg1852 = primCdr(closureRef(co, 0));
Obj _35reg1853 = primCdr(_35reg1852);
Obj _35reg1854 = primIsCons(_35reg1853);
if (True == _35reg1854) {
Obj _35reg1855 = primCdr(closureRef(co, 0));
Obj _35reg1856 = primCdr(_35reg1855);
Obj _35reg1857 = primCar(_35reg1856);
Obj y = _35reg1857;
Obj _35reg1858 = primCdr(closureRef(co, 0));
Obj _35reg1859 = primCdr(_35reg1858);
Obj _35reg1860 = primCdr(_35reg1859);
Obj _35reg1861 = primEQ(Nil, _35reg1860);
if (True == _35reg1861) {
Obj _35reg1862 = primCons(y, Nil);
Obj _35reg1863 = primCons(x, _35reg1862);
pushCont(co, 0, _35clofun2982, 0);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.free-vars")), _35reg1863);
} else {
coraCall(co, 1, _35cc1279);
}
} else {
coraCall(co, 1, _35cc1279);
}
} else {
coraCall(co, 1, _35cc1279);
}
} else {
coraCall(co, 1, _35cc1279);
}
} else {
coraCall(co, 1, _35cc1279);
}
}

void _35clofun2982(struct Cora* co) {
Obj _35val1864 = co->args[1];
coraCall(co, 4, globalRef(intern("cora/lib/toc.foldl")), globalRef(intern("cora/lib/toc.union")), Nil, _35val1864);
}

void _35clofun2968(struct Cora* co) {
Obj _35cc1280 = makeNative(0, _35clofun2969, 0, 1, closureRef(co, 0));
Obj _35reg1815 = primIsCons(closureRef(co, 0));
if (True == _35reg1815) {
Obj _35reg1816 = primCar(closureRef(co, 0));
Obj _35reg1817 = primEQ(intern("let"), _35reg1816);
if (True == _35reg1817) {
Obj _35reg1818 = primCdr(closureRef(co, 0));
Obj _35reg1819 = primIsCons(_35reg1818);
if (True == _35reg1819) {
Obj _35reg1820 = primCdr(closureRef(co, 0));
Obj _35reg1821 = primCar(_35reg1820);
Obj a = _35reg1821;
Obj _35reg1822 = primCdr(closureRef(co, 0));
Obj _35reg1823 = primCdr(_35reg1822);
Obj _35reg1824 = primIsCons(_35reg1823);
if (True == _35reg1824) {
Obj _35reg1825 = primCdr(closureRef(co, 0));
Obj _35reg1826 = primCdr(_35reg1825);
Obj _35reg1827 = primCar(_35reg1826);
Obj b = _35reg1827;
Obj _35reg1828 = primCdr(closureRef(co, 0));
Obj _35reg1829 = primCdr(_35reg1828);
Obj _35reg1830 = primCdr(_35reg1829);
Obj _35reg1831 = primIsCons(_35reg1830);
if (True == _35reg1831) {
Obj _35reg1832 = primCdr(closureRef(co, 0));
Obj _35reg1833 = primCdr(_35reg1832);
Obj _35reg1834 = primCdr(_35reg1833);
Obj _35reg1835 = primCar(_35reg1834);
Obj c = _35reg1835;
Obj _35reg1836 = primCdr(closureRef(co, 0));
Obj _35reg1837 = primCdr(_35reg1836);
Obj _35reg1838 = primCdr(_35reg1837);
Obj _35reg1839 = primCdr(_35reg1838);
Obj _35reg1840 = primEQ(Nil, _35reg1839);
if (True == _35reg1840) {
pushCont(co, 0, _35clofun2979, 2, c, a);
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), b);
} else {
coraCall(co, 1, _35cc1280);
}
} else {
coraCall(co, 1, _35cc1280);
}
} else {
coraCall(co, 1, _35cc1280);
}
} else {
coraCall(co, 1, _35cc1280);
}
} else {
coraCall(co, 1, _35cc1280);
}
} else {
coraCall(co, 1, _35cc1280);
}
}

void _35clofun2979(struct Cora* co) {
Obj _35val1841 = co->args[1];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun2980, 2, a, _35val1841);
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), c);
}

void _35clofun2980(struct Cora* co) {
Obj _35val1842 = co->args[1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35val1841 = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg1843 = primCons(a, Nil);
pushCont(co, 0, _35clofun2981, 1, _35val1841);
coraCall(co, 3, globalRef(intern("cora/lib/toc.diff")), _35val1842, _35reg1843);
}

void _35clofun2981(struct Cora* co) {
Obj _35val1844 = co->args[1];
Obj _35val1841 = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc.union")), _35val1841, _35val1844);
}

void _35clofun2969(struct Cora* co) {
Obj _35cc1281 = makeNative(0, _35clofun2970, 0, 1, closureRef(co, 0));
Obj _35reg1805 = primIsCons(closureRef(co, 0));
if (True == _35reg1805) {
Obj _35reg1806 = primCar(closureRef(co, 0));
Obj _35reg1807 = primEQ(intern("%closure"), _35reg1806);
if (True == _35reg1807) {
Obj _35reg1808 = primCdr(closureRef(co, 0));
Obj _35reg1809 = primIsCons(_35reg1808);
if (True == _35reg1809) {
Obj _35reg1810 = primCdr(closureRef(co, 0));
Obj _35reg1811 = primCar(_35reg1810);
Obj lam = _35reg1811;
Obj _35reg1812 = primCdr(closureRef(co, 0));
Obj _35reg1813 = primCdr(_35reg1812);
Obj more = _35reg1813;
Obj _35reg1814 = primCons(lam, more);
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), _35reg1814);
} else {
coraCall(co, 1, _35cc1281);
}
} else {
coraCall(co, 1, _35cc1281);
}
} else {
coraCall(co, 1, _35cc1281);
}
}

void _35clofun2970(struct Cora* co) {
Obj _35cc1282 = makeNative(0, _35clofun2971, 0, 1, closureRef(co, 0));
Obj _35reg1795 = primIsCons(closureRef(co, 0));
if (True == _35reg1795) {
Obj _35reg1796 = primCar(closureRef(co, 0));
Obj _35reg1797 = primEQ(intern("return"), _35reg1796);
if (True == _35reg1797) {
Obj _35reg1798 = primCdr(closureRef(co, 0));
Obj _35reg1799 = primIsCons(_35reg1798);
if (True == _35reg1799) {
Obj _35reg1800 = primCdr(closureRef(co, 0));
Obj _35reg1801 = primCar(_35reg1800);
Obj x = _35reg1801;
Obj _35reg1802 = primCdr(closureRef(co, 0));
Obj _35reg1803 = primCdr(_35reg1802);
Obj _35reg1804 = primEQ(Nil, _35reg1803);
if (True == _35reg1804) {
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), x);
} else {
coraCall(co, 1, _35cc1282);
}
} else {
coraCall(co, 1, _35cc1282);
}
} else {
coraCall(co, 1, _35cc1282);
}
} else {
coraCall(co, 1, _35cc1282);
}
}

void _35clofun2971(struct Cora* co) {
Obj _35cc1283 = makeNative(0, _35clofun2972, 0, 1, closureRef(co, 0));
Obj _35reg1775 = primIsCons(closureRef(co, 0));
if (True == _35reg1775) {
Obj _35reg1776 = primCar(closureRef(co, 0));
Obj _35reg1777 = primEQ(intern("call"), _35reg1776);
if (True == _35reg1777) {
Obj _35reg1778 = primCdr(closureRef(co, 0));
Obj _35reg1779 = primIsCons(_35reg1778);
if (True == _35reg1779) {
Obj _35reg1780 = primCdr(closureRef(co, 0));
Obj _35reg1781 = primCar(_35reg1780);
Obj exp = _35reg1781;
Obj _35reg1782 = primCdr(closureRef(co, 0));
Obj _35reg1783 = primCdr(_35reg1782);
Obj _35reg1784 = primIsCons(_35reg1783);
if (True == _35reg1784) {
Obj _35reg1785 = primCdr(closureRef(co, 0));
Obj _35reg1786 = primCdr(_35reg1785);
Obj _35reg1787 = primCar(_35reg1786);
Obj cont = _35reg1787;
Obj _35reg1788 = primCdr(closureRef(co, 0));
Obj _35reg1789 = primCdr(_35reg1788);
Obj _35reg1790 = primCdr(_35reg1789);
Obj _35reg1791 = primEQ(Nil, _35reg1790);
if (True == _35reg1791) {
Obj _35reg1792 = primCons(cont, Nil);
Obj _35reg1793 = primCons(exp, _35reg1792);
pushCont(co, 0, _35clofun2978, 0);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.free-vars")), _35reg1793);
} else {
coraCall(co, 1, _35cc1283);
}
} else {
coraCall(co, 1, _35cc1283);
}
} else {
coraCall(co, 1, _35cc1283);
}
} else {
coraCall(co, 1, _35cc1283);
}
} else {
coraCall(co, 1, _35cc1283);
}
}

void _35clofun2978(struct Cora* co) {
Obj _35val1794 = co->args[1];
coraCall(co, 4, globalRef(intern("cora/lib/toc.foldl")), globalRef(intern("cora/lib/toc.union")), Nil, _35val1794);
}

void _35clofun2972(struct Cora* co) {
Obj _35cc1284 = makeNative(0, _35clofun2973, 0, 1, closureRef(co, 0));
Obj _35reg1765 = primIsCons(closureRef(co, 0));
if (True == _35reg1765) {
Obj _35reg1766 = primCar(closureRef(co, 0));
Obj _35reg1767 = primEQ(intern("tailcall"), _35reg1766);
if (True == _35reg1767) {
Obj _35reg1768 = primCdr(closureRef(co, 0));
Obj _35reg1769 = primIsCons(_35reg1768);
if (True == _35reg1769) {
Obj _35reg1770 = primCdr(closureRef(co, 0));
Obj _35reg1771 = primCar(_35reg1770);
Obj exp = _35reg1771;
Obj _35reg1772 = primCdr(closureRef(co, 0));
Obj _35reg1773 = primCdr(_35reg1772);
Obj _35reg1774 = primEQ(Nil, _35reg1773);
if (True == _35reg1774) {
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), exp);
} else {
coraCall(co, 1, _35cc1284);
}
} else {
coraCall(co, 1, _35cc1284);
}
} else {
coraCall(co, 1, _35cc1284);
}
} else {
coraCall(co, 1, _35cc1284);
}
}

void _35clofun2973(struct Cora* co) {
Obj _35cc1285 = makeNative(0, _35clofun2974, 0, 1, closureRef(co, 0));
Obj _35reg1747 = primIsCons(closureRef(co, 0));
if (True == _35reg1747) {
Obj _35reg1748 = primCar(closureRef(co, 0));
Obj _35reg1749 = primEQ(intern("continuation"), _35reg1748);
if (True == _35reg1749) {
Obj _35reg1750 = primCdr(closureRef(co, 0));
Obj _35reg1751 = primIsCons(_35reg1750);
if (True == _35reg1751) {
Obj _35reg1752 = primCdr(closureRef(co, 0));
Obj _35reg1753 = primCar(_35reg1752);
Obj arg = _35reg1753;
Obj _35reg1754 = primCdr(closureRef(co, 0));
Obj _35reg1755 = primCdr(_35reg1754);
Obj _35reg1756 = primIsCons(_35reg1755);
if (True == _35reg1756) {
Obj _35reg1757 = primCdr(closureRef(co, 0));
Obj _35reg1758 = primCdr(_35reg1757);
Obj _35reg1759 = primCar(_35reg1758);
Obj body = _35reg1759;
Obj _35reg1760 = primCdr(closureRef(co, 0));
Obj _35reg1761 = primCdr(_35reg1760);
Obj _35reg1762 = primCdr(_35reg1761);
Obj _35reg1763 = primEQ(Nil, _35reg1762);
if (True == _35reg1763) {
pushCont(co, 0, _35clofun2977, 1, arg);
coraCall(co, 2, globalRef(intern("cora/lib/toc.free-vars")), body);
} else {
coraCall(co, 1, _35cc1285);
}
} else {
coraCall(co, 1, _35cc1285);
}
} else {
coraCall(co, 1, _35cc1285);
}
} else {
coraCall(co, 1, _35cc1285);
}
} else {
coraCall(co, 1, _35cc1285);
}
}

void _35clofun2977(struct Cora* co) {
Obj _35val1764 = co->args[1];
Obj arg = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("cora/lib/toc.diff")), _35val1764, arg);
}

void _35clofun2974(struct Cora* co) {
Obj _35cc1286 = makeNative(0, _35clofun2975, 0, 0);
Obj _35reg1742 = primIsCons(closureRef(co, 0));
if (True == _35reg1742) {
Obj _35reg1743 = primCar(closureRef(co, 0));
Obj f = _35reg1743;
Obj _35reg1744 = primCdr(closureRef(co, 0));
Obj args = _35reg1744;
Obj _35reg1745 = primCons(f, args);
pushCont(co, 0, _35clofun2976, 0);
coraCall(co, 3, globalRef(intern("map")), globalRef(intern("cora/lib/toc.free-vars")), _35reg1745);
} else {
coraCall(co, 1, _35cc1286);
}
}

void _35clofun2976(struct Cora* co) {
Obj _35val1746 = co->args[1];
coraCall(co, 4, globalRef(intern("cora/lib/toc.foldl")), globalRef(intern("cora/lib/toc.union")), Nil, _35val1746);
}

void _35clofun2975(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2956(struct Cora* co) {
Obj _35p1267 = co->args[1];
Obj _35cc1268 = makeNative(0, _35clofun2957, 0, 1, _35p1267);
Obj _35reg1731 = primIsCons(_35p1267);
if (True == _35reg1731) {
Obj _35reg1732 = primCar(_35p1267);
Obj _35reg1733 = primEQ(intern("%const"), _35reg1732);
if (True == _35reg1733) {
Obj _35reg1734 = primCdr(_35p1267);
Obj _35reg1735 = primIsCons(_35reg1734);
if (True == _35reg1735) {
Obj _35reg1736 = primCdr(_35p1267);
Obj _35reg1737 = primCar(_35reg1736);
Obj x = _35reg1737;
Obj _35reg1738 = primCdr(_35p1267);
Obj _35reg1739 = primCdr(_35reg1738);
Obj _35reg1740 = primEQ(Nil, _35reg1739);
if (True == _35reg1740) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc1268);
}
} else {
coraCall(co, 1, _35cc1268);
}
} else {
coraCall(co, 1, _35cc1268);
}
} else {
coraCall(co, 1, _35cc1268);
}
}

void _35clofun2957(struct Cora* co) {
Obj _35cc1269 = makeNative(0, _35clofun2958, 0, 1, closureRef(co, 0));
Obj _35reg1721 = primIsCons(closureRef(co, 0));
if (True == _35reg1721) {
Obj _35reg1722 = primCar(closureRef(co, 0));
Obj _35reg1723 = primEQ(intern("%global"), _35reg1722);
if (True == _35reg1723) {
Obj _35reg1724 = primCdr(closureRef(co, 0));
Obj _35reg1725 = primIsCons(_35reg1724);
if (True == _35reg1725) {
Obj _35reg1726 = primCdr(closureRef(co, 0));
Obj _35reg1727 = primCar(_35reg1726);
Obj x = _35reg1727;
Obj _35reg1728 = primCdr(closureRef(co, 0));
Obj _35reg1729 = primCdr(_35reg1728);
Obj _35reg1730 = primEQ(Nil, _35reg1729);
if (True == _35reg1730) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc1269);
}
} else {
coraCall(co, 1, _35cc1269);
}
} else {
coraCall(co, 1, _35cc1269);
}
} else {
coraCall(co, 1, _35cc1269);
}
}

void _35clofun2958(struct Cora* co) {
Obj _35cc1270 = makeNative(0, _35clofun2959, 0, 1, closureRef(co, 0));
Obj _35reg1711 = primIsCons(closureRef(co, 0));
if (True == _35reg1711) {
Obj _35reg1712 = primCar(closureRef(co, 0));
Obj _35reg1713 = primEQ(intern("%builtin"), _35reg1712);
if (True == _35reg1713) {
Obj _35reg1714 = primCdr(closureRef(co, 0));
Obj _35reg1715 = primIsCons(_35reg1714);
if (True == _35reg1715) {
Obj _35reg1716 = primCdr(closureRef(co, 0));
Obj _35reg1717 = primCar(_35reg1716);
Obj op = _35reg1717;
Obj _35reg1718 = primCdr(closureRef(co, 0));
Obj _35reg1719 = primCdr(_35reg1718);
Obj _35reg1720 = primEQ(Nil, _35reg1719);
if (True == _35reg1720) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc1270);
}
} else {
coraCall(co, 1, _35cc1270);
}
} else {
coraCall(co, 1, _35cc1270);
}
} else {
coraCall(co, 1, _35cc1270);
}
}

void _35clofun2959(struct Cora* co) {
Obj _35cc1271 = makeNative(0, _35clofun2960, 0, 1, closureRef(co, 0));
Obj _35reg1701 = primIsCons(closureRef(co, 0));
if (True == _35reg1701) {
Obj _35reg1702 = primCar(closureRef(co, 0));
Obj _35reg1703 = primEQ(intern("quote"), _35reg1702);
if (True == _35reg1703) {
Obj _35reg1704 = primCdr(closureRef(co, 0));
Obj _35reg1705 = primIsCons(_35reg1704);
if (True == _35reg1705) {
Obj _35reg1706 = primCdr(closureRef(co, 0));
Obj _35reg1707 = primCar(_35reg1706);
Obj x = _35reg1707;
Obj _35reg1708 = primCdr(closureRef(co, 0));
Obj _35reg1709 = primCdr(_35reg1708);
Obj _35reg1710 = primEQ(Nil, _35reg1709);
if (True == _35reg1710) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc1271);
}
} else {
coraCall(co, 1, _35cc1271);
}
} else {
coraCall(co, 1, _35cc1271);
}
} else {
coraCall(co, 1, _35cc1271);
}
}

void _35clofun2960(struct Cora* co) {
Obj _35cc1272 = makeNative(0, _35clofun2961, 0, 1, closureRef(co, 0));
Obj _35reg1691 = primIsCons(closureRef(co, 0));
if (True == _35reg1691) {
Obj _35reg1692 = primCar(closureRef(co, 0));
Obj _35reg1693 = primEQ(intern("%closure-ref"), _35reg1692);
if (True == _35reg1693) {
Obj _35reg1694 = primCdr(closureRef(co, 0));
Obj _35reg1695 = primIsCons(_35reg1694);
if (True == _35reg1695) {
Obj _35reg1696 = primCdr(closureRef(co, 0));
Obj _35reg1697 = primCar(_35reg1696);
Obj __ = _35reg1697;
Obj _35reg1698 = primCdr(closureRef(co, 0));
Obj _35reg1699 = primCdr(_35reg1698);
Obj _35reg1700 = primEQ(Nil, _35reg1699);
if (True == _35reg1700) {
coraReturn(co, True);
return;
} else {
coraCall(co, 1, _35cc1272);
}
} else {
coraCall(co, 1, _35cc1272);
}
} else {
coraCall(co, 1, _35cc1272);
}
} else {
coraCall(co, 1, _35cc1272);
}
}

void _35clofun2961(struct Cora* co) {
Obj _35cc1273 = makeNative(0, _35clofun2962, 0, 0);
Obj x = closureRef(co, 0);
coraReturn(co, False);
return;
}

void _35clofun2962(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2950(struct Cora* co) {
Obj _35p1262 = co->args[1];
Obj _35p1263 = co->args[2];
Obj _35cc1264 = makeNative(0, _35clofun2951, 0, 2, _35p1262, _35p1263);
Obj _35reg1689 = primEQ(Nil, _35p1262);
if (True == _35reg1689) {
Obj __ = _35p1263;
coraReturn(co, Nil);
return;
} else {
coraCall(co, 1, _35cc1264);
}
}

void _35clofun2951(struct Cora* co) {
Obj _35cc1265 = makeNative(0, _35clofun2952, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1685 = primIsCons(closureRef(co, 0));
if (True == _35reg1685) {
Obj _35reg1686 = primCar(closureRef(co, 0));
Obj x = _35reg1686;
Obj _35reg1687 = primCdr(closureRef(co, 0));
Obj y = _35reg1687;
Obj s2 = closureRef(co, 1);
pushCont(co, 0, _35clofun2955, 3, y, s2, _35cc1265);
coraCall(co, 3, globalRef(intern("elem?")), x, s2);
} else {
coraCall(co, 1, _35cc1265);
}
}

void _35clofun2955(struct Cora* co) {
Obj _35val1688 = co->args[1];
Obj y = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj s2 = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35cc1265 = co->ctx.stk.stack[co->ctx.stk.base + 2];
if (True == _35val1688) {
coraCall(co, 3, globalRef(intern("cora/lib/toc.diff")), y, s2);
} else {
coraCall(co, 1, _35cc1265);
}
}

void _35clofun2952(struct Cora* co) {
Obj _35cc1266 = makeNative(0, _35clofun2953, 0, 0);
Obj _35reg1680 = primIsCons(closureRef(co, 0));
if (True == _35reg1680) {
Obj _35reg1681 = primCar(closureRef(co, 0));
Obj x = _35reg1681;
Obj _35reg1682 = primCdr(closureRef(co, 0));
Obj y = _35reg1682;
Obj s2 = closureRef(co, 1);
pushCont(co, 0, _35clofun2954, 1, x);
coraCall(co, 3, globalRef(intern("cora/lib/toc.diff")), y, s2);
} else {
coraCall(co, 1, _35cc1266);
}
}

void _35clofun2954(struct Cora* co) {
Obj _35val1683 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg1684 = primCons(x, _35val1683);
coraReturn(co, _35reg1684);
return;
}

void _35clofun2953(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2944(struct Cora* co) {
Obj _35p1257 = co->args[1];
Obj _35p1258 = co->args[2];
Obj _35cc1259 = makeNative(0, _35clofun2945, 0, 2, _35p1257, _35p1258);
Obj _35reg1678 = primEQ(Nil, _35p1257);
if (True == _35reg1678) {
Obj s2 = _35p1258;
coraReturn(co, s2);
return;
} else {
coraCall(co, 1, _35cc1259);
}
}

void _35clofun2945(struct Cora* co) {
Obj _35cc1260 = makeNative(0, _35clofun2946, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1674 = primIsCons(closureRef(co, 0));
if (True == _35reg1674) {
Obj _35reg1675 = primCar(closureRef(co, 0));
Obj x = _35reg1675;
Obj _35reg1676 = primCdr(closureRef(co, 0));
Obj y = _35reg1676;
Obj s2 = closureRef(co, 1);
pushCont(co, 0, _35clofun2949, 3, y, s2, _35cc1260);
coraCall(co, 3, globalRef(intern("elem?")), x, s2);
} else {
coraCall(co, 1, _35cc1260);
}
}

void _35clofun2949(struct Cora* co) {
Obj _35val1677 = co->args[1];
Obj y = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj s2 = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35cc1260 = co->ctx.stk.stack[co->ctx.stk.base + 2];
if (True == _35val1677) {
coraCall(co, 3, globalRef(intern("cora/lib/toc.union")), y, s2);
} else {
coraCall(co, 1, _35cc1260);
}
}

void _35clofun2946(struct Cora* co) {
Obj _35cc1261 = makeNative(0, _35clofun2947, 0, 0);
Obj _35reg1669 = primIsCons(closureRef(co, 0));
if (True == _35reg1669) {
Obj _35reg1670 = primCar(closureRef(co, 0));
Obj x = _35reg1670;
Obj _35reg1671 = primCdr(closureRef(co, 0));
Obj y = _35reg1671;
Obj s2 = closureRef(co, 1);
pushCont(co, 0, _35clofun2948, 1, x);
coraCall(co, 3, globalRef(intern("cora/lib/toc.union")), y, s2);
} else {
coraCall(co, 1, _35cc1261);
}
}

void _35clofun2948(struct Cora* co) {
Obj _35val1672 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg1673 = primCons(x, _35val1672);
coraReturn(co, _35reg1673);
return;
}

void _35clofun2947(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2914(struct Cora* co) {
Obj _35p1246 = co->args[1];
Obj _35p1247 = co->args[2];
Obj _35cc1248 = makeNative(0, _35clofun2915, 0, 2, _35p1246, _35p1247);
Obj __ = _35p1246;
Obj x = _35p1247;
pushCont(co, 0, _35clofun2941, 2, x, _35cc1248);
coraCall(co, 2, globalRef(intern("number?")), x);
}

void _35clofun2941(struct Cora* co) {
Obj _35val1654 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35cc1248 = co->ctx.stk.stack[co->ctx.stk.base + 1];
if (True == _35val1654) {
if (True == True) {
Obj _35reg1655 = primCons(x, Nil);
Obj _35reg1656 = primCons(intern("%const"), _35reg1655);
coraReturn(co, _35reg1656);
return;
} else {
coraCall(co, 1, _35cc1248);
}
} else {
Obj _35reg1657 = primIsString(x);
if (True == _35reg1657) {
if (True == True) {
Obj _35reg1658 = primCons(x, Nil);
Obj _35reg1659 = primCons(intern("%const"), _35reg1658);
coraReturn(co, _35reg1659);
return;
} else {
coraCall(co, 1, _35cc1248);
}
} else {
pushCont(co, 0, _35clofun2942, 2, x, _35cc1248);
coraCall(co, 2, globalRef(intern("boolean?")), x);
}
}
}

void _35clofun2942(struct Cora* co) {
Obj _35val1660 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35cc1248 = co->ctx.stk.stack[co->ctx.stk.base + 1];
if (True == _35val1660) {
if (True == True) {
Obj _35reg1661 = primCons(x, Nil);
Obj _35reg1662 = primCons(intern("%const"), _35reg1661);
coraReturn(co, _35reg1662);
return;
} else {
coraCall(co, 1, _35cc1248);
}
} else {
pushCont(co, 0, _35clofun2943, 2, x, _35cc1248);
coraCall(co, 2, globalRef(intern("null?")), x);
}
}

void _35clofun2943(struct Cora* co) {
Obj _35val1663 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35cc1248 = co->ctx.stk.stack[co->ctx.stk.base + 1];
if (True == _35val1663) {
if (True == True) {
Obj _35reg1664 = primCons(x, Nil);
Obj _35reg1665 = primCons(intern("%const"), _35reg1664);
coraReturn(co, _35reg1665);
return;
} else {
coraCall(co, 1, _35cc1248);
}
} else {
if (True == False) {
Obj _35reg1666 = primCons(x, Nil);
Obj _35reg1667 = primCons(intern("%const"), _35reg1666);
coraReturn(co, _35reg1667);
return;
} else {
coraCall(co, 1, _35cc1248);
}
}
}

void _35clofun2915(struct Cora* co) {
Obj _35cc1249 = makeNative(0, _35clofun2916, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj __ = closureRef(co, 0);
Obj _35reg1642 = primIsCons(closureRef(co, 1));
if (True == _35reg1642) {
Obj _35reg1643 = primCar(closureRef(co, 1));
Obj _35reg1644 = primEQ(intern("quote"), _35reg1643);
if (True == _35reg1644) {
Obj _35reg1645 = primCdr(closureRef(co, 1));
Obj _35reg1646 = primIsCons(_35reg1645);
if (True == _35reg1646) {
Obj _35reg1647 = primCdr(closureRef(co, 1));
Obj _35reg1648 = primCar(_35reg1647);
Obj x = _35reg1648;
Obj _35reg1649 = primCdr(closureRef(co, 1));
Obj _35reg1650 = primCdr(_35reg1649);
Obj _35reg1651 = primEQ(Nil, _35reg1650);
if (True == _35reg1651) {
Obj _35reg1652 = primCons(x, Nil);
Obj _35reg1653 = primCons(intern("%const"), _35reg1652);
coraReturn(co, _35reg1653);
return;
} else {
coraCall(co, 1, _35cc1249);
}
} else {
coraCall(co, 1, _35cc1249);
}
} else {
coraCall(co, 1, _35cc1249);
}
} else {
coraCall(co, 1, _35cc1249);
}
}

void _35clofun2916(struct Cora* co) {
Obj _35cc1250 = makeNative(0, _35clofun2917, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1638 = primIsSymbol(x);
if (True == _35reg1638) {
pushCont(co, 0, _35clofun2940, 1, x);
coraCall(co, 3, globalRef(intern("elem?")), x, env);
} else {
coraCall(co, 1, _35cc1250);
}
}

void _35clofun2940(struct Cora* co) {
Obj _35val1639 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
if (True == _35val1639) {
coraReturn(co, x);
return;
} else {
Obj _35reg1640 = primCons(x, Nil);
Obj _35reg1641 = primCons(intern("%global"), _35reg1640);
coraReturn(co, _35reg1641);
return;
}
}

void _35clofun2917(struct Cora* co) {
Obj _35cc1251 = makeNative(0, _35clofun2918, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1616 = primIsCons(closureRef(co, 1));
if (True == _35reg1616) {
Obj _35reg1617 = primCar(closureRef(co, 1));
Obj _35reg1618 = primEQ(intern("lambda"), _35reg1617);
if (True == _35reg1618) {
Obj _35reg1619 = primCdr(closureRef(co, 1));
Obj _35reg1620 = primIsCons(_35reg1619);
if (True == _35reg1620) {
Obj _35reg1621 = primCdr(closureRef(co, 1));
Obj _35reg1622 = primCar(_35reg1621);
Obj args = _35reg1622;
Obj _35reg1623 = primCdr(closureRef(co, 1));
Obj _35reg1624 = primCdr(_35reg1623);
Obj _35reg1625 = primIsCons(_35reg1624);
if (True == _35reg1625) {
Obj _35reg1626 = primCdr(closureRef(co, 1));
Obj _35reg1627 = primCdr(_35reg1626);
Obj _35reg1628 = primCar(_35reg1627);
Obj body = _35reg1628;
Obj _35reg1629 = primCdr(closureRef(co, 1));
Obj _35reg1630 = primCdr(_35reg1629);
Obj _35reg1631 = primCdr(_35reg1630);
Obj _35reg1632 = primEQ(Nil, _35reg1631);
if (True == _35reg1632) {
pushCont(co, 0, _35clofun2938, 2, body, args);
coraCall(co, 3, globalRef(intern("append")), args, env);
} else {
coraCall(co, 1, _35cc1251);
}
} else {
coraCall(co, 1, _35cc1251);
}
} else {
coraCall(co, 1, _35cc1251);
}
} else {
coraCall(co, 1, _35cc1251);
}
} else {
coraCall(co, 1, _35cc1251);
}
}

void _35clofun2938(struct Cora* co) {
Obj _35val1633 = co->args[1];
Obj body = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun2939, 1, args);
coraCall(co, 3, globalRef(intern("cora/lib/toc.parse")), _35val1633, body);
}

void _35clofun2939(struct Cora* co) {
Obj _35val1634 = co->args[1];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg1635 = primCons(_35val1634, Nil);
Obj _35reg1636 = primCons(args, _35reg1635);
Obj _35reg1637 = primCons(intern("lambda"), _35reg1636);
coraReturn(co, _35reg1637);
return;
}

void _35clofun2918(struct Cora* co) {
Obj _35cc1252 = makeNative(0, _35clofun2919, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1609 = primIsCons(closureRef(co, 1));
if (True == _35reg1609) {
Obj _35reg1610 = primCar(closureRef(co, 1));
Obj _35reg1611 = primEQ(intern("if"), _35reg1610);
if (True == _35reg1611) {
Obj _35reg1612 = primCdr(closureRef(co, 1));
Obj args = _35reg1612;
pushCont(co, 0, _35clofun2936, 1, args);
coraCall(co, 2, globalRef(intern("cora/lib/toc.parse")), env);
} else {
coraCall(co, 1, _35cc1252);
}
} else {
coraCall(co, 1, _35cc1252);
}
}

void _35clofun2936(struct Cora* co) {
Obj _35val1613 = co->args[1];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 0];
pushCont(co, 0, _35clofun2937, 0);
coraCall(co, 3, globalRef(intern("map")), _35val1613, args);
}

void _35clofun2937(struct Cora* co) {
Obj _35val1614 = co->args[1];
Obj _35reg1615 = primCons(intern("if"), _35val1614);
coraReturn(co, _35reg1615);
return;
}

void _35clofun2919(struct Cora* co) {
Obj _35cc1253 = makeNative(0, _35clofun2920, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1587 = primIsCons(closureRef(co, 1));
if (True == _35reg1587) {
Obj _35reg1588 = primCar(closureRef(co, 1));
Obj _35reg1589 = primEQ(intern("do"), _35reg1588);
if (True == _35reg1589) {
Obj _35reg1590 = primCdr(closureRef(co, 1));
Obj _35reg1591 = primIsCons(_35reg1590);
if (True == _35reg1591) {
Obj _35reg1592 = primCdr(closureRef(co, 1));
Obj _35reg1593 = primCar(_35reg1592);
Obj x = _35reg1593;
Obj _35reg1594 = primCdr(closureRef(co, 1));
Obj _35reg1595 = primCdr(_35reg1594);
Obj _35reg1596 = primIsCons(_35reg1595);
if (True == _35reg1596) {
Obj _35reg1597 = primCdr(closureRef(co, 1));
Obj _35reg1598 = primCdr(_35reg1597);
Obj _35reg1599 = primCar(_35reg1598);
Obj y = _35reg1599;
Obj _35reg1600 = primCdr(closureRef(co, 1));
Obj _35reg1601 = primCdr(_35reg1600);
Obj _35reg1602 = primCdr(_35reg1601);
Obj _35reg1603 = primEQ(Nil, _35reg1602);
if (True == _35reg1603) {
pushCont(co, 0, _35clofun2934, 2, env, y);
coraCall(co, 3, globalRef(intern("cora/lib/toc.parse")), env, x);
} else {
coraCall(co, 1, _35cc1253);
}
} else {
coraCall(co, 1, _35cc1253);
}
} else {
coraCall(co, 1, _35cc1253);
}
} else {
coraCall(co, 1, _35cc1253);
}
} else {
coraCall(co, 1, _35cc1253);
}
}

void _35clofun2934(struct Cora* co) {
Obj _35val1604 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj y = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun2935, 1, _35val1604);
coraCall(co, 3, globalRef(intern("cora/lib/toc.parse")), env, y);
}

void _35clofun2935(struct Cora* co) {
Obj _35val1605 = co->args[1];
Obj _35val1604 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg1606 = primCons(_35val1605, Nil);
Obj _35reg1607 = primCons(_35val1604, _35reg1606);
Obj _35reg1608 = primCons(intern("do"), _35reg1607);
coraReturn(co, _35reg1608);
return;
}

void _35clofun2920(struct Cora* co) {
Obj _35cc1254 = makeNative(0, _35clofun2921, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1554 = primIsCons(closureRef(co, 1));
if (True == _35reg1554) {
Obj _35reg1555 = primCar(closureRef(co, 1));
Obj _35reg1556 = primEQ(intern("let"), _35reg1555);
if (True == _35reg1556) {
Obj _35reg1557 = primCdr(closureRef(co, 1));
Obj _35reg1558 = primIsCons(_35reg1557);
if (True == _35reg1558) {
Obj _35reg1559 = primCdr(closureRef(co, 1));
Obj _35reg1560 = primCar(_35reg1559);
Obj a = _35reg1560;
Obj _35reg1561 = primCdr(closureRef(co, 1));
Obj _35reg1562 = primCdr(_35reg1561);
Obj _35reg1563 = primIsCons(_35reg1562);
if (True == _35reg1563) {
Obj _35reg1564 = primCdr(closureRef(co, 1));
Obj _35reg1565 = primCdr(_35reg1564);
Obj _35reg1566 = primCar(_35reg1565);
Obj b = _35reg1566;
Obj _35reg1567 = primCdr(closureRef(co, 1));
Obj _35reg1568 = primCdr(_35reg1567);
Obj _35reg1569 = primCdr(_35reg1568);
Obj _35reg1570 = primIsCons(_35reg1569);
if (True == _35reg1570) {
Obj _35reg1571 = primCdr(closureRef(co, 1));
Obj _35reg1572 = primCdr(_35reg1571);
Obj _35reg1573 = primCdr(_35reg1572);
Obj _35reg1574 = primCar(_35reg1573);
Obj c = _35reg1574;
Obj _35reg1575 = primCdr(closureRef(co, 1));
Obj _35reg1576 = primCdr(_35reg1575);
Obj _35reg1577 = primCdr(_35reg1576);
Obj _35reg1578 = primCdr(_35reg1577);
Obj _35reg1579 = primEQ(Nil, _35reg1578);
if (True == _35reg1579) {
pushCont(co, 0, _35clofun2932, 3, env, c, a);
coraCall(co, 3, globalRef(intern("cora/lib/toc.parse")), env, b);
} else {
coraCall(co, 1, _35cc1254);
}
} else {
coraCall(co, 1, _35cc1254);
}
} else {
coraCall(co, 1, _35cc1254);
}
} else {
coraCall(co, 1, _35cc1254);
}
} else {
coraCall(co, 1, _35cc1254);
}
} else {
coraCall(co, 1, _35cc1254);
}
}

void _35clofun2932(struct Cora* co) {
Obj _35val1580 = co->args[1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj c = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj _35reg1581 = primCons(a, env);
pushCont(co, 0, _35clofun2933, 2, _35val1580, a);
coraCall(co, 3, globalRef(intern("cora/lib/toc.parse")), _35reg1581, c);
}

void _35clofun2933(struct Cora* co) {
Obj _35val1582 = co->args[1];
Obj _35val1580 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj a = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg1583 = primCons(_35val1582, Nil);
Obj _35reg1584 = primCons(_35val1580, _35reg1583);
Obj _35reg1585 = primCons(a, _35reg1584);
Obj _35reg1586 = primCons(intern("let"), _35reg1585);
coraReturn(co, _35reg1586);
return;
}

void _35clofun2921(struct Cora* co) {
Obj _35cc1255 = makeNative(0, _35clofun2922, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1534 = primIsCons(closureRef(co, 1));
if (True == _35reg1534) {
Obj _35reg1535 = primCar(closureRef(co, 1));
Obj op = _35reg1535;
Obj _35reg1536 = primCdr(closureRef(co, 1));
Obj args = _35reg1536;
pushCont(co, 0, _35clofun2925, 4, op, args, env, _35cc1255);
coraCall(co, 2, globalRef(intern("builtin?")), op);
} else {
coraCall(co, 1, _35cc1255);
}
}

void _35clofun2925(struct Cora* co) {
Obj _35val1537 = co->args[1];
Obj op = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj _35cc1255 = co->ctx.stk.stack[co->ctx.stk.base + 3];
if (True == _35val1537) {
pushCont(co, 0, _35clofun2926, 3, op, args, env);
coraCall(co, 2, globalRef(intern("cora/lib/toc.builtin->args")), op);
} else {
coraCall(co, 1, _35cc1255);
}
}

void _35clofun2926(struct Cora* co) {
Obj _35val1538 = co->args[1];
Obj op = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj required = _35val1538;
pushCont(co, 0, _35clofun2927, 4, required, op, args, env);
coraCall(co, 2, globalRef(intern("length")), args);
}

void _35clofun2927(struct Cora* co) {
Obj _35val1539 = co->args[1];
Obj required = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj op = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 3];
Obj provided = _35val1539;
Obj _35reg1540 = primEQ(required, provided);
if (True == _35reg1540) {
Obj _35reg1541 = primCons(op, Nil);
Obj _35reg1542 = primCons(intern("%builtin"), _35reg1541);
pushCont(co, 0, _35clofun2928, 2, args, _35reg1542);
coraCall(co, 2, globalRef(intern("cora/lib/toc.parse")), env);
} else {
Obj _35reg1546 = primGT(required, provided);
if (True == _35reg1546) {
Obj _35reg1547 = primSub(required, provided);
pushCont(co, 0, _35clofun2930, 3, op, args, env);
coraCall(co, 3, globalRef(intern("cora/lib/toc.temp-list")), _35reg1547, Nil);
} else {
coraCall(co, 2, globalRef(intern("error")), makeString1("primitive call mismatch"));
}
}
}

void _35clofun2930(struct Cora* co) {
Obj _35val1548 = co->args[1];
Obj op = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 2];
Obj tmp = _35val1548;
Obj _35reg1549 = primCons(op, args);
pushCont(co, 0, _35clofun2931, 2, tmp, env);
coraCall(co, 3, globalRef(intern("append")), _35reg1549, tmp);
}

void _35clofun2931(struct Cora* co) {
Obj _35val1550 = co->args[1];
Obj tmp = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj env = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg1551 = primCons(_35val1550, Nil);
Obj _35reg1552 = primCons(tmp, _35reg1551);
Obj _35reg1553 = primCons(intern("lambda"), _35reg1552);
coraCall(co, 3, globalRef(intern("cora/lib/toc.parse")), env, _35reg1553);
}

void _35clofun2928(struct Cora* co) {
Obj _35val1543 = co->args[1];
Obj args = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg1542 = co->ctx.stk.stack[co->ctx.stk.base + 1];
pushCont(co, 0, _35clofun2929, 1, _35reg1542);
coraCall(co, 3, globalRef(intern("map")), _35val1543, args);
}

void _35clofun2929(struct Cora* co) {
Obj _35val1544 = co->args[1];
Obj _35reg1542 = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj _35reg1545 = primCons(_35reg1542, _35val1544);
coraReturn(co, _35reg1545);
return;
}

void _35clofun2922(struct Cora* co) {
Obj _35cc1256 = makeNative(0, _35clofun2923, 0, 0);
Obj env = closureRef(co, 0);
Obj ls = closureRef(co, 1);
pushCont(co, 0, _35clofun2924, 1, ls);
coraCall(co, 2, globalRef(intern("cora/lib/toc.parse")), env);
}

void _35clofun2924(struct Cora* co) {
Obj _35val1533 = co->args[1];
Obj ls = co->ctx.stk.stack[co->ctx.stk.base + 0];
coraCall(co, 3, globalRef(intern("map")), _35val1533, ls);
}

void _35clofun2923(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2911(struct Cora* co) {
Obj _35p1242 = co->args[1];
Obj _35p1243 = co->args[2];
Obj _35cc1244 = makeNative(0, _35clofun2912, 0, 2, _35p1242, _35p1243);
Obj _35reg1531 = primEQ(makeNumber(0), _35p1242);
if (True == _35reg1531) {
Obj res = _35p1243;
coraReturn(co, res);
return;
} else {
coraCall(co, 1, _35cc1244);
}
}

void _35clofun2912(struct Cora* co) {
Obj _35cc1245 = makeNative(0, _35clofun2913, 0, 0);
Obj n = closureRef(co, 0);
Obj res = closureRef(co, 1);
Obj _35reg1528 = primSub(n, makeNumber(1));
Obj _35reg1529 = primGenSym(intern("tmp"));
Obj _35reg1530 = primCons(_35reg1529, res);
coraCall(co, 3, globalRef(intern("cora/lib/toc.temp-list")), _35reg1528, _35reg1530);
}

void _35clofun2913(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2908(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, 0, _35clofun2909, 0);
coraCall(co, 3, globalRef(intern("cora/lib/toc.assq")), x, globalRef(intern("cora/lib/toc.*builtin-prims*")));
}

void _35clofun2909(struct Cora* co) {
Obj _35val1525 = co->args[1];
Obj find = _35val1525;
pushCont(co, 0, _35clofun2910, 1, find);
coraCall(co, 2, globalRef(intern("null?")), find);
}

void _35clofun2910(struct Cora* co) {
Obj _35val1526 = co->args[1];
Obj find = co->ctx.stk.stack[co->ctx.stk.base + 0];
if (True == _35val1526) {
coraReturn(co, makeString1("ERROR"));
return;
} else {
coraCall(co, 2, globalRef(intern("cadr")), find);
}
}

void _35clofun2905(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, 0, _35clofun2906, 0);
coraCall(co, 3, globalRef(intern("cora/lib/toc.assq")), x, globalRef(intern("cora/lib/toc.*builtin-prims*")));
}

void _35clofun2906(struct Cora* co) {
Obj _35val1522 = co->args[1];
Obj find = _35val1522;
pushCont(co, 0, _35clofun2907, 1, find);
coraCall(co, 2, globalRef(intern("null?")), find);
}

void _35clofun2907(struct Cora* co) {
Obj _35val1523 = co->args[1];
Obj find = co->ctx.stk.stack[co->ctx.stk.base + 0];
if (True == _35val1523) {
coraReturn(co, makeString1("ERROR"));
return;
} else {
coraCall(co, 2, globalRef(intern("caddr")), find);
}
}

void _35clofun2902(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, 0, _35clofun2903, 0);
coraCall(co, 3, globalRef(intern("cora/lib/toc.assq")), x, globalRef(intern("cora/lib/toc.*builtin-prims*")));
}

void _35clofun2903(struct Cora* co) {
Obj _35val1518 = co->args[1];
pushCont(co, 0, _35clofun2904, 0);
coraCall(co, 2, globalRef(intern("null?")), _35val1518);
}

void _35clofun2904(struct Cora* co) {
Obj _35val1519 = co->args[1];
Obj _35reg1520 = primNot(_35val1519);
coraReturn(co, _35reg1520);
return;
}

void _35clofun2898(struct Cora* co) {
Obj _35p1238 = co->args[1];
Obj _35p1239 = co->args[2];
Obj _35cc1240 = makeNative(0, _35clofun2899, 0, 2, _35p1238, _35p1239);
Obj x = _35p1238;
Obj _35reg1447 = primEQ(Nil, _35p1239);
if (True == _35reg1447) {
coraReturn(co, False);
return;
} else {
coraCall(co, 1, _35cc1240);
}
}

void _35clofun2899(struct Cora* co) {
Obj _35cc1241 = makeNative(0, _35clofun2900, 0, 0);
Obj x = closureRef(co, 0);
Obj _35reg1442 = primIsCons(closureRef(co, 1));
if (True == _35reg1442) {
Obj _35reg1443 = primCar(closureRef(co, 1));
Obj hd = _35reg1443;
Obj _35reg1444 = primCdr(closureRef(co, 1));
Obj tl = _35reg1444;
pushCont(co, 0, _35clofun2901, 2, x, tl);
coraCall(co, 3, globalRef(intern("cora/lib/toc.index")), x, hd);
} else {
coraCall(co, 1, _35cc1241);
}
}

void _35clofun2901(struct Cora* co) {
Obj _35val1445 = co->args[1];
Obj x = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj tl = co->ctx.stk.stack[co->ctx.stk.base + 1];
Obj _35reg1446 = primLT(_35val1445, makeNumber(0));
if (True == _35reg1446) {
coraCall(co, 3, globalRef(intern("cora/lib/toc.exist-in-env")), x, tl);
} else {
coraReturn(co, True);
return;
}
}

void _35clofun2900(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2897(struct Cora* co) {
Obj x = co->args[1];
Obj l = co->args[2];
coraCall(co, 4, globalRef(intern("cora/lib/toc.pos-in-list0")), makeNumber(0), x, l);
}

void _35clofun2893(struct Cora* co) {
Obj _35p1232 = co->args[1];
Obj _35p1233 = co->args[2];
Obj _35p1234 = co->args[3];
Obj _35cc1235 = makeNative(0, _35clofun2894, 0, 3, _35p1232, _35p1233, _35p1234);
Obj __ = _35p1232;
Obj x = _35p1233;
Obj _35reg1439 = primEQ(Nil, _35p1234);
if (True == _35reg1439) {
coraReturn(co, makeNumber(-1));
return;
} else {
coraCall(co, 1, _35cc1235);
}
}

void _35clofun2894(struct Cora* co) {
Obj _35cc1236 = makeNative(0, _35clofun2895, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj pos = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1435 = primIsCons(closureRef(co, 2));
if (True == _35reg1435) {
Obj _35reg1436 = primCar(closureRef(co, 2));
Obj a = _35reg1436;
Obj _35reg1437 = primCdr(closureRef(co, 2));
Obj b = _35reg1437;
Obj _35reg1438 = primEQ(x, a);
if (True == _35reg1438) {
coraReturn(co, pos);
return;
} else {
coraCall(co, 1, _35cc1236);
}
} else {
coraCall(co, 1, _35cc1236);
}
}

void _35clofun2895(struct Cora* co) {
Obj _35cc1237 = makeNative(0, _35clofun2896, 0, 0);
Obj pos = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1431 = primIsCons(closureRef(co, 2));
if (True == _35reg1431) {
Obj _35reg1432 = primCar(closureRef(co, 2));
Obj a = _35reg1432;
Obj _35reg1433 = primCdr(closureRef(co, 2));
Obj b = _35reg1433;
Obj _35reg1434 = primAdd(pos, makeNumber(1));
coraCall(co, 4, globalRef(intern("cora/lib/toc.pos-in-list0")), _35reg1434, x, b);
} else {
coraCall(co, 1, _35cc1237);
}
}

void _35clofun2896(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2889(struct Cora* co) {
Obj _35p1227 = co->args[1];
Obj _35p1228 = co->args[2];
Obj _35p1229 = co->args[3];
Obj _35cc1230 = makeNative(0, _35clofun2890, 0, 3, _35p1227, _35p1228, _35p1229);
Obj f = _35p1227;
Obj acc = _35p1228;
Obj _35reg1429 = primEQ(Nil, _35p1229);
if (True == _35reg1429) {
coraReturn(co, acc);
return;
} else {
coraCall(co, 1, _35cc1230);
}
}

void _35clofun2890(struct Cora* co) {
Obj _35cc1231 = makeNative(0, _35clofun2891, 0, 0);
Obj f = closureRef(co, 0);
Obj acc = closureRef(co, 1);
Obj _35reg1425 = primIsCons(closureRef(co, 2));
if (True == _35reg1425) {
Obj _35reg1426 = primCar(closureRef(co, 2));
Obj x = _35reg1426;
Obj _35reg1427 = primCdr(closureRef(co, 2));
Obj y = _35reg1427;
pushCont(co, 0, _35clofun2892, 2, f, y);
coraCall(co, 3, f, acc, x);
} else {
coraCall(co, 1, _35cc1231);
}
}

void _35clofun2892(struct Cora* co) {
Obj _35val1428 = co->args[1];
Obj f = co->ctx.stk.stack[co->ctx.stk.base + 0];
Obj y = co->ctx.stk.stack[co->ctx.stk.base + 1];
coraCall(co, 4, globalRef(intern("cora/lib/toc.foldl")), f, _35val1428, y);
}

void _35clofun2891(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

void _35clofun2885(struct Cora* co) {
Obj _35p1222 = co->args[1];
Obj _35p1223 = co->args[2];
Obj _35cc1224 = makeNative(0, _35clofun2886, 0, 2, _35p1222, _35p1223);
Obj var = _35p1222;
Obj _35reg1423 = primEQ(Nil, _35p1223);
if (True == _35reg1423) {
coraReturn(co, Nil);
return;
} else {
coraCall(co, 1, _35cc1224);
}
}

void _35clofun2886(struct Cora* co) {
Obj _35cc1225 = makeNative(0, _35clofun2887, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj var = closureRef(co, 0);
Obj _35reg1413 = primIsCons(closureRef(co, 1));
if (True == _35reg1413) {
Obj _35reg1414 = primCar(closureRef(co, 1));
Obj _35reg1415 = primIsCons(_35reg1414);
if (True == _35reg1415) {
Obj _35reg1416 = primCar(closureRef(co, 1));
Obj _35reg1417 = primCar(_35reg1416);
Obj x = _35reg1417;
Obj _35reg1418 = primCar(closureRef(co, 1));
Obj _35reg1419 = primCdr(_35reg1418);
Obj y = _35reg1419;
Obj _35reg1420 = primCdr(closureRef(co, 1));
Obj __ = _35reg1420;
Obj _35reg1421 = primEQ(var, x);
if (True == _35reg1421) {
Obj _35reg1422 = primCons(x, y);
coraReturn(co, _35reg1422);
return;
} else {
coraCall(co, 1, _35cc1225);
}
} else {
coraCall(co, 1, _35cc1225);
}
} else {
coraCall(co, 1, _35cc1225);
}
}

void _35clofun2887(struct Cora* co) {
Obj _35cc1226 = makeNative(0, _35clofun2888, 0, 0);
Obj var = closureRef(co, 0);
Obj _35reg1410 = primIsCons(closureRef(co, 1));
if (True == _35reg1410) {
Obj _35reg1411 = primCar(closureRef(co, 1));
Obj __ = _35reg1411;
Obj _35reg1412 = primCdr(closureRef(co, 1));
Obj y = _35reg1412;
coraCall(co, 3, globalRef(intern("cora/lib/toc.assq")), var, y);
} else {
coraCall(co, 1, _35cc1226);
}
}

void _35clofun2888(struct Cora* co) {
coraCall(co, 2, globalRef(intern("error")), makeString1("no match-help found!"));
}

