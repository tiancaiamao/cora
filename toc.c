#include "types.h"
#include "runtime.h"

void entry(struct Cora* co);
void _35clofun3661(struct Cora* co);
void _35clofun3662(struct Cora* co);
void _35clofun3981(struct Cora* co);
void _35clofun4021(struct Cora* co);
void _35clofun4022(struct Cora* co);
void _35clofun4027(struct Cora* co);
void _35clofun4030(struct Cora* co);
void _35clofun4033(struct Cora* co);
void _35clofun4034(struct Cora* co);
void _35clofun4031(struct Cora* co);
void _35clofun4032(struct Cora* co);
void _35clofun4028(struct Cora* co);
void _35clofun4029(struct Cora* co);
void _35clofun4025(struct Cora* co);
void _35clofun4026(struct Cora* co);
void _35clofun4023(struct Cora* co);
void _35clofun4024(struct Cora* co);
void _35clofun4020(struct Cora* co);
void _35clofun4019(struct Cora* co);
void _35clofun4018(struct Cora* co);
void _35clofun4017(struct Cora* co);
void _35clofun4016(struct Cora* co);
void _35clofun4015(struct Cora* co);
void _35clofun4014(struct Cora* co);
void _35clofun4013(struct Cora* co);
void _35clofun4012(struct Cora* co);
void _35clofun4011(struct Cora* co);
void _35clofun4010(struct Cora* co);
void _35clofun4009(struct Cora* co);
void _35clofun4008(struct Cora* co);
void _35clofun4007(struct Cora* co);
void _35clofun4006(struct Cora* co);
void _35clofun4005(struct Cora* co);
void _35clofun3999(struct Cora* co);
void _35clofun4000(struct Cora* co);
void _35clofun4001(struct Cora* co);
void _35clofun4002(struct Cora* co);
void _35clofun4003(struct Cora* co);
void _35clofun4004(struct Cora* co);
void _35clofun3991(struct Cora* co);
void _35clofun3992(struct Cora* co);
void _35clofun3993(struct Cora* co);
void _35clofun3996(struct Cora* co);
void _35clofun3997(struct Cora* co);
void _35clofun3998(struct Cora* co);
void _35clofun3994(struct Cora* co);
void _35clofun3995(struct Cora* co);
void _35clofun3987(struct Cora* co);
void _35clofun3988(struct Cora* co);
void _35clofun3990(struct Cora* co);
void _35clofun3989(struct Cora* co);
void _35clofun3982(struct Cora* co);
void _35clofun3983(struct Cora* co);
void _35clofun3984(struct Cora* co);
void _35clofun3985(struct Cora* co);
void _35clofun3986(struct Cora* co);
void _35clofun3978(struct Cora* co);
void _35clofun3979(struct Cora* co);
void _35clofun3980(struct Cora* co);
void _35clofun3975(struct Cora* co);
void _35clofun3976(struct Cora* co);
void _35clofun3977(struct Cora* co);
void _35clofun3973(struct Cora* co);
void _35clofun3974(struct Cora* co);
void _35clofun3972(struct Cora* co);
void _35clofun3971(struct Cora* co);
void _35clofun3970(struct Cora* co);
void _35clofun3969(struct Cora* co);
void _35clofun3962(struct Cora* co);
void _35clofun3964(struct Cora* co);
void _35clofun3965(struct Cora* co);
void _35clofun3966(struct Cora* co);
void _35clofun3967(struct Cora* co);
void _35clofun3968(struct Cora* co);
void _35clofun3963(struct Cora* co);
void _35clofun3954(struct Cora* co);
void _35clofun3955(struct Cora* co);
void _35clofun3957(struct Cora* co);
void _35clofun3958(struct Cora* co);
void _35clofun3959(struct Cora* co);
void _35clofun3960(struct Cora* co);
void _35clofun3961(struct Cora* co);
void _35clofun3956(struct Cora* co);
void _35clofun3950(struct Cora* co);
void _35clofun3951(struct Cora* co);
void _35clofun3952(struct Cora* co);
void _35clofun3953(struct Cora* co);
void _35clofun3949(struct Cora* co);
void _35clofun3943(struct Cora* co);
void _35clofun3944(struct Cora* co);
void _35clofun3946(struct Cora* co);
void _35clofun3947(struct Cora* co);
void _35clofun3948(struct Cora* co);
void _35clofun3945(struct Cora* co);
void _35clofun3932(struct Cora* co);
void _35clofun3934(struct Cora* co);
void _35clofun3935(struct Cora* co);
void _35clofun3936(struct Cora* co);
void _35clofun3937(struct Cora* co);
void _35clofun3938(struct Cora* co);
void _35clofun3939(struct Cora* co);
void _35clofun3942(struct Cora* co);
void _35clofun3940(struct Cora* co);
void _35clofun3941(struct Cora* co);
void _35clofun3933(struct Cora* co);
void _35clofun3924(struct Cora* co);
void _35clofun3925(struct Cora* co);
void _35clofun3927(struct Cora* co);
void _35clofun3928(struct Cora* co);
void _35clofun3929(struct Cora* co);
void _35clofun3930(struct Cora* co);
void _35clofun3931(struct Cora* co);
void _35clofun3926(struct Cora* co);
void _35clofun3843(struct Cora* co);
void _35clofun3844(struct Cora* co);
void _35clofun3921(struct Cora* co);
void _35clofun3922(struct Cora* co);
void _35clofun3923(struct Cora* co);
void _35clofun3845(struct Cora* co);
void _35clofun3919(struct Cora* co);
void _35clofun3920(struct Cora* co);
void _35clofun3846(struct Cora* co);
void _35clofun3917(struct Cora* co);
void _35clofun3918(struct Cora* co);
void _35clofun3847(struct Cora* co);
void _35clofun3911(struct Cora* co);
void _35clofun3914(struct Cora* co);
void _35clofun3915(struct Cora* co);
void _35clofun3916(struct Cora* co);
void _35clofun3912(struct Cora* co);
void _35clofun3913(struct Cora* co);
void _35clofun3908(struct Cora* co);
void _35clofun3909(struct Cora* co);
void _35clofun3910(struct Cora* co);
void _35clofun3848(struct Cora* co);
void _35clofun3898(struct Cora* co);
void _35clofun3904(struct Cora* co);
void _35clofun3905(struct Cora* co);
void _35clofun3906(struct Cora* co);
void _35clofun3907(struct Cora* co);
void _35clofun3899(struct Cora* co);
void _35clofun3900(struct Cora* co);
void _35clofun3901(struct Cora* co);
void _35clofun3902(struct Cora* co);
void _35clofun3903(struct Cora* co);
void _35clofun3849(struct Cora* co);
void _35clofun3894(struct Cora* co);
void _35clofun3895(struct Cora* co);
void _35clofun3896(struct Cora* co);
void _35clofun3897(struct Cora* co);
void _35clofun3850(struct Cora* co);
void _35clofun3888(struct Cora* co);
void _35clofun3889(struct Cora* co);
void _35clofun3890(struct Cora* co);
void _35clofun3891(struct Cora* co);
void _35clofun3892(struct Cora* co);
void _35clofun3893(struct Cora* co);
void _35clofun3851(struct Cora* co);
void _35clofun3878(struct Cora* co);
void _35clofun3879(struct Cora* co);
void _35clofun3880(struct Cora* co);
void _35clofun3881(struct Cora* co);
void _35clofun3882(struct Cora* co);
void _35clofun3883(struct Cora* co);
void _35clofun3884(struct Cora* co);
void _35clofun3885(struct Cora* co);
void _35clofun3886(struct Cora* co);
void _35clofun3887(struct Cora* co);
void _35clofun3852(struct Cora* co);
void _35clofun3876(struct Cora* co);
void _35clofun3877(struct Cora* co);
void _35clofun3853(struct Cora* co);
void _35clofun3872(struct Cora* co);
void _35clofun3873(struct Cora* co);
void _35clofun3874(struct Cora* co);
void _35clofun3875(struct Cora* co);
void _35clofun3854(struct Cora* co);
void _35clofun3855(struct Cora* co);
void _35clofun3871(struct Cora* co);
void _35clofun3856(struct Cora* co);
void _35clofun3858(struct Cora* co);
void _35clofun3859(struct Cora* co);
void _35clofun3860(struct Cora* co);
void _35clofun3861(struct Cora* co);
void _35clofun3862(struct Cora* co);
void _35clofun3863(struct Cora* co);
void _35clofun3864(struct Cora* co);
void _35clofun3865(struct Cora* co);
void _35clofun3866(struct Cora* co);
void _35clofun3867(struct Cora* co);
void _35clofun3868(struct Cora* co);
void _35clofun3869(struct Cora* co);
void _35clofun3870(struct Cora* co);
void _35clofun3857(struct Cora* co);
void _35clofun3841(struct Cora* co);
void _35clofun3842(struct Cora* co);
void _35clofun3836(struct Cora* co);
void _35clofun3840(struct Cora* co);
void _35clofun3837(struct Cora* co);
void _35clofun3839(struct Cora* co);
void _35clofun3838(struct Cora* co);
void _35clofun3826(struct Cora* co);
void _35clofun3834(struct Cora* co);
void _35clofun3835(struct Cora* co);
void _35clofun3832(struct Cora* co);
void _35clofun3833(struct Cora* co);
void _35clofun3830(struct Cora* co);
void _35clofun3831(struct Cora* co);
void _35clofun3827(struct Cora* co);
void _35clofun3828(struct Cora* co);
void _35clofun3829(struct Cora* co);
void _35clofun3808(struct Cora* co);
void _35clofun3825(struct Cora* co);
void _35clofun3809(struct Cora* co);
void _35clofun3810(struct Cora* co);
void _35clofun3824(struct Cora* co);
void _35clofun3811(struct Cora* co);
void _35clofun3819(struct Cora* co);
void _35clofun3820(struct Cora* co);
void _35clofun3821(struct Cora* co);
void _35clofun3822(struct Cora* co);
void _35clofun3823(struct Cora* co);
void _35clofun3812(struct Cora* co);
void _35clofun3816(struct Cora* co);
void _35clofun3817(struct Cora* co);
void _35clofun3818(struct Cora* co);
void _35clofun3813(struct Cora* co);
void _35clofun3815(struct Cora* co);
void _35clofun3814(struct Cora* co);
void _35clofun3798(struct Cora* co);
void _35clofun3802(struct Cora* co);
void _35clofun3803(struct Cora* co);
void _35clofun3807(struct Cora* co);
void _35clofun3804(struct Cora* co);
void _35clofun3806(struct Cora* co);
void _35clofun3805(struct Cora* co);
void _35clofun3799(struct Cora* co);
void _35clofun3801(struct Cora* co);
void _35clofun3800(struct Cora* co);
void _35clofun3780(struct Cora* co);
void _35clofun3797(struct Cora* co);
void _35clofun3781(struct Cora* co);
void _35clofun3796(struct Cora* co);
void _35clofun3782(struct Cora* co);
void _35clofun3793(struct Cora* co);
void _35clofun3794(struct Cora* co);
void _35clofun3795(struct Cora* co);
void _35clofun3783(struct Cora* co);
void _35clofun3791(struct Cora* co);
void _35clofun3792(struct Cora* co);
void _35clofun3784(struct Cora* co);
void _35clofun3789(struct Cora* co);
void _35clofun3790(struct Cora* co);
void _35clofun3785(struct Cora* co);
void _35clofun3788(struct Cora* co);
void _35clofun3786(struct Cora* co);
void _35clofun3787(struct Cora* co);
void _35clofun3779(struct Cora* co);
void _35clofun3764(struct Cora* co);
void _35clofun3778(struct Cora* co);
void _35clofun3765(struct Cora* co);
void _35clofun3777(struct Cora* co);
void _35clofun3766(struct Cora* co);
void _35clofun3773(struct Cora* co);
void _35clofun3774(struct Cora* co);
void _35clofun3775(struct Cora* co);
void _35clofun3776(struct Cora* co);
void _35clofun3767(struct Cora* co);
void _35clofun3771(struct Cora* co);
void _35clofun3772(struct Cora* co);
void _35clofun3768(struct Cora* co);
void _35clofun3770(struct Cora* co);
void _35clofun3769(struct Cora* co);
void _35clofun3741(struct Cora* co);
void _35clofun3763(struct Cora* co);
void _35clofun3742(struct Cora* co);
void _35clofun3743(struct Cora* co);
void _35clofun3762(struct Cora* co);
void _35clofun3744(struct Cora* co);
void _35clofun3761(struct Cora* co);
void _35clofun3745(struct Cora* co);
void _35clofun3760(struct Cora* co);
void _35clofun3746(struct Cora* co);
void _35clofun3757(struct Cora* co);
void _35clofun3758(struct Cora* co);
void _35clofun3759(struct Cora* co);
void _35clofun3747(struct Cora* co);
void _35clofun3748(struct Cora* co);
void _35clofun3749(struct Cora* co);
void _35clofun3756(struct Cora* co);
void _35clofun3750(struct Cora* co);
void _35clofun3751(struct Cora* co);
void _35clofun3755(struct Cora* co);
void _35clofun3752(struct Cora* co);
void _35clofun3754(struct Cora* co);
void _35clofun3753(struct Cora* co);
void _35clofun3734(struct Cora* co);
void _35clofun3735(struct Cora* co);
void _35clofun3736(struct Cora* co);
void _35clofun3737(struct Cora* co);
void _35clofun3738(struct Cora* co);
void _35clofun3739(struct Cora* co);
void _35clofun3740(struct Cora* co);
void _35clofun3728(struct Cora* co);
void _35clofun3729(struct Cora* co);
void _35clofun3733(struct Cora* co);
void _35clofun3730(struct Cora* co);
void _35clofun3732(struct Cora* co);
void _35clofun3731(struct Cora* co);
void _35clofun3722(struct Cora* co);
void _35clofun3723(struct Cora* co);
void _35clofun3727(struct Cora* co);
void _35clofun3724(struct Cora* co);
void _35clofun3726(struct Cora* co);
void _35clofun3725(struct Cora* co);
void _35clofun3692(struct Cora* co);
void _35clofun3719(struct Cora* co);
void _35clofun3720(struct Cora* co);
void _35clofun3721(struct Cora* co);
void _35clofun3693(struct Cora* co);
void _35clofun3694(struct Cora* co);
void _35clofun3718(struct Cora* co);
void _35clofun3695(struct Cora* co);
void _35clofun3716(struct Cora* co);
void _35clofun3717(struct Cora* co);
void _35clofun3696(struct Cora* co);
void _35clofun3714(struct Cora* co);
void _35clofun3715(struct Cora* co);
void _35clofun3697(struct Cora* co);
void _35clofun3712(struct Cora* co);
void _35clofun3713(struct Cora* co);
void _35clofun3698(struct Cora* co);
void _35clofun3710(struct Cora* co);
void _35clofun3711(struct Cora* co);
void _35clofun3699(struct Cora* co);
void _35clofun3703(struct Cora* co);
void _35clofun3704(struct Cora* co);
void _35clofun3705(struct Cora* co);
void _35clofun3708(struct Cora* co);
void _35clofun3709(struct Cora* co);
void _35clofun3706(struct Cora* co);
void _35clofun3707(struct Cora* co);
void _35clofun3700(struct Cora* co);
void _35clofun3702(struct Cora* co);
void _35clofun3701(struct Cora* co);
void _35clofun3689(struct Cora* co);
void _35clofun3690(struct Cora* co);
void _35clofun3691(struct Cora* co);
void _35clofun3686(struct Cora* co);
void _35clofun3687(struct Cora* co);
void _35clofun3688(struct Cora* co);
void _35clofun3683(struct Cora* co);
void _35clofun3684(struct Cora* co);
void _35clofun3685(struct Cora* co);
void _35clofun3680(struct Cora* co);
void _35clofun3681(struct Cora* co);
void _35clofun3682(struct Cora* co);
void _35clofun3676(struct Cora* co);
void _35clofun3677(struct Cora* co);
void _35clofun3679(struct Cora* co);
void _35clofun3678(struct Cora* co);
void _35clofun3675(struct Cora* co);
void _35clofun3671(struct Cora* co);
void _35clofun3672(struct Cora* co);
void _35clofun3673(struct Cora* co);
void _35clofun3674(struct Cora* co);
void _35clofun3667(struct Cora* co);
void _35clofun3668(struct Cora* co);
void _35clofun3670(struct Cora* co);
void _35clofun3669(struct Cora* co);
void _35clofun3663(struct Cora* co);
void _35clofun3664(struct Cora* co);
void _35clofun3665(struct Cora* co);
void _35clofun3666(struct Cora* co);

void entry(struct Cora* co) {
pushCont(co, _35clofun3661, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("import"));
co->args[1] = makeString1("cora/lib/toc/internal");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3661(struct Cora* co) {
Obj _35val2200 = co->args[1];
pushCont(co, _35clofun3662, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("import"));
co->args[1] = makeString1("cora/lib/io");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3662(struct Cora* co) {
Obj _35val2201 = co->args[1];
Obj _35reg2216 = primSet(intern("cora/lib/toc/include.assq"), makeNative(_35clofun3663, 2, 0));
Obj _35reg2222 = primSet(intern("cora/lib/toc/include.foldl"), makeNative(_35clofun3667, 3, 0));
Obj _35reg2232 = primSet(intern("cora/lib/toc/include.pos-in-list0"), makeNative(_35clofun3671, 3, 0));
Obj _35reg2233 = primSet(intern("cora/lib/toc/include.index"), makeNative(_35clofun3675, 2, 0));
Obj _35reg2240 = primSet(intern("cora/lib/toc/include.exist-in-env"), makeNative(_35clofun3676, 2, 0));
Obj _35reg2241 = primCons(intern("primSet"), Nil);
Obj _35reg2242 = primCons(makeNumber(2), _35reg2241);
Obj _35reg2243 = primCons(intern("set"), _35reg2242);
Obj _35reg2244 = primCons(intern("primCar"), Nil);
Obj _35reg2245 = primCons(makeNumber(1), _35reg2244);
Obj _35reg2246 = primCons(intern("car"), _35reg2245);
Obj _35reg2247 = primCons(intern("primCdr"), Nil);
Obj _35reg2248 = primCons(makeNumber(1), _35reg2247);
Obj _35reg2249 = primCons(intern("cdr"), _35reg2248);
Obj _35reg2250 = primCons(intern("primCons"), Nil);
Obj _35reg2251 = primCons(makeNumber(2), _35reg2250);
Obj _35reg2252 = primCons(intern("cons"), _35reg2251);
Obj _35reg2253 = primCons(intern("primIsCons"), Nil);
Obj _35reg2254 = primCons(makeNumber(1), _35reg2253);
Obj _35reg2255 = primCons(intern("cons?"), _35reg2254);
Obj _35reg2256 = primCons(intern("primAdd"), Nil);
Obj _35reg2257 = primCons(makeNumber(2), _35reg2256);
Obj _35reg2258 = primCons(intern("+"), _35reg2257);
Obj _35reg2259 = primCons(intern("primSub"), Nil);
Obj _35reg2260 = primCons(makeNumber(2), _35reg2259);
Obj _35reg2261 = primCons(intern("-"), _35reg2260);
Obj _35reg2262 = primCons(intern("primMul"), Nil);
Obj _35reg2263 = primCons(makeNumber(2), _35reg2262);
Obj _35reg2264 = primCons(intern("*"), _35reg2263);
Obj _35reg2265 = primCons(intern("primDiv"), Nil);
Obj _35reg2266 = primCons(makeNumber(2), _35reg2265);
Obj _35reg2267 = primCons(intern("/"), _35reg2266);
Obj _35reg2268 = primCons(intern("primEQ"), Nil);
Obj _35reg2269 = primCons(makeNumber(2), _35reg2268);
Obj _35reg2270 = primCons(intern("="), _35reg2269);
Obj _35reg2271 = primCons(intern("primGT"), Nil);
Obj _35reg2272 = primCons(makeNumber(2), _35reg2271);
Obj _35reg2273 = primCons(intern(">"), _35reg2272);
Obj _35reg2274 = primCons(intern("primLT"), Nil);
Obj _35reg2275 = primCons(makeNumber(2), _35reg2274);
Obj _35reg2276 = primCons(intern("<"), _35reg2275);
Obj _35reg2277 = primCons(intern("primGenSym"), Nil);
Obj _35reg2278 = primCons(makeNumber(1), _35reg2277);
Obj _35reg2279 = primCons(intern("gensym"), _35reg2278);
Obj _35reg2280 = primCons(intern("primIsSymbol"), Nil);
Obj _35reg2281 = primCons(makeNumber(1), _35reg2280);
Obj _35reg2282 = primCons(intern("symbol?"), _35reg2281);
Obj _35reg2283 = primCons(intern("primNot"), Nil);
Obj _35reg2284 = primCons(makeNumber(1), _35reg2283);
Obj _35reg2285 = primCons(intern("not"), _35reg2284);
Obj _35reg2286 = primCons(intern("primIsNumber"), Nil);
Obj _35reg2287 = primCons(makeNumber(1), _35reg2286);
Obj _35reg2288 = primCons(intern("integer?"), _35reg2287);
Obj _35reg2289 = primCons(intern("primIsString"), Nil);
Obj _35reg2290 = primCons(makeNumber(1), _35reg2289);
Obj _35reg2291 = primCons(intern("string?"), _35reg2290);
Obj _35reg2292 = primCons(_35reg2291, Nil);
Obj _35reg2293 = primCons(_35reg2288, _35reg2292);
Obj _35reg2294 = primCons(_35reg2285, _35reg2293);
Obj _35reg2295 = primCons(_35reg2282, _35reg2294);
Obj _35reg2296 = primCons(_35reg2279, _35reg2295);
Obj _35reg2297 = primCons(_35reg2276, _35reg2296);
Obj _35reg2298 = primCons(_35reg2273, _35reg2297);
Obj _35reg2299 = primCons(_35reg2270, _35reg2298);
Obj _35reg2300 = primCons(_35reg2267, _35reg2299);
Obj _35reg2301 = primCons(_35reg2264, _35reg2300);
Obj _35reg2302 = primCons(_35reg2261, _35reg2301);
Obj _35reg2303 = primCons(_35reg2258, _35reg2302);
Obj _35reg2304 = primCons(_35reg2255, _35reg2303);
Obj _35reg2305 = primCons(_35reg2252, _35reg2304);
Obj _35reg2306 = primCons(_35reg2249, _35reg2305);
Obj _35reg2307 = primCons(_35reg2246, _35reg2306);
Obj _35reg2308 = primCons(_35reg2243, _35reg2307);
Obj _35reg2309 = primSet(intern("cora/lib/toc/include.*builtin-prims*"), _35reg2308);
Obj _35reg2313 = primSet(intern("builtin?"), makeNative(_35clofun3680, 1, 0));
Obj _35reg2316 = primSet(intern("cora/lib/toc/include.builtin->name"), makeNative(_35clofun3683, 1, 0));
Obj _35reg2319 = primSet(intern("cora/lib/toc/include.builtin->args"), makeNative(_35clofun3686, 1, 0));
Obj _35reg2324 = primSet(intern("cora/lib/toc/include.temp-list"), makeNative(_35clofun3689, 2, 0));
Obj _35reg2460 = primSet(intern("cora/lib/toc/include.parse"), makeNative(_35clofun3692, 2, 0));
Obj _35reg2471 = primSet(intern("cora/lib/toc/include.union"), makeNative(_35clofun3722, 2, 0));
Obj _35reg2482 = primSet(intern("cora/lib/toc/include.diff"), makeNative(_35clofun3728, 2, 0));
Obj _35reg2533 = primSet(intern("cora/lib/toc/include.convert-protect?"), makeNative(_35clofun3734, 1, 0));
Obj _35reg2708 = primSet(intern("cora/lib/toc/include.free-vars"), makeNative(_35clofun3741, 1, 0));
Obj _35reg2781 = primSet(intern("cora/lib/toc/include.closure-convert"), makeNative(_35clofun3764, 2, 0));
Obj _35reg2784 = primSet(intern("cora/lib/toc/include.id"), makeNative(_35clofun3779, 1, 0));
Obj _35reg2921 = primSet(intern("cora/lib/toc/include.tailify"), makeNative(_35clofun3780, 2, 0));
Obj _35reg2968 = primSet(intern("cora/lib/toc/include.tailify-list"), makeNative(_35clofun3798, 3, 0));
Obj _35reg3047 = primSet(intern("cora/lib/toc/include.explicit-stack"), makeNative(_35clofun3808, 2, 0));
Obj _35reg3154 = primSet(intern("cora/lib/toc/include.collect-lambda"), makeNative(_35clofun3826, 3, 0));
Obj _35reg3161 = primSet(intern("cora/lib/toc/include.collect-lambda-list"), makeNative(_35clofun3836, 4, 0));
Obj _35reg3168 = primSet(intern("cora/lib/toc/include.wrap-var"), makeNative(_35clofun3841, 2, 0));
Obj _35reg3429 = primSet(intern("cora/lib/toc/include.generate-inst"), makeNative(_35clofun3843, 3, 0));
Obj _35reg3440 = primSet(intern("cora/lib/toc/include.generate-call-args"), makeNative(_35clofun3924, 4, 0));
Obj _35reg3459 = primSet(intern("cora/lib/toc/include.generate-cont"), makeNative(_35clofun3932, 2, 0));
Obj _35reg3468 = primSet(intern("cora/lib/toc/include.generate-inst-list-h"), makeNative(_35clofun3943, 4, 0));
Obj _35reg3469 = primSet(intern("cora/lib/toc/include.generate-inst-list"), makeNative(_35clofun3949, 3, 0));
Obj _35reg3473 = primSet(intern("cora/lib/toc/include.code-gen-func-declare"), makeNative(_35clofun3950, 2, 0));
Obj _35reg3484 = primSet(intern("cora/lib/toc/include.generate-call-args-reverse"), makeNative(_35clofun3954, 5, 0));
Obj _35reg3541 = primSet(intern("cora/lib/toc/include.code-gen-toplevel"), makeNative(_35clofun3962, 2, 0));
Obj _35reg3542 = primSet(intern("cora/lib/toc/include.parse-pass"), makeNative(_35clofun3969, 1, 0));
Obj _35reg3543 = primSet(intern("cora/lib/toc/include.closure-convert-pass"), makeNative(_35clofun3970, 1, 0));
Obj _35reg3544 = primSet(intern("cora/lib/toc/include.tailify-pass"), makeNative(_35clofun3971, 1, 0));
Obj _35reg3545 = primSet(intern("cora/lib/toc/include.explicit-stack-pass"), makeNative(_35clofun3972, 1, 0));
Obj _35reg3553 = primSet(intern("cora/lib/toc/include.collect-lambda-pass"), makeNative(_35clofun3973, 1, 0));
Obj _35reg3560 = primSet(intern("cora/lib/toc/include.rewrite-->macro"), makeNative(_35clofun3975, 2, 0));
pushCont(co, _35clofun3981, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("->");
co->args[2] = makeNative(_35clofun3978, 1, 0);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3981(struct Cora* co) {
Obj _35val3563 = co->args[1];
Obj _35reg3568 = primSet(intern("cora/lib/toc/include.compile"), makeNative(_35clofun3982, 1, 0));
Obj _35reg3574 = primSet(intern("for-each"), makeNative(_35clofun3987, 2, 0));
Obj _35reg3581 = primSet(intern("cora/lib/toc/include.generate-c"), makeNative(_35clofun3991, 2, 0));
Obj _35reg3587 = primSet(intern("cora/lib/toc/include.compile-to-c"), makeNative(_35clofun3999, 3, 0));
Obj _35reg3589 = primSet(intern("set"), makeNative(_35clofun4005, 2, 0));
Obj _35reg3591 = primSet(intern("car"), makeNative(_35clofun4006, 1, 0));
Obj _35reg3593 = primSet(intern("cdr"), makeNative(_35clofun4007, 1, 0));
Obj _35reg3595 = primSet(intern("cons"), makeNative(_35clofun4008, 2, 0));
Obj _35reg3597 = primSet(intern("cons"), makeNative(_35clofun4009, 2, 0));
Obj _35reg3599 = primSet(intern("+"), makeNative(_35clofun4010, 2, 0));
Obj _35reg3601 = primSet(intern("-"), makeNative(_35clofun4011, 2, 0));
Obj _35reg3603 = primSet(intern("*"), makeNative(_35clofun4012, 2, 0));
Obj _35reg3605 = primSet(intern("/"), makeNative(_35clofun4013, 2, 0));
Obj _35reg3607 = primSet(intern("="), makeNative(_35clofun4014, 2, 0));
Obj _35reg3609 = primSet(intern(">"), makeNative(_35clofun4015, 2, 0));
Obj _35reg3611 = primSet(intern("<"), makeNative(_35clofun4016, 2, 0));
Obj _35reg3613 = primSet(intern("gensym"), makeNative(_35clofun4017, 1, 0));
Obj _35reg3615 = primSet(intern("symbol?"), makeNative(_35clofun4018, 1, 0));
Obj _35reg3617 = primSet(intern("not"), makeNative(_35clofun4019, 1, 0));
Obj _35reg3619 = primSet(intern("string?"), makeNative(_35clofun4020, 1, 0));
Obj _35reg3660 = primSet(intern("cora/lib/toc/include.eval0"), makeNative(_35clofun4021, 1, 0));
co->nargs = 2;
co->args[1] = _35reg3660;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4021(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg3620 = primIsSymbol(exp);
if (True == _35reg3620) {
co->nargs = 2;
co->args[0] = globalRef(intern("value"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun4022, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("number?"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun4022(struct Cora* co) {
Obj _35val3621 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val3621) {
if (True == True) {
co->nargs = 2;
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg3622 = primIsCons(exp);
if (True == _35reg3622) {
Obj _35reg3623 = primCar(exp);
Obj _35reg3624 = primEQ(_35reg3623, intern("quote"));
if (True == _35reg3624) {
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3625 = primCar(exp);
pushCont(co, _35clofun4023, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg3625;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
Obj _35reg3629 = primIsString(exp);
if (True == _35reg3629) {
if (True == True) {
co->nargs = 2;
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg3630 = primIsCons(exp);
if (True == _35reg3630) {
Obj _35reg3631 = primCar(exp);
Obj _35reg3632 = primEQ(_35reg3631, intern("quote"));
if (True == _35reg3632) {
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3633 = primCar(exp);
pushCont(co, _35clofun4025, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg3633;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
pushCont(co, _35clofun4027, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("boolean?"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun4027(struct Cora* co) {
Obj _35val3637 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val3637) {
if (True == True) {
co->nargs = 2;
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg3638 = primIsCons(exp);
if (True == _35reg3638) {
Obj _35reg3639 = primCar(exp);
Obj _35reg3640 = primEQ(_35reg3639, intern("quote"));
if (True == _35reg3640) {
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3641 = primCar(exp);
pushCont(co, _35clofun4028, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg3641;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
pushCont(co, _35clofun4030, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun4030(struct Cora* co) {
Obj _35val3645 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val3645) {
if (True == True) {
co->nargs = 2;
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg3646 = primIsCons(exp);
if (True == _35reg3646) {
Obj _35reg3647 = primCar(exp);
Obj _35reg3648 = primEQ(_35reg3647, intern("quote"));
if (True == _35reg3648) {
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3649 = primCar(exp);
pushCont(co, _35clofun4031, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg3649;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
co->nargs = 2;
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg3653 = primIsCons(exp);
if (True == _35reg3653) {
Obj _35reg3654 = primCar(exp);
Obj _35reg3655 = primEQ(_35reg3654, intern("quote"));
if (True == _35reg3655) {
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3656 = primCar(exp);
pushCont(co, _35clofun4033, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg3656;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun4033(struct Cora* co) {
Obj _35val3657 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg3658 = primCdr(exp);
pushCont(co, _35clofun4034, 1, _35val3657);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg3658;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4034(struct Cora* co) {
Obj _35val3659 = co->args[1];
Obj _35val3657 = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val3657;
co->args[2] = _35val3659;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4031(struct Cora* co) {
Obj _35val3650 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg3651 = primCdr(exp);
pushCont(co, _35clofun4032, 1, _35val3650);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg3651;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4032(struct Cora* co) {
Obj _35val3652 = co->args[1];
Obj _35val3650 = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val3650;
co->args[2] = _35val3652;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4028(struct Cora* co) {
Obj _35val3642 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg3643 = primCdr(exp);
pushCont(co, _35clofun4029, 1, _35val3642);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg3643;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4029(struct Cora* co) {
Obj _35val3644 = co->args[1];
Obj _35val3642 = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val3642;
co->args[2] = _35val3644;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4025(struct Cora* co) {
Obj _35val3634 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg3635 = primCdr(exp);
pushCont(co, _35clofun4026, 1, _35val3634);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg3635;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4026(struct Cora* co) {
Obj _35val3636 = co->args[1];
Obj _35val3634 = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val3634;
co->args[2] = _35val3636;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4023(struct Cora* co) {
Obj _35val3626 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg3627 = primCdr(exp);
pushCont(co, _35clofun4024, 1, _35val3626);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg3627;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4024(struct Cora* co) {
Obj _35val3628 = co->args[1];
Obj _35val3626 = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val3626;
co->args[2] = _35val3628;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4020(struct Cora* co) {
Obj _35tmp2199 = co->args[1];
Obj _35reg3618 = primIsString(_35tmp2199);
co->nargs = 2;
co->args[1] = _35reg3618;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4019(struct Cora* co) {
Obj _35tmp2198 = co->args[1];
Obj _35reg3616 = primNot(_35tmp2198);
co->nargs = 2;
co->args[1] = _35reg3616;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4018(struct Cora* co) {
Obj _35tmp2197 = co->args[1];
Obj _35reg3614 = primIsSymbol(_35tmp2197);
co->nargs = 2;
co->args[1] = _35reg3614;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4017(struct Cora* co) {
Obj _35tmp2196 = co->args[1];
Obj _35reg3612 = primGenSym(_35tmp2196);
co->nargs = 2;
co->args[1] = _35reg3612;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4016(struct Cora* co) {
Obj _35tmp2195 = co->args[1];
Obj _35tmp2194 = co->args[2];
Obj _35reg3610 = primLT(_35tmp2195, _35tmp2194);
co->nargs = 2;
co->args[1] = _35reg3610;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4015(struct Cora* co) {
Obj _35tmp2193 = co->args[1];
Obj _35tmp2192 = co->args[2];
Obj _35reg3608 = primGT(_35tmp2193, _35tmp2192);
co->nargs = 2;
co->args[1] = _35reg3608;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4014(struct Cora* co) {
Obj _35tmp2191 = co->args[1];
Obj _35tmp2190 = co->args[2];
Obj _35reg3606 = primEQ(_35tmp2191, _35tmp2190);
co->nargs = 2;
co->args[1] = _35reg3606;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4013(struct Cora* co) {
Obj _35tmp2189 = co->args[1];
Obj _35tmp2188 = co->args[2];
Obj _35reg3604 = primDiv(_35tmp2189, _35tmp2188);
co->nargs = 2;
co->args[1] = _35reg3604;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4012(struct Cora* co) {
Obj _35tmp2187 = co->args[1];
Obj _35tmp2186 = co->args[2];
Obj _35reg3602 = primMul(_35tmp2187, _35tmp2186);
co->nargs = 2;
co->args[1] = _35reg3602;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4011(struct Cora* co) {
Obj _35tmp2185 = co->args[1];
Obj _35tmp2184 = co->args[2];
Obj _35reg3600 = primSub(_35tmp2185, _35tmp2184);
co->nargs = 2;
co->args[1] = _35reg3600;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4010(struct Cora* co) {
Obj _35tmp2183 = co->args[1];
Obj _35tmp2182 = co->args[2];
Obj _35reg3598 = primAdd(_35tmp2183, _35tmp2182);
co->nargs = 2;
co->args[1] = _35reg3598;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4009(struct Cora* co) {
Obj _35tmp2181 = co->args[1];
Obj _35tmp2180 = co->args[2];
Obj _35reg3596 = primCons(_35tmp2181, _35tmp2180);
co->nargs = 2;
co->args[1] = _35reg3596;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4008(struct Cora* co) {
Obj _35tmp2179 = co->args[1];
Obj _35tmp2178 = co->args[2];
Obj _35reg3594 = primCons(_35tmp2179, _35tmp2178);
co->nargs = 2;
co->args[1] = _35reg3594;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4007(struct Cora* co) {
Obj _35tmp2177 = co->args[1];
Obj _35reg3592 = primCdr(_35tmp2177);
co->nargs = 2;
co->args[1] = _35reg3592;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4006(struct Cora* co) {
Obj _35tmp2176 = co->args[1];
Obj _35reg3590 = primCar(_35tmp2176);
co->nargs = 2;
co->args[1] = _35reg3590;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun4005(struct Cora* co) {
Obj _35tmp2175 = co->args[1];
Obj _35tmp2174 = co->args[2];
Obj _35reg3588 = primSet(_35tmp2175, _35tmp2174);
co->nargs = 2;
co->args[1] = _35reg3588;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3999(struct Cora* co) {
Obj from = co->args[1];
Obj to = co->args[2];
Obj pkg_45str = co->args[3];
pushCont(co, _35clofun4000, 1, to);
co->nargs = 3;
co->args[0] = globalRef(intern("read-file-as-sexp"));
co->args[1] = from;
co->args[2] = pkg_45str;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4000(struct Cora* co) {
Obj _35val3582 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj sexp = _35val3582;
pushCont(co, _35clofun4001, 1, to);
co->nargs = 2;
co->args[0] = globalRef(intern("macroexpand"));
co->args[1] = sexp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4001(struct Cora* co) {
Obj _35val3583 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj input = _35val3583;
pushCont(co, _35clofun4002, 1, to);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.compile"));
co->args[1] = input;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4002(struct Cora* co) {
Obj _35val3584 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = _35val3584;
pushCont(co, _35clofun4003, 1, bc);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/io.open-output-file"));
co->args[1] = to;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4003(struct Cora* co) {
Obj _35val3585 = co->args[1];
Obj bc = co->stack[co->base + 0];
Obj stream = _35val3585;
pushCont(co, _35clofun4004, 1, stream);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-c"));
co->args[1] = stream;
co->args[2] = bc;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun4004(struct Cora* co) {
Obj _35val3586 = co->args[1];
Obj stream = co->stack[co->base + 0];
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/io.close-output-file"));
co->args[1] = stream;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3991(struct Cora* co) {
Obj to = co->args[1];
Obj bc = co->args[2];
pushCont(co, _35clofun3992, 2, to, bc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("#include \"types.h\"\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3992(struct Cora* co) {
Obj _35val3575 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3993, 2, to, bc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("#include \"runtime.h\"\n\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3993(struct Cora* co) {
Obj _35val3576 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3996, 2, to, bc);
co->nargs = 3;
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3994, 1, 1, to);
co->args[2] = bc;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3996(struct Cora* co) {
Obj _35val3579 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3997, 2, to, bc);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3997(struct Cora* co) {
Obj _35val3580 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
co->nargs = 3;
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3998, 1, 1, to);
co->args[2] = bc;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3998(struct Cora* co) {
Obj x = co->args[1];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-toplevel"));
co->args[1] = closureRef(co, 0);
co->args[2] = x;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3994(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg3577 = primCar(x);
pushCont(co, _35clofun3995, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-func-declare"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg3577;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3995(struct Cora* co) {
Obj _35val3578 = co->args[1];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = closureRef(co, 0);
co->args[2] = makeString1(";\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3987(struct Cora* co) {
Obj _35p2170 = co->args[1];
Obj _35p2171 = co->args[2];
Obj _35cc2172 = makeNative(_35clofun3988, 0, 2, _35p2170, _35p2171);
Obj fn = _35p2170;
Obj _35reg3573 = primEQ(Nil, _35p2171);
if (True == _35reg3573) {
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2172;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3988(struct Cora* co) {
Obj _35cc2173 = makeNative(_35clofun3989, 0, 0);
Obj fn = closureRef(co, 0);
Obj _35reg3569 = primIsCons(closureRef(co, 1));
if (True == _35reg3569) {
Obj _35reg3570 = primCar(closureRef(co, 1));
Obj x = _35reg3570;
Obj _35reg3571 = primCdr(closureRef(co, 1));
Obj y = _35reg3571;
pushCont(co, _35clofun3990, 2, fn, y);
co->nargs = 2;
co->args[0] = fn;
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2173;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3990(struct Cora* co) {
Obj _35val3572 = co->args[1];
Obj fn = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
co->nargs = 3;
co->args[0] = globalRef(intern("for-each"));
co->args[1] = fn;
co->args[2] = y;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3989(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3982(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun3983, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse-pass"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3983(struct Cora* co) {
Obj _35val3564 = co->args[1];
pushCont(co, _35clofun3984, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert-pass"));
co->args[1] = _35val3564;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3984(struct Cora* co) {
Obj _35val3565 = co->args[1];
pushCont(co, _35clofun3985, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-pass"));
co->args[1] = _35val3565;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3985(struct Cora* co) {
Obj _35val3566 = co->args[1];
pushCont(co, _35clofun3986, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack-pass"));
co->args[1] = _35val3566;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3986(struct Cora* co) {
Obj _35val3567 = co->args[1];
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-pass"));
co->args[1] = _35val3567;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3978(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun3979, 1, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3979(struct Cora* co) {
Obj _35val3561 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj obj = _35val3561;
pushCont(co, _35clofun3980, 1, obj);
co->nargs = 2;
co->args[0] = globalRef(intern("cddr"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3980(struct Cora* co) {
Obj _35val3562 = co->args[1];
Obj obj = co->stack[co->base + 0];
Obj fns = _35val3562;
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.rewrite-->macro"));
co->args[1] = obj;
co->args[2] = fns;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3975(struct Cora* co) {
Obj _35p2166 = co->args[1];
Obj _35p2167 = co->args[2];
Obj _35cc2168 = makeNative(_35clofun3976, 0, 2, _35p2166, _35p2167);
Obj obj = _35p2166;
Obj _35reg3559 = primEQ(Nil, _35p2167);
if (True == _35reg3559) {
co->nargs = 2;
co->args[1] = obj;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2168;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3976(struct Cora* co) {
Obj _35cc2169 = makeNative(_35clofun3977, 0, 0);
Obj obj = closureRef(co, 0);
Obj _35reg3554 = primIsCons(closureRef(co, 1));
if (True == _35reg3554) {
Obj _35reg3555 = primCar(closureRef(co, 1));
Obj hd = _35reg3555;
Obj _35reg3556 = primCdr(closureRef(co, 1));
Obj more = _35reg3556;
Obj _35reg3557 = primCons(obj, Nil);
Obj _35reg3558 = primCons(hd, _35reg3557);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.rewrite-->macro"));
co->args[1] = _35reg3558;
co->args[2] = more;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2169;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3977(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3973(struct Cora* co) {
Obj exp = co->args[1];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = Nil;
co->args[2] = exp;
co->args[3] = makeNative(_35clofun3974, 2, 0);
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3974(struct Cora* co) {
Obj ls = co->args[1];
Obj e1 = co->args[2];
Obj _35reg3546 = primCons(e1, Nil);
Obj _35reg3547 = primCons(Nil, _35reg3546);
Obj _35reg3548 = primCons(Nil, _35reg3547);
Obj _35reg3549 = primCons(intern("lambda"), _35reg3548);
Obj _35reg3550 = primCons(_35reg3549, Nil);
Obj _35reg3551 = primCons(intern("entry"), _35reg3550);
Obj _35reg3552 = primCons(_35reg3551, ls);
co->nargs = 2;
co->args[1] = _35reg3552;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3972(struct Cora* co) {
Obj exp = co->args[1];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = Nil;
co->args[2] = exp;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3971(struct Cora* co) {
Obj exp = co->args[1];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = exp;
co->args[2] = globalRef(intern("cora/lib/toc/include.id"));
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3970(struct Cora* co) {
Obj exp = co->args[1];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = Nil;
co->args[2] = exp;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3969(struct Cora* co) {
Obj exp = co->args[1];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = Nil;
co->args[2] = exp;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3962(struct Cora* co) {
Obj _35p2163 = co->args[1];
Obj _35p2164 = co->args[2];
Obj _35cc2165 = makeNative(_35clofun3963, 0, 0);
Obj w = _35p2163;
Obj _35reg3485 = primIsCons(_35p2164);
if (True == _35reg3485) {
Obj _35reg3486 = primCar(_35p2164);
Obj name = _35reg3486;
Obj _35reg3487 = primCdr(_35p2164);
Obj _35reg3488 = primIsCons(_35reg3487);
if (True == _35reg3488) {
Obj _35reg3489 = primCdr(_35p2164);
Obj _35reg3490 = primCar(_35reg3489);
Obj _35reg3491 = primIsCons(_35reg3490);
if (True == _35reg3491) {
Obj _35reg3492 = primCdr(_35p2164);
Obj _35reg3493 = primCar(_35reg3492);
Obj _35reg3494 = primCar(_35reg3493);
Obj _35reg3495 = primEQ(intern("lambda"), _35reg3494);
if (True == _35reg3495) {
Obj _35reg3496 = primCdr(_35p2164);
Obj _35reg3497 = primCar(_35reg3496);
Obj _35reg3498 = primCdr(_35reg3497);
Obj _35reg3499 = primIsCons(_35reg3498);
if (True == _35reg3499) {
Obj _35reg3500 = primCdr(_35p2164);
Obj _35reg3501 = primCar(_35reg3500);
Obj _35reg3502 = primCdr(_35reg3501);
Obj _35reg3503 = primCar(_35reg3502);
Obj params = _35reg3503;
Obj _35reg3504 = primCdr(_35p2164);
Obj _35reg3505 = primCar(_35reg3504);
Obj _35reg3506 = primCdr(_35reg3505);
Obj _35reg3507 = primCdr(_35reg3506);
Obj _35reg3508 = primIsCons(_35reg3507);
if (True == _35reg3508) {
Obj _35reg3509 = primCdr(_35p2164);
Obj _35reg3510 = primCar(_35reg3509);
Obj _35reg3511 = primCdr(_35reg3510);
Obj _35reg3512 = primCdr(_35reg3511);
Obj _35reg3513 = primCar(_35reg3512);
Obj actives = _35reg3513;
Obj _35reg3514 = primCdr(_35p2164);
Obj _35reg3515 = primCar(_35reg3514);
Obj _35reg3516 = primCdr(_35reg3515);
Obj _35reg3517 = primCdr(_35reg3516);
Obj _35reg3518 = primCdr(_35reg3517);
Obj _35reg3519 = primIsCons(_35reg3518);
if (True == _35reg3519) {
Obj _35reg3520 = primCdr(_35p2164);
Obj _35reg3521 = primCar(_35reg3520);
Obj _35reg3522 = primCdr(_35reg3521);
Obj _35reg3523 = primCdr(_35reg3522);
Obj _35reg3524 = primCdr(_35reg3523);
Obj _35reg3525 = primCar(_35reg3524);
Obj body = _35reg3525;
Obj _35reg3526 = primCdr(_35p2164);
Obj _35reg3527 = primCar(_35reg3526);
Obj _35reg3528 = primCdr(_35reg3527);
Obj _35reg3529 = primCdr(_35reg3528);
Obj _35reg3530 = primCdr(_35reg3529);
Obj _35reg3531 = primCdr(_35reg3530);
Obj _35reg3532 = primEQ(Nil, _35reg3531);
if (True == _35reg3532) {
Obj _35reg3533 = primCdr(_35p2164);
Obj _35reg3534 = primCdr(_35reg3533);
Obj _35reg3535 = primEQ(Nil, _35reg3534);
if (True == _35reg3535) {
pushCont(co, _35clofun3964, 4, actives, params, body, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-func-declare"));
co->args[1] = w;
co->args[2] = name;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2165;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3964(struct Cora* co) {
Obj _35val3536 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3965, 4, actives, params, body, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" {\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3965(struct Cora* co) {
Obj _35val3537 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3966, 4, actives, params, body, w);
co->nargs = 6;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = Nil;
co->args[2] = w;
co->args[3] = makeString1(" = co->args[");
co->args[4] = makeNumber(1);
co->args[5] = params;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3966(struct Cora* co) {
Obj _35val3538 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3967, 3, params, body, w);
co->nargs = 6;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = Nil;
co->args[2] = w;
co->args[3] = makeString1(" = co->stack[co->base + ");
co->args[4] = makeNumber(0);
co->args[5] = actives;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3967(struct Cora* co) {
Obj _35val3539 = co->args[1];
Obj params = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3968, 1, w);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = params;
co->args[2] = w;
co->args[3] = body;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3968(struct Cora* co) {
Obj _35val3540 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("}\n\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3963(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3954(struct Cora* co) {
Obj _35p2156 = co->args[1];
Obj _35p2157 = co->args[2];
Obj _35p2158 = co->args[3];
Obj _35p2159 = co->args[4];
Obj _35p2160 = co->args[5];
Obj _35cc2161 = makeNative(_35clofun3955, 0, 5, _35p2156, _35p2157, _35p2158, _35p2159, _35p2160);
Obj env = _35p2156;
Obj w = _35p2157;
Obj dest_45str = _35p2158;
Obj idx = _35p2159;
Obj _35reg3483 = primEQ(Nil, _35p2160);
if (True == _35reg3483) {
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2161;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3955(struct Cora* co) {
Obj _35cc2162 = makeNative(_35clofun3956, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj dest_45str = closureRef(co, 2);
Obj idx = closureRef(co, 3);
Obj _35reg3474 = primIsCons(closureRef(co, 4));
if (True == _35reg3474) {
Obj _35reg3475 = primCar(closureRef(co, 4));
Obj a = _35reg3475;
Obj _35reg3476 = primCdr(closureRef(co, 4));
Obj b = _35reg3476;
pushCont(co, _35clofun3957, 6, a, idx, env, w, dest_45str, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Obj ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2162;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3957(struct Cora* co) {
Obj _35val3477 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj dest_45str = co->stack[co->base + 4];
Obj b = co->stack[co->base + 5];
pushCont(co, _35clofun3958, 5, idx, env, w, dest_45str, b);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3958(struct Cora* co) {
Obj _35val3478 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3959, 5, idx, env, w, dest_45str, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = dest_45str;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3959(struct Cora* co) {
Obj _35val3479 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3960, 5, idx, env, w, dest_45str, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = idx;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3960(struct Cora* co) {
Obj _35val3480 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3961, 5, idx, env, w, dest_45str, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("];\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3961(struct Cora* co) {
Obj _35val3481 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
Obj _35reg3482 = primAdd(idx, makeNumber(1));
co->nargs = 6;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = dest_45str;
co->args[4] = _35reg3482;
co->args[5] = b;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3956(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3950(struct Cora* co) {
Obj w = co->args[1];
Obj name = co->args[2];
pushCont(co, _35clofun3951, 2, name, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("void ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3951(struct Cora* co) {
Obj _35val3470 = co->args[1];
Obj name = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3952, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = name;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3952(struct Cora* co) {
Obj _35val3471 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3953, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("(struct Cora* co");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3953(struct Cora* co) {
Obj _35val3472 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3949(struct Cora* co) {
Obj env = co->args[1];
Obj w = co->args[2];
Obj l = co->args[3];
co->nargs = 5;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[3] = w;
co->args[4] = l;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3943(struct Cora* co) {
Obj _35p2150 = co->args[1];
Obj _35p2151 = co->args[2];
Obj _35p2152 = co->args[3];
Obj _35p2153 = co->args[4];
Obj _35cc2154 = makeNative(_35clofun3944, 0, 4, _35p2150, _35p2151, _35p2152, _35p2153);
Obj env = _35p2150;
Obj fn = _35p2151;
Obj w = _35p2152;
Obj _35reg3467 = primEQ(Nil, _35p2153);
if (True == _35reg3467) {
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2154;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3944(struct Cora* co) {
Obj _35cc2155 = makeNative(_35clofun3945, 0, 0);
Obj env = closureRef(co, 0);
Obj fn = closureRef(co, 1);
Obj w = closureRef(co, 2);
Obj _35reg3460 = primIsCons(closureRef(co, 3));
if (True == _35reg3460) {
Obj _35reg3461 = primCar(closureRef(co, 3));
Obj a = _35reg3461;
Obj _35reg3462 = primCdr(closureRef(co, 3));
Obj b = _35reg3462;
pushCont(co, _35clofun3946, 4, env, fn, w, b);
co->nargs = 4;
co->args[0] = fn;
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2155;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3946(struct Cora* co) {
Obj _35val3463 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
pushCont(co, _35clofun3947, 4, env, fn, w, b);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = b;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3947(struct Cora* co) {
Obj _35val3464 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
Obj _35reg3465 = primNot(_35val3464);
if (True == _35reg3465) {
pushCont(co, _35clofun3948, 4, env, fn, w, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->nargs = 5;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = fn;
co->args[3] = w;
co->args[4] = b;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3948(struct Cora* co) {
Obj _35val3466 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
co->nargs = 5;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = fn;
co->args[3] = w;
co->args[4] = b;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3945(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3932(struct Cora* co) {
Obj _35p2147 = co->args[1];
Obj _35p2148 = co->args[2];
Obj _35cc2149 = makeNative(_35clofun3933, 0, 0);
Obj w = _35p2147;
Obj _35reg3441 = primIsCons(_35p2148);
if (True == _35reg3441) {
Obj _35reg3442 = primCar(_35p2148);
Obj _35reg3443 = primEQ(intern("%continuation"), _35reg3442);
if (True == _35reg3443) {
Obj _35reg3444 = primCdr(_35p2148);
Obj _35reg3445 = primIsCons(_35reg3444);
if (True == _35reg3445) {
Obj _35reg3446 = primCdr(_35p2148);
Obj _35reg3447 = primCar(_35reg3446);
Obj label = _35reg3447;
Obj _35reg3448 = primCdr(_35p2148);
Obj _35reg3449 = primCdr(_35reg3448);
Obj stacks = _35reg3449;
pushCont(co, _35clofun3934, 3, label, stacks, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("pushCont(co, ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2149;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2149;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2149;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3934(struct Cora* co) {
Obj _35val3450 = co->args[1];
Obj label = co->stack[co->base + 0];
Obj stacks = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3935, 2, stacks, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = label;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3935(struct Cora* co) {
Obj _35val3451 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3936, 2, stacks, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3936(struct Cora* co) {
Obj _35val3452 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3937, 2, stacks, w);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = stacks;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3937(struct Cora* co) {
Obj _35val3453 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3938, 2, stacks, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = _35val3453;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3938(struct Cora* co) {
Obj _35val3454 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3939, 2, stacks, w);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = stacks;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3939(struct Cora* co) {
Obj _35val3455 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj _35reg3456 = primNot(_35val3455);
if (True == _35reg3456) {
pushCont(co, _35clofun3942, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3940, 1, 1, w);
co->args[2] = stacks;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(");\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3942(struct Cora* co) {
Obj _35val3458 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(");\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3940(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun3941, 1, x);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = closureRef(co, 0);
co->args[2] = makeString1(", ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3941(struct Cora* co) {
Obj _35val3457 = co->args[1];
Obj x = co->stack[co->base + 0];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = Nil;
co->args[2] = closureRef(co, 0);
co->args[3] = x;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3933(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3924(struct Cora* co) {
Obj _35p2141 = co->args[1];
Obj _35p2142 = co->args[2];
Obj _35p2143 = co->args[3];
Obj _35p2144 = co->args[4];
Obj _35cc2145 = makeNative(_35clofun3925, 0, 4, _35p2141, _35p2142, _35p2143, _35p2144);
Obj env = _35p2141;
Obj w = _35p2142;
Obj idx = _35p2143;
Obj _35reg3439 = primEQ(Nil, _35p2144);
if (True == _35reg3439) {
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2145;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3925(struct Cora* co) {
Obj _35cc2146 = makeNative(_35clofun3926, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj idx = closureRef(co, 2);
Obj _35reg3430 = primIsCons(closureRef(co, 3));
if (True == _35reg3430) {
Obj _35reg3431 = primCar(closureRef(co, 3));
Obj a = _35reg3431;
Obj _35reg3432 = primCdr(closureRef(co, 3));
Obj b = _35reg3432;
pushCont(co, _35clofun3927, 5, a, idx, env, w, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->args[");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2146;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3927(struct Cora* co) {
Obj _35val3433 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3928, 5, a, idx, env, w, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = idx;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3928(struct Cora* co) {
Obj _35val3434 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3929, 5, a, idx, env, w, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("] = ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3929(struct Cora* co) {
Obj _35val3435 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3930, 4, idx, env, w, b);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3930(struct Cora* co) {
Obj _35val3436 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
pushCont(co, _35clofun3931, 4, idx, env, w, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3931(struct Cora* co) {
Obj _35val3437 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
Obj _35reg3438 = primAdd(idx, makeNumber(1));
co->nargs = 5;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = _35reg3438;
co->args[4] = b;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3926(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3843(struct Cora* co) {
Obj _35p2124 = co->args[1];
Obj _35p2125 = co->args[2];
Obj _35p2126 = co->args[3];
Obj _35cc2127 = makeNative(_35clofun3844, 0, 3, _35p2124, _35p2125, _35p2126);
Obj env = _35p2124;
Obj w = _35p2125;
Obj x = _35p2126;
Obj _35reg3428 = primIsSymbol(x);
if (True == _35reg3428) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = x;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2127;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3844(struct Cora* co) {
Obj _35cc2128 = makeNative(_35clofun3845, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3415 = primIsCons(closureRef(co, 2));
if (True == _35reg3415) {
Obj _35reg3416 = primCar(closureRef(co, 2));
Obj _35reg3417 = primEQ(intern("%global"), _35reg3416);
if (True == _35reg3417) {
Obj _35reg3418 = primCdr(closureRef(co, 2));
Obj _35reg3419 = primIsCons(_35reg3418);
if (True == _35reg3419) {
Obj _35reg3420 = primCdr(closureRef(co, 2));
Obj _35reg3421 = primCar(_35reg3420);
Obj x = _35reg3421;
Obj _35reg3422 = primCdr(closureRef(co, 2));
Obj _35reg3423 = primCdr(_35reg3422);
Obj _35reg3424 = primEQ(Nil, _35reg3423);
if (True == _35reg3424) {
pushCont(co, _35clofun3921, 2, x, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("globalRef(intern(\"");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2128;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2128;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2128;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2128;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3921(struct Cora* co) {
Obj _35val3425 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3922, 1, w);
co->nargs = 2;
co->args[0] = globalRef(intern("symbol->string"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3922(struct Cora* co) {
Obj _35val3426 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3923, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = _35val3426;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3923(struct Cora* co) {
Obj _35val3427 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\"))");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3845(struct Cora* co) {
Obj _35cc2129 = makeNative(_35clofun3846, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3403 = primIsCons(closureRef(co, 2));
if (True == _35reg3403) {
Obj _35reg3404 = primCar(closureRef(co, 2));
Obj _35reg3405 = primEQ(intern("%closure-ref"), _35reg3404);
if (True == _35reg3405) {
Obj _35reg3406 = primCdr(closureRef(co, 2));
Obj _35reg3407 = primIsCons(_35reg3406);
if (True == _35reg3407) {
Obj _35reg3408 = primCdr(closureRef(co, 2));
Obj _35reg3409 = primCar(_35reg3408);
Obj idx = _35reg3409;
Obj _35reg3410 = primCdr(closureRef(co, 2));
Obj _35reg3411 = primCdr(_35reg3410);
Obj _35reg3412 = primEQ(Nil, _35reg3411);
if (True == _35reg3412) {
pushCont(co, _35clofun3919, 2, idx, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("closureRef(co, ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2129;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2129;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2129;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2129;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3919(struct Cora* co) {
Obj _35val3413 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3920, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = idx;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3920(struct Cora* co) {
Obj _35val3414 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3846(struct Cora* co) {
Obj _35cc2130 = makeNative(_35clofun3847, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3391 = primIsCons(closureRef(co, 2));
if (True == _35reg3391) {
Obj _35reg3392 = primCar(closureRef(co, 2));
Obj _35reg3393 = primEQ(intern("%stack-ref"), _35reg3392);
if (True == _35reg3393) {
Obj _35reg3394 = primCdr(closureRef(co, 2));
Obj _35reg3395 = primIsCons(_35reg3394);
if (True == _35reg3395) {
Obj _35reg3396 = primCdr(closureRef(co, 2));
Obj _35reg3397 = primCar(_35reg3396);
Obj idx = _35reg3397;
Obj _35reg3398 = primCdr(closureRef(co, 2));
Obj _35reg3399 = primCdr(_35reg3398);
Obj _35reg3400 = primEQ(Nil, _35reg3399);
if (True == _35reg3400) {
pushCont(co, _35clofun3917, 2, idx, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("stackRef(co, ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2130;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2130;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2130;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2130;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3917(struct Cora* co) {
Obj _35val3401 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3918, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = idx;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3918(struct Cora* co) {
Obj _35val3402 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3847(struct Cora* co) {
Obj _35cc2131 = makeNative(_35clofun3848, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3367 = primIsCons(closureRef(co, 2));
if (True == _35reg3367) {
Obj _35reg3368 = primCar(closureRef(co, 2));
Obj _35reg3369 = primEQ(intern("%const"), _35reg3368);
if (True == _35reg3369) {
Obj _35reg3370 = primCdr(closureRef(co, 2));
Obj _35reg3371 = primIsCons(_35reg3370);
if (True == _35reg3371) {
Obj _35reg3372 = primCdr(closureRef(co, 2));
Obj _35reg3373 = primCar(_35reg3372);
Obj x = _35reg3373;
Obj _35reg3374 = primCdr(closureRef(co, 2));
Obj _35reg3375 = primCdr(_35reg3374);
Obj _35reg3376 = primEQ(Nil, _35reg3375);
if (True == _35reg3376) {
Obj _35reg3377 = primIsSymbol(x);
if (True == _35reg3377) {
pushCont(co, _35clofun3908, 2, x, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("intern(\"");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun3911, 2, x, w);
co->nargs = 2;
co->args[0] = globalRef(intern("number?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2131;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2131;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2131;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2131;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3911(struct Cora* co) {
Obj _35val3381 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
if (True == _35val3381) {
pushCont(co, _35clofun3912, 2, x, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeNumber(");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3384 = primIsString(x);
if (True == _35reg3384) {
pushCont(co, _35clofun3914, 2, x, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeString1(\"");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3388 = primEQ(x, Nil);
if (True == _35reg3388) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Nil");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3389 = primEQ(x, True);
if (True == _35reg3389) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("True");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3390 = primEQ(x, False);
if (True == _35reg3390) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("False");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
}
}
}

void _35clofun3914(struct Cora* co) {
Obj _35val3385 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3915, 1, w);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/internal.escape-str"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3915(struct Cora* co) {
Obj _35val3386 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3916, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = _35val3386;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3916(struct Cora* co) {
Obj _35val3387 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3912(struct Cora* co) {
Obj _35val3382 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3913, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = x;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3913(struct Cora* co) {
Obj _35val3383 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3908(struct Cora* co) {
Obj _35val3378 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3909, 1, w);
co->nargs = 2;
co->args[0] = globalRef(intern("symbol->string"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3909(struct Cora* co) {
Obj _35val3379 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3910, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = _35val3379;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3910(struct Cora* co) {
Obj _35val3380 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3848(struct Cora* co) {
Obj _35cc2132 = makeNative(_35clofun3849, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3328 = primIsCons(closureRef(co, 2));
if (True == _35reg3328) {
Obj _35reg3329 = primCar(closureRef(co, 2));
Obj _35reg3330 = primEQ(intern("let"), _35reg3329);
if (True == _35reg3330) {
Obj _35reg3331 = primCdr(closureRef(co, 2));
Obj _35reg3332 = primIsCons(_35reg3331);
if (True == _35reg3332) {
Obj _35reg3333 = primCdr(closureRef(co, 2));
Obj _35reg3334 = primCar(_35reg3333);
Obj a = _35reg3334;
Obj _35reg3335 = primCdr(closureRef(co, 2));
Obj _35reg3336 = primCdr(_35reg3335);
Obj _35reg3337 = primIsCons(_35reg3336);
if (True == _35reg3337) {
Obj _35reg3338 = primCdr(closureRef(co, 2));
Obj _35reg3339 = primCdr(_35reg3338);
Obj _35reg3340 = primCar(_35reg3339);
Obj b = _35reg3340;
Obj _35reg3341 = primCdr(closureRef(co, 2));
Obj _35reg3342 = primCdr(_35reg3341);
Obj _35reg3343 = primCdr(_35reg3342);
Obj _35reg3344 = primIsCons(_35reg3343);
if (True == _35reg3344) {
Obj _35reg3345 = primCdr(closureRef(co, 2));
Obj _35reg3346 = primCdr(_35reg3345);
Obj _35reg3347 = primCdr(_35reg3346);
Obj _35reg3348 = primCar(_35reg3347);
Obj c = _35reg3348;
Obj _35reg3349 = primCdr(closureRef(co, 2));
Obj _35reg3350 = primCdr(_35reg3349);
Obj _35reg3351 = primCdr(_35reg3350);
Obj _35reg3352 = primCdr(_35reg3351);
Obj _35reg3353 = primEQ(Nil, _35reg3352);
if (True == _35reg3353) {
pushCont(co, _35clofun3898, 5, b, a, env, w, c);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = a;
co->args[2] = env;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2132;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2132;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2132;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2132;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2132;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2132;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3898(struct Cora* co) {
Obj _35val3354 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
Obj idx = _35val3354;
Obj _35reg3355 = primLT(idx, makeNumber(0));
if (True == _35reg3355) {
pushCont(co, _35clofun3899, 5, b, a, env, w, c);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Obj ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
pushCont(co, _35clofun3904, 5, b, a, env, w, c);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = a;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3904(struct Cora* co) {
Obj _35val3362 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3905, 5, b, a, env, w, c);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" = ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3905(struct Cora* co) {
Obj _35val3363 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3906, 4, a, env, w, c);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3906(struct Cora* co) {
Obj _35val3364 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
pushCont(co, _35clofun3907, 4, a, env, w, c);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3907(struct Cora* co) {
Obj _35val3365 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj _35reg3366 = primCons(a, env);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = _35reg3366;
co->args[2] = w;
co->args[3] = c;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3899(struct Cora* co) {
Obj _35val3356 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3900, 5, b, a, env, w, c);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = a;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3900(struct Cora* co) {
Obj _35val3357 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3901, 5, b, a, env, w, c);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" = ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3901(struct Cora* co) {
Obj _35val3358 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3902, 4, a, env, w, c);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3902(struct Cora* co) {
Obj _35val3359 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
pushCont(co, _35clofun3903, 4, a, env, w, c);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3903(struct Cora* co) {
Obj _35val3360 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj _35reg3361 = primCons(a, env);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = _35reg3361;
co->args[2] = w;
co->args[3] = c;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3849(struct Cora* co) {
Obj _35cc2133 = makeNative(_35clofun3850, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3307 = primIsCons(closureRef(co, 2));
if (True == _35reg3307) {
Obj _35reg3308 = primCar(closureRef(co, 2));
Obj _35reg3309 = primIsCons(_35reg3308);
if (True == _35reg3309) {
Obj _35reg3310 = primCar(closureRef(co, 2));
Obj _35reg3311 = primCar(_35reg3310);
Obj _35reg3312 = primEQ(intern("%builtin"), _35reg3311);
if (True == _35reg3312) {
Obj _35reg3313 = primCar(closureRef(co, 2));
Obj _35reg3314 = primCdr(_35reg3313);
Obj _35reg3315 = primIsCons(_35reg3314);
if (True == _35reg3315) {
Obj _35reg3316 = primCar(closureRef(co, 2));
Obj _35reg3317 = primCdr(_35reg3316);
Obj _35reg3318 = primCar(_35reg3317);
Obj f = _35reg3318;
Obj _35reg3319 = primCar(closureRef(co, 2));
Obj _35reg3320 = primCdr(_35reg3319);
Obj _35reg3321 = primCdr(_35reg3320);
Obj _35reg3322 = primEQ(Nil, _35reg3321);
if (True == _35reg3322) {
Obj _35reg3323 = primCdr(closureRef(co, 2));
Obj args = _35reg3323;
pushCont(co, _35clofun3894, 3, env, args, w);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.builtin->name"));
co->args[1] = f;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2133;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2133;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2133;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2133;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2133;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3894(struct Cora* co) {
Obj _35val3324 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3895, 3, env, args, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = _35val3324;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3895(struct Cora* co) {
Obj _35val3325 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3896, 3, env, args, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("(");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3896(struct Cora* co) {
Obj _35val3326 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3897, 1, w);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = args;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3897(struct Cora* co) {
Obj _35val3327 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3850(struct Cora* co) {
Obj _35cc2134 = makeNative(_35clofun3851, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3275 = primIsCons(closureRef(co, 2));
if (True == _35reg3275) {
Obj _35reg3276 = primCar(closureRef(co, 2));
Obj _35reg3277 = primEQ(intern("if"), _35reg3276);
if (True == _35reg3277) {
Obj _35reg3278 = primCdr(closureRef(co, 2));
Obj _35reg3279 = primIsCons(_35reg3278);
if (True == _35reg3279) {
Obj _35reg3280 = primCdr(closureRef(co, 2));
Obj _35reg3281 = primCar(_35reg3280);
Obj a = _35reg3281;
Obj _35reg3282 = primCdr(closureRef(co, 2));
Obj _35reg3283 = primCdr(_35reg3282);
Obj _35reg3284 = primIsCons(_35reg3283);
if (True == _35reg3284) {
Obj _35reg3285 = primCdr(closureRef(co, 2));
Obj _35reg3286 = primCdr(_35reg3285);
Obj _35reg3287 = primCar(_35reg3286);
Obj b = _35reg3287;
Obj _35reg3288 = primCdr(closureRef(co, 2));
Obj _35reg3289 = primCdr(_35reg3288);
Obj _35reg3290 = primCdr(_35reg3289);
Obj _35reg3291 = primIsCons(_35reg3290);
if (True == _35reg3291) {
Obj _35reg3292 = primCdr(closureRef(co, 2));
Obj _35reg3293 = primCdr(_35reg3292);
Obj _35reg3294 = primCdr(_35reg3293);
Obj _35reg3295 = primCar(_35reg3294);
Obj c = _35reg3295;
Obj _35reg3296 = primCdr(closureRef(co, 2));
Obj _35reg3297 = primCdr(_35reg3296);
Obj _35reg3298 = primCdr(_35reg3297);
Obj _35reg3299 = primCdr(_35reg3298);
Obj _35reg3300 = primEQ(Nil, _35reg3299);
if (True == _35reg3300) {
pushCont(co, _35clofun3888, 5, a, b, env, c, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("if (True == ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2134;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2134;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2134;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2134;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2134;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2134;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3888(struct Cora* co) {
Obj _35val3301 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj b = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj w = co->stack[co->base + 4];
pushCont(co, _35clofun3889, 4, b, env, c, w);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3889(struct Cora* co) {
Obj _35val3302 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj c = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3890, 4, b, env, c, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(") {\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3890(struct Cora* co) {
Obj _35val3303 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj c = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3891, 3, env, c, w);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3891(struct Cora* co) {
Obj _35val3304 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3892, 3, env, c, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("} else {\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3892(struct Cora* co) {
Obj _35val3305 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3893, 1, w);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = c;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3893(struct Cora* co) {
Obj _35val3306 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("}\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3851(struct Cora* co) {
Obj _35cc2135 = makeNative(_35clofun3852, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3248 = primIsCons(closureRef(co, 2));
if (True == _35reg3248) {
Obj _35reg3249 = primCar(closureRef(co, 2));
Obj _35reg3250 = primEQ(intern("%closure"), _35reg3249);
if (True == _35reg3250) {
Obj _35reg3251 = primCdr(closureRef(co, 2));
Obj _35reg3252 = primIsCons(_35reg3251);
if (True == _35reg3252) {
Obj _35reg3253 = primCdr(closureRef(co, 2));
Obj _35reg3254 = primCar(_35reg3253);
Obj label = _35reg3254;
Obj _35reg3255 = primCdr(closureRef(co, 2));
Obj _35reg3256 = primCdr(_35reg3255);
Obj _35reg3257 = primIsCons(_35reg3256);
if (True == _35reg3257) {
Obj _35reg3258 = primCdr(closureRef(co, 2));
Obj _35reg3259 = primCdr(_35reg3258);
Obj _35reg3260 = primCar(_35reg3259);
Obj nargs = _35reg3260;
Obj _35reg3261 = primCdr(closureRef(co, 2));
Obj _35reg3262 = primCdr(_35reg3261);
Obj _35reg3263 = primCdr(_35reg3262);
Obj frees = _35reg3263;
pushCont(co, _35clofun3878, 5, label, nargs, env, frees, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeNative(");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2135;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2135;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2135;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2135;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3878(struct Cora* co) {
Obj _35val3264 = co->args[1];
Obj label = co->stack[co->base + 0];
Obj nargs = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj frees = co->stack[co->base + 3];
Obj w = co->stack[co->base + 4];
pushCont(co, _35clofun3879, 4, nargs, env, frees, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = label;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3879(struct Cora* co) {
Obj _35val3265 = co->args[1];
Obj nargs = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj frees = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3880, 4, nargs, env, frees, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3880(struct Cora* co) {
Obj _35val3266 = co->args[1];
Obj nargs = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj frees = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3881, 3, env, frees, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = nargs;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3881(struct Cora* co) {
Obj _35val3267 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3882, 3, env, frees, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3882(struct Cora* co) {
Obj _35val3268 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3883, 3, env, frees, w);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = frees;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3883(struct Cora* co) {
Obj _35val3269 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3884, 3, env, frees, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = _35val3269;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3884(struct Cora* co) {
Obj _35val3270 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3885, 3, env, frees, w);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = frees;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3885(struct Cora* co) {
Obj _35val3271 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj _35reg3272 = primNot(_35val3271);
if (True == _35reg3272) {
pushCont(co, _35clofun3886, 3, env, frees, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3886(struct Cora* co) {
Obj _35val3273 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3887, 1, w);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = frees;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3887(struct Cora* co) {
Obj _35val3274 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3852(struct Cora* co) {
Obj _35cc2136 = makeNative(_35clofun3853, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3229 = primIsCons(closureRef(co, 2));
if (True == _35reg3229) {
Obj _35reg3230 = primCar(closureRef(co, 2));
Obj _35reg3231 = primEQ(intern("do"), _35reg3230);
if (True == _35reg3231) {
Obj _35reg3232 = primCdr(closureRef(co, 2));
Obj _35reg3233 = primIsCons(_35reg3232);
if (True == _35reg3233) {
Obj _35reg3234 = primCdr(closureRef(co, 2));
Obj _35reg3235 = primCar(_35reg3234);
Obj a = _35reg3235;
Obj _35reg3236 = primCdr(closureRef(co, 2));
Obj _35reg3237 = primCdr(_35reg3236);
Obj _35reg3238 = primIsCons(_35reg3237);
if (True == _35reg3238) {
Obj _35reg3239 = primCdr(closureRef(co, 2));
Obj _35reg3240 = primCdr(_35reg3239);
Obj _35reg3241 = primCar(_35reg3240);
Obj b = _35reg3241;
Obj _35reg3242 = primCdr(closureRef(co, 2));
Obj _35reg3243 = primCdr(_35reg3242);
Obj _35reg3244 = primCdr(_35reg3243);
Obj _35reg3245 = primEQ(Nil, _35reg3244);
if (True == _35reg3245) {
pushCont(co, _35clofun3876, 3, env, w, b);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2136;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2136;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2136;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2136;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2136;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3876(struct Cora* co) {
Obj _35val3246 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj b = co->stack[co->base + 2];
pushCont(co, _35clofun3877, 3, env, w, b);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3877(struct Cora* co) {
Obj _35val3247 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj b = co->stack[co->base + 2];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3853(struct Cora* co) {
Obj _35cc2137 = makeNative(_35clofun3854, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3215 = primIsCons(closureRef(co, 2));
if (True == _35reg3215) {
Obj _35reg3216 = primCar(closureRef(co, 2));
Obj _35reg3217 = primEQ(intern("return"), _35reg3216);
if (True == _35reg3217) {
Obj _35reg3218 = primCdr(closureRef(co, 2));
Obj _35reg3219 = primIsCons(_35reg3218);
if (True == _35reg3219) {
Obj _35reg3220 = primCdr(closureRef(co, 2));
Obj _35reg3221 = primCar(_35reg3220);
Obj x = _35reg3221;
Obj _35reg3222 = primCdr(closureRef(co, 2));
Obj _35reg3223 = primCdr(_35reg3222);
Obj _35reg3224 = primEQ(Nil, _35reg3223);
if (True == _35reg3224) {
pushCont(co, _35clofun3872, 3, env, x, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->nargs = 2;\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2137;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2137;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2137;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2137;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3872(struct Cora* co) {
Obj _35val3225 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj x = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3873, 3, env, x, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->args[1] = ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3873(struct Cora* co) {
Obj _35val3226 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj x = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3874, 1, w);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = x;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3874(struct Cora* co) {
Obj _35val3227 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3875, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\npopStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3875(struct Cora* co) {
Obj _35val3228 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\nreturn;\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3854(struct Cora* co) {
Obj _35cc2138 = makeNative(_35clofun3855, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3205 = primIsCons(closureRef(co, 2));
if (True == _35reg3205) {
Obj _35reg3206 = primCar(closureRef(co, 2));
Obj _35reg3207 = primEQ(intern("tailcall"), _35reg3206);
if (True == _35reg3207) {
Obj _35reg3208 = primCdr(closureRef(co, 2));
Obj _35reg3209 = primIsCons(_35reg3208);
if (True == _35reg3209) {
Obj _35reg3210 = primCdr(closureRef(co, 2));
Obj _35reg3211 = primCar(_35reg3210);
Obj exp = _35reg3211;
Obj _35reg3212 = primCdr(closureRef(co, 2));
Obj _35reg3213 = primCdr(_35reg3212);
Obj _35reg3214 = primEQ(Nil, _35reg3213);
if (True == _35reg3214) {
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = exp;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2138;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2138;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2138;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2138;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3855(struct Cora* co) {
Obj _35cc2139 = makeNative(_35clofun3856, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3187 = primIsCons(closureRef(co, 2));
if (True == _35reg3187) {
Obj _35reg3188 = primCar(closureRef(co, 2));
Obj _35reg3189 = primEQ(intern("call"), _35reg3188);
if (True == _35reg3189) {
Obj _35reg3190 = primCdr(closureRef(co, 2));
Obj _35reg3191 = primIsCons(_35reg3190);
if (True == _35reg3191) {
Obj _35reg3192 = primCdr(closureRef(co, 2));
Obj _35reg3193 = primCar(_35reg3192);
Obj exp = _35reg3193;
Obj _35reg3194 = primCdr(closureRef(co, 2));
Obj _35reg3195 = primCdr(_35reg3194);
Obj _35reg3196 = primIsCons(_35reg3195);
if (True == _35reg3196) {
Obj _35reg3197 = primCdr(closureRef(co, 2));
Obj _35reg3198 = primCdr(_35reg3197);
Obj _35reg3199 = primCar(_35reg3198);
Obj cont = _35reg3199;
Obj _35reg3200 = primCdr(closureRef(co, 2));
Obj _35reg3201 = primCdr(_35reg3200);
Obj _35reg3202 = primCdr(_35reg3201);
Obj _35reg3203 = primEQ(Nil, _35reg3202);
if (True == _35reg3203) {
pushCont(co, _35clofun3871, 3, env, w, exp);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-cont"));
co->args[1] = w;
co->args[2] = cont;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2139;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2139;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2139;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2139;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2139;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3871(struct Cora* co) {
Obj _35val3204 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj exp = co->stack[co->base + 2];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = exp;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3856(struct Cora* co) {
Obj _35cc2140 = makeNative(_35clofun3857, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg3169 = primIsCons(closureRef(co, 2));
if (True == _35reg3169) {
Obj _35reg3170 = primCar(closureRef(co, 2));
Obj f = _35reg3170;
Obj _35reg3171 = primCdr(closureRef(co, 2));
Obj args = _35reg3171;
pushCont(co, _35clofun3858, 4, f, env, args, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->nargs = ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2140;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3858(struct Cora* co) {
Obj _35val3172 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj args = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj _35reg3173 = primCons(f, args);
pushCont(co, _35clofun3859, 4, f, env, args, w);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = _35reg3173;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3859(struct Cora* co) {
Obj _35val3174 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj args = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3860, 4, f, env, args, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = _35val3174;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3860(struct Cora* co) {
Obj _35val3175 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj args = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3861, 4, f, env, args, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3861(struct Cora* co) {
Obj _35val3176 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj args = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj _35reg3177 = primCons(f, args);
pushCont(co, _35clofun3862, 2, args, w);
co->nargs = 5;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = makeNumber(0);
co->args[4] = _35reg3177;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3862(struct Cora* co) {
Obj _35val3178 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3863, 2, args, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("if (nativeRequired(co->args[0]) == ");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3863(struct Cora* co) {
Obj _35val3179 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3864, 1, w);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = args;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3864(struct Cora* co) {
Obj _35val3180 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3865, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = _35val3180;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3865(struct Cora* co) {
Obj _35val3181 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3866, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(") {\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3866(struct Cora* co) {
Obj _35val3182 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3867, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->pc = nativeFuncPtr(co->args[0]);\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3867(struct Cora* co) {
Obj _35val3183 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3868, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->frees = co->args[0];\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3868(struct Cora* co) {
Obj _35val3184 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3869, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("} else {\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3869(struct Cora* co) {
Obj _35val3185 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3870, 1, w);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->pc = coraCall;\n}\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3870(struct Cora* co) {
Obj _35val3186 = co->args[1];
Obj w = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("return;\n");
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3857(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3841(struct Cora* co) {
Obj x = co->args[1];
Obj k = co->args[2];
Obj _35reg3162 = primGenSym(intern("reg"));
Obj tmp = _35reg3162;
pushCont(co, _35clofun3842, 2, x, tmp);
co->nargs = 2;
co->args[0] = k;
co->args[1] = tmp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3842(struct Cora* co) {
Obj _35val3163 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj tmp = co->stack[co->base + 1];
Obj _35reg3164 = primCons(_35val3163, Nil);
Obj _35reg3165 = primCons(x, _35reg3164);
Obj _35reg3166 = primCons(tmp, _35reg3165);
Obj _35reg3167 = primCons(intern("let"), _35reg3166);
co->nargs = 2;
co->args[1] = _35reg3167;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3836(struct Cora* co) {
Obj _35p2118 = co->args[1];
Obj _35p2119 = co->args[2];
Obj _35p2120 = co->args[3];
Obj _35p2121 = co->args[4];
Obj _35cc2122 = makeNative(_35clofun3837, 0, 4, _35p2118, _35p2119, _35p2120, _35p2121);
Obj res = _35p2118;
Obj init = _35p2119;
Obj _35reg3159 = primEQ(Nil, _35p2120);
if (True == _35reg3159) {
Obj k = _35p2121;
pushCont(co, _35clofun3840, 2, k, init);
co->nargs = 2;
co->args[0] = globalRef(intern("reverse"));
co->args[1] = res;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2122;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3840(struct Cora* co) {
Obj _35val3160 = co->args[1];
Obj k = co->stack[co->base + 0];
Obj init = co->stack[co->base + 1];
co->nargs = 3;
co->args[0] = k;
co->args[1] = init;
co->args[2] = _35val3160;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3837(struct Cora* co) {
Obj _35cc2123 = makeNative(_35clofun3838, 0, 0);
Obj res = closureRef(co, 0);
Obj init = closureRef(co, 1);
Obj _35reg3155 = primIsCons(closureRef(co, 2));
if (True == _35reg3155) {
Obj _35reg3156 = primCar(closureRef(co, 2));
Obj x = _35reg3156;
Obj _35reg3157 = primCdr(closureRef(co, 2));
Obj y = _35reg3157;
Obj k = closureRef(co, 3);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = init;
co->args[2] = x;
co->args[3] = makeNative(_35clofun3839, 2, 3, res, y, k);
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2123;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3839(struct Cora* co) {
Obj init1 = co->args[1];
Obj x1 = co->args[2];
Obj _35reg3158 = primCons(x1, closureRef(co, 0));
co->nargs = 5;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-list"));
co->args[1] = _35reg3158;
co->args[2] = init1;
co->args[3] = closureRef(co, 1);
co->args[4] = closureRef(co, 2);
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3838(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3826(struct Cora* co) {
Obj _35p2112 = co->args[1];
Obj _35p2113 = co->args[2];
Obj _35p2114 = co->args[3];
Obj _35cc2115 = makeNative(_35clofun3827, 0, 3, _35p2112, _35p2113, _35p2114);
Obj res = _35p2112;
Obj _35reg3049 = primIsCons(_35p2113);
if (True == _35reg3049) {
Obj _35reg3050 = primCar(_35p2113);
Obj clo_45or_45cont = _35reg3050;
Obj _35reg3051 = primCdr(_35p2113);
Obj _35reg3052 = primIsCons(_35reg3051);
if (True == _35reg3052) {
Obj _35reg3053 = primCdr(_35p2113);
Obj _35reg3054 = primCar(_35reg3053);
Obj _35reg3055 = primIsCons(_35reg3054);
if (True == _35reg3055) {
Obj _35reg3056 = primCdr(_35p2113);
Obj _35reg3057 = primCar(_35reg3056);
Obj _35reg3058 = primCar(_35reg3057);
Obj _35reg3059 = primEQ(intern("lambda"), _35reg3058);
if (True == _35reg3059) {
Obj _35reg3060 = primCdr(_35p2113);
Obj _35reg3061 = primCar(_35reg3060);
Obj _35reg3062 = primCdr(_35reg3061);
Obj _35reg3063 = primIsCons(_35reg3062);
if (True == _35reg3063) {
Obj _35reg3064 = primCdr(_35p2113);
Obj _35reg3065 = primCar(_35reg3064);
Obj _35reg3066 = primCdr(_35reg3065);
Obj _35reg3067 = primCar(_35reg3066);
Obj params = _35reg3067;
Obj _35reg3068 = primCdr(_35p2113);
Obj _35reg3069 = primCar(_35reg3068);
Obj _35reg3070 = primCdr(_35reg3069);
Obj _35reg3071 = primCdr(_35reg3070);
Obj _35reg3072 = primIsCons(_35reg3071);
if (True == _35reg3072) {
Obj _35reg3073 = primCdr(_35p2113);
Obj _35reg3074 = primCar(_35reg3073);
Obj _35reg3075 = primCdr(_35reg3074);
Obj _35reg3076 = primCdr(_35reg3075);
Obj _35reg3077 = primCar(_35reg3076);
Obj body = _35reg3077;
Obj _35reg3078 = primCdr(_35p2113);
Obj _35reg3079 = primCar(_35reg3078);
Obj _35reg3080 = primCdr(_35reg3079);
Obj _35reg3081 = primCdr(_35reg3080);
Obj _35reg3082 = primCdr(_35reg3081);
Obj _35reg3083 = primEQ(Nil, _35reg3082);
if (True == _35reg3083) {
Obj _35reg3084 = primCdr(_35p2113);
Obj _35reg3085 = primCdr(_35reg3084);
Obj fvs = _35reg3085;
Obj k = _35p2114;
Obj _35reg3086 = primEQ(clo_45or_45cont, intern("%closure"));
if (True == _35reg3086) {
if (True == True) {
Obj _35reg3087 = primGenSym(intern("clofun"));
Obj name = _35reg3087;
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3830, 2, 5, k, params, clo_45or_45cont, name, fvs);
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
Obj _35reg3109 = primEQ(clo_45or_45cont, intern("%continuation"));
if (True == _35reg3109) {
if (True == True) {
Obj _35reg3110 = primGenSym(intern("clofun"));
Obj name = _35reg3110;
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3832, 2, 5, k, params, clo_45or_45cont, name, fvs);
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg3132 = primGenSym(intern("clofun"));
Obj name = _35reg3132;
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3834, 2, 5, k, params, clo_45or_45cont, name, fvs);
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2115;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3834(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg3133 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg3133) {
Obj _35reg3134 = primCons(body1, Nil);
Obj _35reg3135 = primCons(Nil, _35reg3134);
Obj _35reg3136 = primCons(closureRef(co, 1), _35reg3135);
Obj _35reg3137 = primCons(intern("lambda"), _35reg3136);
Obj _35reg3138 = primCons(_35reg3137, Nil);
Obj _35reg3139 = primCons(closureRef(co, 3), _35reg3138);
Obj _35reg3140 = primCons(_35reg3139, res1);
pushCont(co, _35clofun3835, 1, _35reg3140);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3145 = primCons(body1, Nil);
Obj _35reg3146 = primCons(closureRef(co, 4), _35reg3145);
Obj _35reg3147 = primCons(closureRef(co, 1), _35reg3146);
Obj _35reg3148 = primCons(intern("lambda"), _35reg3147);
Obj _35reg3149 = primCons(_35reg3148, Nil);
Obj _35reg3150 = primCons(closureRef(co, 3), _35reg3149);
Obj _35reg3151 = primCons(_35reg3150, res1);
Obj _35reg3152 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg3153 = primCons(closureRef(co, 2), _35reg3152);
co->nargs = 3;
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg3151;
co->args[2] = _35reg3153;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3835(struct Cora* co) {
Obj _35val3141 = co->args[1];
Obj _35reg3140 = co->stack[co->base + 0];
Obj _35reg3142 = primCons(_35val3141, closureRef(co, 4));
Obj _35reg3143 = primCons(closureRef(co, 3), _35reg3142);
Obj _35reg3144 = primCons(closureRef(co, 2), _35reg3143);
co->nargs = 3;
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg3140;
co->args[2] = _35reg3144;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3832(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg3111 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg3111) {
Obj _35reg3112 = primCons(body1, Nil);
Obj _35reg3113 = primCons(Nil, _35reg3112);
Obj _35reg3114 = primCons(closureRef(co, 1), _35reg3113);
Obj _35reg3115 = primCons(intern("lambda"), _35reg3114);
Obj _35reg3116 = primCons(_35reg3115, Nil);
Obj _35reg3117 = primCons(closureRef(co, 3), _35reg3116);
Obj _35reg3118 = primCons(_35reg3117, res1);
pushCont(co, _35clofun3833, 1, _35reg3118);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3123 = primCons(body1, Nil);
Obj _35reg3124 = primCons(closureRef(co, 4), _35reg3123);
Obj _35reg3125 = primCons(closureRef(co, 1), _35reg3124);
Obj _35reg3126 = primCons(intern("lambda"), _35reg3125);
Obj _35reg3127 = primCons(_35reg3126, Nil);
Obj _35reg3128 = primCons(closureRef(co, 3), _35reg3127);
Obj _35reg3129 = primCons(_35reg3128, res1);
Obj _35reg3130 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg3131 = primCons(closureRef(co, 2), _35reg3130);
co->nargs = 3;
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg3129;
co->args[2] = _35reg3131;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3833(struct Cora* co) {
Obj _35val3119 = co->args[1];
Obj _35reg3118 = co->stack[co->base + 0];
Obj _35reg3120 = primCons(_35val3119, closureRef(co, 4));
Obj _35reg3121 = primCons(closureRef(co, 3), _35reg3120);
Obj _35reg3122 = primCons(closureRef(co, 2), _35reg3121);
co->nargs = 3;
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg3118;
co->args[2] = _35reg3122;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3830(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg3088 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg3088) {
Obj _35reg3089 = primCons(body1, Nil);
Obj _35reg3090 = primCons(Nil, _35reg3089);
Obj _35reg3091 = primCons(closureRef(co, 1), _35reg3090);
Obj _35reg3092 = primCons(intern("lambda"), _35reg3091);
Obj _35reg3093 = primCons(_35reg3092, Nil);
Obj _35reg3094 = primCons(closureRef(co, 3), _35reg3093);
Obj _35reg3095 = primCons(_35reg3094, res1);
pushCont(co, _35clofun3831, 1, _35reg3095);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg3100 = primCons(body1, Nil);
Obj _35reg3101 = primCons(closureRef(co, 4), _35reg3100);
Obj _35reg3102 = primCons(closureRef(co, 1), _35reg3101);
Obj _35reg3103 = primCons(intern("lambda"), _35reg3102);
Obj _35reg3104 = primCons(_35reg3103, Nil);
Obj _35reg3105 = primCons(closureRef(co, 3), _35reg3104);
Obj _35reg3106 = primCons(_35reg3105, res1);
Obj _35reg3107 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg3108 = primCons(closureRef(co, 2), _35reg3107);
co->nargs = 3;
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg3106;
co->args[2] = _35reg3108;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3831(struct Cora* co) {
Obj _35val3096 = co->args[1];
Obj _35reg3095 = co->stack[co->base + 0];
Obj _35reg3097 = primCons(_35val3096, closureRef(co, 4));
Obj _35reg3098 = primCons(closureRef(co, 3), _35reg3097);
Obj _35reg3099 = primCons(closureRef(co, 2), _35reg3098);
co->nargs = 3;
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg3095;
co->args[2] = _35reg3099;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3827(struct Cora* co) {
Obj _35cc2116 = makeNative(_35clofun3828, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj res = closureRef(co, 0);
Obj f_45args = closureRef(co, 1);
Obj k = closureRef(co, 2);
Obj _35reg3048 = primIsCons(f_45args);
if (True == _35reg3048) {
co->nargs = 5;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-list"));
co->args[1] = Nil;
co->args[2] = res;
co->args[3] = f_45args;
co->args[4] = k;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2116;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3828(struct Cora* co) {
Obj _35cc2117 = makeNative(_35clofun3829, 0, 0);
Obj res = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj k = closureRef(co, 2);
co->nargs = 3;
co->args[0] = k;
co->args[1] = res;
co->args[2] = x;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3829(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3808(struct Cora* co) {
Obj _35p2104 = co->args[1];
Obj _35p2105 = co->args[2];
Obj _35cc2106 = makeNative(_35clofun3809, 0, 2, _35p2104, _35p2105);
Obj __ = _35p2104;
Obj x = _35p2105;
pushCont(co, _35clofun3825, 2, x, _35cc2106);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3825(struct Cora* co) {
Obj _35val3046 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc2106 = co->stack[co->base + 1];
if (True == _35val3046) {
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2106;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3809(struct Cora* co) {
Obj _35cc2107 = makeNative(_35clofun3810, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj var = closureRef(co, 1);
Obj _35reg3045 = primIsSymbol(var);
if (True == _35reg3045) {
co->nargs = 2;
co->args[1] = var;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2107;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3810(struct Cora* co) {
Obj _35cc2108 = makeNative(_35clofun3811, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg3024 = primIsCons(closureRef(co, 1));
if (True == _35reg3024) {
Obj _35reg3025 = primCar(closureRef(co, 1));
Obj _35reg3026 = primEQ(intern("lambda"), _35reg3025);
if (True == _35reg3026) {
Obj _35reg3027 = primCdr(closureRef(co, 1));
Obj _35reg3028 = primIsCons(_35reg3027);
if (True == _35reg3028) {
Obj _35reg3029 = primCdr(closureRef(co, 1));
Obj _35reg3030 = primCar(_35reg3029);
Obj args = _35reg3030;
Obj _35reg3031 = primCdr(closureRef(co, 1));
Obj _35reg3032 = primCdr(_35reg3031);
Obj _35reg3033 = primIsCons(_35reg3032);
if (True == _35reg3033) {
Obj _35reg3034 = primCdr(closureRef(co, 1));
Obj _35reg3035 = primCdr(_35reg3034);
Obj _35reg3036 = primCar(_35reg3035);
Obj body = _35reg3036;
Obj _35reg3037 = primCdr(closureRef(co, 1));
Obj _35reg3038 = primCdr(_35reg3037);
Obj _35reg3039 = primCdr(_35reg3038);
Obj _35reg3040 = primEQ(Nil, _35reg3039);
if (True == _35reg3040) {
pushCont(co, _35clofun3824, 1, args);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->args[2] = body;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2108;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2108;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2108;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2108;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2108;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3824(struct Cora* co) {
Obj _35val3041 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg3042 = primCons(_35val3041, Nil);
Obj _35reg3043 = primCons(args, _35reg3042);
Obj _35reg3044 = primCons(intern("lambda"), _35reg3043);
co->nargs = 2;
co->args[1] = _35reg3044;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3811(struct Cora* co) {
Obj _35cc2109 = makeNative(_35clofun3812, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2997 = primIsCons(closureRef(co, 1));
if (True == _35reg2997) {
Obj _35reg2998 = primCar(closureRef(co, 1));
Obj _35reg2999 = primEQ(intern("continuation"), _35reg2998);
if (True == _35reg2999) {
Obj _35reg3000 = primCdr(closureRef(co, 1));
Obj _35reg3001 = primIsCons(_35reg3000);
if (True == _35reg3001) {
Obj _35reg3002 = primCdr(closureRef(co, 1));
Obj _35reg3003 = primCar(_35reg3002);
Obj val = _35reg3003;
Obj _35reg3004 = primCdr(closureRef(co, 1));
Obj _35reg3005 = primCdr(_35reg3004);
Obj _35reg3006 = primIsCons(_35reg3005);
if (True == _35reg3006) {
Obj _35reg3007 = primCdr(closureRef(co, 1));
Obj _35reg3008 = primCdr(_35reg3007);
Obj _35reg3009 = primCar(_35reg3008);
Obj body = _35reg3009;
Obj _35reg3010 = primCdr(closureRef(co, 1));
Obj _35reg3011 = primCdr(_35reg3010);
Obj _35reg3012 = primCdr(_35reg3011);
Obj _35reg3013 = primEQ(Nil, _35reg3012);
if (True == _35reg3013) {
pushCont(co, _35clofun3819, 3, fvs, body, val);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2109;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2109;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2109;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2109;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2109;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3819(struct Cora* co) {
Obj _35val3014 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
pushCont(co, _35clofun3820, 3, fvs, body, val);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val3014;
co->args[2] = val;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3820(struct Cora* co) {
Obj _35val3015 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
Obj fvs1 = _35val3015;
pushCont(co, _35clofun3821, 3, fvs1, body, val);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3821(struct Cora* co) {
Obj _35val3016 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
pushCont(co, _35clofun3822, 3, fvs1, body, val);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val3016;
co->args[2] = fvs1;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3822(struct Cora* co) {
Obj _35val3017 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
Obj fvs2 = _35val3017;
pushCont(co, _35clofun3823, 2, val, fvs2);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs1;
co->args[2] = body;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3823(struct Cora* co) {
Obj _35val3018 = co->args[1];
Obj val = co->stack[co->base + 0];
Obj fvs2 = co->stack[co->base + 1];
Obj _35reg3019 = primCons(_35val3018, Nil);
Obj _35reg3020 = primCons(val, _35reg3019);
Obj _35reg3021 = primCons(intern("lambda"), _35reg3020);
Obj _35reg3022 = primCons(_35reg3021, fvs2);
Obj _35reg3023 = primCons(intern("%continuation"), _35reg3022);
co->nargs = 2;
co->args[1] = _35reg3023;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3812(struct Cora* co) {
Obj _35cc2110 = makeNative(_35clofun3813, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2974 = primIsCons(closureRef(co, 1));
if (True == _35reg2974) {
Obj _35reg2975 = primCar(closureRef(co, 1));
Obj _35reg2976 = primEQ(intern("call"), _35reg2975);
if (True == _35reg2976) {
Obj _35reg2977 = primCdr(closureRef(co, 1));
Obj _35reg2978 = primIsCons(_35reg2977);
if (True == _35reg2978) {
Obj _35reg2979 = primCdr(closureRef(co, 1));
Obj _35reg2980 = primCar(_35reg2979);
Obj exp = _35reg2980;
Obj _35reg2981 = primCdr(closureRef(co, 1));
Obj _35reg2982 = primCdr(_35reg2981);
Obj _35reg2983 = primIsCons(_35reg2982);
if (True == _35reg2983) {
Obj _35reg2984 = primCdr(closureRef(co, 1));
Obj _35reg2985 = primCdr(_35reg2984);
Obj _35reg2986 = primCar(_35reg2985);
Obj cont = _35reg2986;
Obj _35reg2987 = primCdr(closureRef(co, 1));
Obj _35reg2988 = primCdr(_35reg2987);
Obj _35reg2989 = primCdr(_35reg2988);
Obj _35reg2990 = primEQ(Nil, _35reg2989);
if (True == _35reg2990) {
pushCont(co, _35clofun3816, 3, exp, fvs, cont);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2110;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2110;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2110;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2110;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2110;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3816(struct Cora* co) {
Obj _35val2991 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj fvs = co->stack[co->base + 1];
Obj cont = co->stack[co->base + 2];
pushCont(co, _35clofun3817, 2, fvs, cont);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2991;
co->args[2] = exp;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3817(struct Cora* co) {
Obj _35val2992 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj cont = co->stack[co->base + 1];
pushCont(co, _35clofun3818, 1, _35val2992);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->args[2] = cont;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3818(struct Cora* co) {
Obj _35val2993 = co->args[1];
Obj _35val2992 = co->stack[co->base + 0];
Obj _35reg2994 = primCons(_35val2993, Nil);
Obj _35reg2995 = primCons(_35val2992, _35reg2994);
Obj _35reg2996 = primCons(intern("call"), _35reg2995);
co->nargs = 2;
co->args[1] = _35reg2996;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3813(struct Cora* co) {
Obj _35cc2111 = makeNative(_35clofun3814, 0, 0);
Obj fvs = closureRef(co, 0);
Obj _35reg2969 = primIsCons(closureRef(co, 1));
if (True == _35reg2969) {
Obj _35reg2970 = primCar(closureRef(co, 1));
Obj f = _35reg2970;
Obj _35reg2971 = primCdr(closureRef(co, 1));
Obj args = _35reg2971;
pushCont(co, _35clofun3815, 2, f, args);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2111;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3815(struct Cora* co) {
Obj _35val2972 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj _35reg2973 = primCons(f, args);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2972;
co->args[2] = _35reg2973;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3814(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3798(struct Cora* co) {
Obj _35p2099 = co->args[1];
Obj _35p2100 = co->args[2];
Obj _35p2101 = co->args[3];
Obj _35cc2102 = makeNative(_35clofun3799, 0, 3, _35p2099, _35p2100, _35p2101);
Obj _35reg2926 = primEQ(Nil, _35p2099);
if (True == _35reg2926) {
Obj ls = _35p2100;
Obj next = _35p2101;
pushCont(co, _35clofun3802, 1, next);
co->nargs = 2;
co->args[0] = globalRef(intern("reverse"));
co->args[1] = ls;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2102;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3802(struct Cora* co) {
Obj _35val2927 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = _35val2927;
Obj _35reg2928 = primCar(exp);
pushCont(co, _35clofun3803, 2, next, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("pair?"));
co->args[1] = _35reg2928;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3803(struct Cora* co) {
Obj _35val2929 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
if (True == _35val2929) {
pushCont(co, _35clofun3804, 2, next, exp);
co->nargs = 2;
co->args[0] = globalRef(intern("caar"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
if (True == False) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2956 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2956) {
Obj _35reg2957 = primCons(exp, Nil);
Obj _35reg2958 = primCons(intern("tailcall"), _35reg2957);
co->nargs = 2;
co->args[1] = _35reg2958;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2959 = primGenSym(intern("val"));
Obj val = _35reg2959;
Obj _35reg2960 = primCons(val, Nil);
pushCont(co, _35clofun3807, 2, _35reg2960, exp);
co->nargs = 2;
co->args[0] = next;
co->args[1] = val;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun3807(struct Cora* co) {
Obj _35val2961 = co->args[1];
Obj _35reg2960 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2962 = primCons(_35val2961, Nil);
Obj _35reg2963 = primCons(_35reg2960, _35reg2962);
Obj _35reg2964 = primCons(intern("continuation"), _35reg2963);
Obj _35reg2965 = primCons(_35reg2964, Nil);
Obj _35reg2966 = primCons(exp, _35reg2965);
Obj _35reg2967 = primCons(intern("call"), _35reg2966);
co->nargs = 2;
co->args[1] = _35reg2967;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3804(struct Cora* co) {
Obj _35val2930 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2931 = primEQ(_35val2930, intern("%builtin"));
if (True == _35reg2931) {
if (True == True) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2932 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2932) {
Obj _35reg2933 = primCons(exp, Nil);
Obj _35reg2934 = primCons(intern("tailcall"), _35reg2933);
co->nargs = 2;
co->args[1] = _35reg2934;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2935 = primGenSym(intern("val"));
Obj val = _35reg2935;
Obj _35reg2936 = primCons(val, Nil);
pushCont(co, _35clofun3805, 2, _35reg2936, exp);
co->nargs = 2;
co->args[0] = next;
co->args[1] = val;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2944 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2944) {
Obj _35reg2945 = primCons(exp, Nil);
Obj _35reg2946 = primCons(intern("tailcall"), _35reg2945);
co->nargs = 2;
co->args[1] = _35reg2946;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2947 = primGenSym(intern("val"));
Obj val = _35reg2947;
Obj _35reg2948 = primCons(val, Nil);
pushCont(co, _35clofun3806, 2, _35reg2948, exp);
co->nargs = 2;
co->args[0] = next;
co->args[1] = val;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun3806(struct Cora* co) {
Obj _35val2949 = co->args[1];
Obj _35reg2948 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2950 = primCons(_35val2949, Nil);
Obj _35reg2951 = primCons(_35reg2948, _35reg2950);
Obj _35reg2952 = primCons(intern("continuation"), _35reg2951);
Obj _35reg2953 = primCons(_35reg2952, Nil);
Obj _35reg2954 = primCons(exp, _35reg2953);
Obj _35reg2955 = primCons(intern("call"), _35reg2954);
co->nargs = 2;
co->args[1] = _35reg2955;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3805(struct Cora* co) {
Obj _35val2937 = co->args[1];
Obj _35reg2936 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2938 = primCons(_35val2937, Nil);
Obj _35reg2939 = primCons(_35reg2936, _35reg2938);
Obj _35reg2940 = primCons(intern("continuation"), _35reg2939);
Obj _35reg2941 = primCons(_35reg2940, Nil);
Obj _35reg2942 = primCons(exp, _35reg2941);
Obj _35reg2943 = primCons(intern("call"), _35reg2942);
co->nargs = 2;
co->args[1] = _35reg2943;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3799(struct Cora* co) {
Obj _35cc2103 = makeNative(_35clofun3800, 0, 0);
Obj _35reg2922 = primIsCons(closureRef(co, 0));
if (True == _35reg2922) {
Obj _35reg2923 = primCar(closureRef(co, 0));
Obj hd = _35reg2923;
Obj _35reg2924 = primCdr(closureRef(co, 0));
Obj tl = _35reg2924;
Obj ls = closureRef(co, 1);
Obj next = closureRef(co, 2);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = hd;
co->args[2] = makeNative(_35clofun3801, 1, 3, tl, ls, next);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2103;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3801(struct Cora* co) {
Obj hd1 = co->args[1];
Obj _35reg2925 = primCons(hd1, closureRef(co, 1));
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-list"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg2925;
co->args[3] = closureRef(co, 2);
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3800(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3780(struct Cora* co) {
Obj _35p2090 = co->args[1];
Obj _35p2091 = co->args[2];
Obj _35cc2092 = makeNative(_35clofun3781, 0, 2, _35p2090, _35p2091);
Obj x = _35p2090;
Obj next = _35p2091;
Obj _35reg2919 = primIsSymbol(x);
if (True == _35reg2919) {
if (True == True) {
co->nargs = 2;
co->args[0] = next;
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2092;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun3797, 3, next, x, _35cc2092);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3797(struct Cora* co) {
Obj _35val2920 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj x = co->stack[co->base + 1];
Obj _35cc2092 = co->stack[co->base + 2];
if (True == _35val2920) {
if (True == True) {
co->nargs = 2;
co->args[0] = next;
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2092;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
co->nargs = 2;
co->args[0] = next;
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2092;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun3781(struct Cora* co) {
Obj _35cc2093 = makeNative(_35clofun3782, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj x = closureRef(co, 0);
Obj __ = closureRef(co, 1);
pushCont(co, _35clofun3796, 2, x, _35cc2093);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3796(struct Cora* co) {
Obj _35val2918 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc2093 = co->stack[co->base + 1];
if (True == _35val2918) {
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2093;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3782(struct Cora* co) {
Obj _35cc2094 = makeNative(_35clofun3783, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2886 = primIsCons(closureRef(co, 0));
if (True == _35reg2886) {
Obj _35reg2887 = primCar(closureRef(co, 0));
Obj _35reg2888 = primEQ(intern("if"), _35reg2887);
if (True == _35reg2888) {
Obj _35reg2889 = primCdr(closureRef(co, 0));
Obj _35reg2890 = primIsCons(_35reg2889);
if (True == _35reg2890) {
Obj _35reg2891 = primCdr(closureRef(co, 0));
Obj _35reg2892 = primCar(_35reg2891);
Obj a = _35reg2892;
Obj _35reg2893 = primCdr(closureRef(co, 0));
Obj _35reg2894 = primCdr(_35reg2893);
Obj _35reg2895 = primIsCons(_35reg2894);
if (True == _35reg2895) {
Obj _35reg2896 = primCdr(closureRef(co, 0));
Obj _35reg2897 = primCdr(_35reg2896);
Obj _35reg2898 = primCar(_35reg2897);
Obj b = _35reg2898;
Obj _35reg2899 = primCdr(closureRef(co, 0));
Obj _35reg2900 = primCdr(_35reg2899);
Obj _35reg2901 = primCdr(_35reg2900);
Obj _35reg2902 = primIsCons(_35reg2901);
if (True == _35reg2902) {
Obj _35reg2903 = primCdr(closureRef(co, 0));
Obj _35reg2904 = primCdr(_35reg2903);
Obj _35reg2905 = primCdr(_35reg2904);
Obj _35reg2906 = primCar(_35reg2905);
Obj c = _35reg2906;
Obj _35reg2907 = primCdr(closureRef(co, 0));
Obj _35reg2908 = primCdr(_35reg2907);
Obj _35reg2909 = primCdr(_35reg2908);
Obj _35reg2910 = primCdr(_35reg2909);
Obj _35reg2911 = primEQ(Nil, _35reg2910);
if (True == _35reg2911) {
Obj next = closureRef(co, 1);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = a;
co->args[2] = makeNative(_35clofun3793, 1, 3, b, c, next);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2094;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2094;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2094;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2094;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2094;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2094;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3793(struct Cora* co) {
Obj ra = co->args[1];
pushCont(co, _35clofun3794, 1, ra);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 2);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3794(struct Cora* co) {
Obj _35val2912 = co->args[1];
Obj ra = co->stack[co->base + 0];
pushCont(co, _35clofun3795, 2, _35val2912, ra);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 1);
co->args[2] = closureRef(co, 2);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3795(struct Cora* co) {
Obj _35val2913 = co->args[1];
Obj _35val2912 = co->stack[co->base + 0];
Obj ra = co->stack[co->base + 1];
Obj _35reg2914 = primCons(_35val2913, Nil);
Obj _35reg2915 = primCons(_35val2912, _35reg2914);
Obj _35reg2916 = primCons(ra, _35reg2915);
Obj _35reg2917 = primCons(intern("if"), _35reg2916);
co->nargs = 2;
co->args[1] = _35reg2917;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3783(struct Cora* co) {
Obj _35cc2095 = makeNative(_35clofun3784, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2864 = primIsCons(closureRef(co, 0));
if (True == _35reg2864) {
Obj _35reg2865 = primCar(closureRef(co, 0));
Obj _35reg2866 = primEQ(intern("do"), _35reg2865);
if (True == _35reg2866) {
Obj _35reg2867 = primCdr(closureRef(co, 0));
Obj _35reg2868 = primIsCons(_35reg2867);
if (True == _35reg2868) {
Obj _35reg2869 = primCdr(closureRef(co, 0));
Obj _35reg2870 = primCar(_35reg2869);
Obj a = _35reg2870;
Obj _35reg2871 = primCdr(closureRef(co, 0));
Obj _35reg2872 = primCdr(_35reg2871);
Obj _35reg2873 = primIsCons(_35reg2872);
if (True == _35reg2873) {
Obj _35reg2874 = primCdr(closureRef(co, 0));
Obj _35reg2875 = primCdr(_35reg2874);
Obj _35reg2876 = primCar(_35reg2875);
Obj b = _35reg2876;
Obj _35reg2877 = primCdr(closureRef(co, 0));
Obj _35reg2878 = primCdr(_35reg2877);
Obj _35reg2879 = primCdr(_35reg2878);
Obj _35reg2880 = primEQ(Nil, _35reg2879);
if (True == _35reg2880) {
Obj next = closureRef(co, 1);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = a;
co->args[2] = makeNative(_35clofun3791, 1, 2, b, next);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2095;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2095;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2095;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2095;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2095;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3791(struct Cora* co) {
Obj ra = co->args[1];
Obj _35reg2881 = primIsSymbol(ra);
if (True == _35reg2881) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 1);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun3792, 1, ra);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 1);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3792(struct Cora* co) {
Obj _35val2882 = co->args[1];
Obj ra = co->stack[co->base + 0];
Obj _35reg2883 = primCons(_35val2882, Nil);
Obj _35reg2884 = primCons(ra, _35reg2883);
Obj _35reg2885 = primCons(intern("do"), _35reg2884);
co->nargs = 2;
co->args[1] = _35reg2885;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3784(struct Cora* co) {
Obj _35cc2096 = makeNative(_35clofun3785, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2833 = primIsCons(closureRef(co, 0));
if (True == _35reg2833) {
Obj _35reg2834 = primCar(closureRef(co, 0));
Obj _35reg2835 = primEQ(intern("let"), _35reg2834);
if (True == _35reg2835) {
Obj _35reg2836 = primCdr(closureRef(co, 0));
Obj _35reg2837 = primIsCons(_35reg2836);
if (True == _35reg2837) {
Obj _35reg2838 = primCdr(closureRef(co, 0));
Obj _35reg2839 = primCar(_35reg2838);
Obj a = _35reg2839;
Obj _35reg2840 = primCdr(closureRef(co, 0));
Obj _35reg2841 = primCdr(_35reg2840);
Obj _35reg2842 = primIsCons(_35reg2841);
if (True == _35reg2842) {
Obj _35reg2843 = primCdr(closureRef(co, 0));
Obj _35reg2844 = primCdr(_35reg2843);
Obj _35reg2845 = primCar(_35reg2844);
Obj b = _35reg2845;
Obj _35reg2846 = primCdr(closureRef(co, 0));
Obj _35reg2847 = primCdr(_35reg2846);
Obj _35reg2848 = primCdr(_35reg2847);
Obj _35reg2849 = primIsCons(_35reg2848);
if (True == _35reg2849) {
Obj _35reg2850 = primCdr(closureRef(co, 0));
Obj _35reg2851 = primCdr(_35reg2850);
Obj _35reg2852 = primCdr(_35reg2851);
Obj _35reg2853 = primCar(_35reg2852);
Obj c = _35reg2853;
Obj _35reg2854 = primCdr(closureRef(co, 0));
Obj _35reg2855 = primCdr(_35reg2854);
Obj _35reg2856 = primCdr(_35reg2855);
Obj _35reg2857 = primCdr(_35reg2856);
Obj _35reg2858 = primEQ(Nil, _35reg2857);
if (True == _35reg2858) {
Obj next = closureRef(co, 1);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = b;
co->args[2] = makeNative(_35clofun3789, 1, 3, a, c, next);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2096;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2096;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2096;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2096;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2096;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2096;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3789(struct Cora* co) {
Obj rb = co->args[1];
pushCont(co, _35clofun3790, 1, rb);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 1);
co->args[2] = closureRef(co, 2);
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3790(struct Cora* co) {
Obj _35val2859 = co->args[1];
Obj rb = co->stack[co->base + 0];
Obj _35reg2860 = primCons(_35val2859, Nil);
Obj _35reg2861 = primCons(rb, _35reg2860);
Obj _35reg2862 = primCons(closureRef(co, 0), _35reg2861);
Obj _35reg2863 = primCons(intern("let"), _35reg2862);
co->nargs = 2;
co->args[1] = _35reg2863;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3785(struct Cora* co) {
Obj _35cc2097 = makeNative(_35clofun3786, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2789 = primIsCons(closureRef(co, 0));
if (True == _35reg2789) {
Obj _35reg2790 = primCar(closureRef(co, 0));
Obj _35reg2791 = primEQ(intern("%closure"), _35reg2790);
if (True == _35reg2791) {
Obj _35reg2792 = primCdr(closureRef(co, 0));
Obj _35reg2793 = primIsCons(_35reg2792);
if (True == _35reg2793) {
Obj _35reg2794 = primCdr(closureRef(co, 0));
Obj _35reg2795 = primCar(_35reg2794);
Obj _35reg2796 = primIsCons(_35reg2795);
if (True == _35reg2796) {
Obj _35reg2797 = primCdr(closureRef(co, 0));
Obj _35reg2798 = primCar(_35reg2797);
Obj _35reg2799 = primCar(_35reg2798);
Obj _35reg2800 = primEQ(intern("lambda"), _35reg2799);
if (True == _35reg2800) {
Obj _35reg2801 = primCdr(closureRef(co, 0));
Obj _35reg2802 = primCar(_35reg2801);
Obj _35reg2803 = primCdr(_35reg2802);
Obj _35reg2804 = primIsCons(_35reg2803);
if (True == _35reg2804) {
Obj _35reg2805 = primCdr(closureRef(co, 0));
Obj _35reg2806 = primCar(_35reg2805);
Obj _35reg2807 = primCdr(_35reg2806);
Obj _35reg2808 = primCar(_35reg2807);
Obj args = _35reg2808;
Obj _35reg2809 = primCdr(closureRef(co, 0));
Obj _35reg2810 = primCar(_35reg2809);
Obj _35reg2811 = primCdr(_35reg2810);
Obj _35reg2812 = primCdr(_35reg2811);
Obj _35reg2813 = primIsCons(_35reg2812);
if (True == _35reg2813) {
Obj _35reg2814 = primCdr(closureRef(co, 0));
Obj _35reg2815 = primCar(_35reg2814);
Obj _35reg2816 = primCdr(_35reg2815);
Obj _35reg2817 = primCdr(_35reg2816);
Obj _35reg2818 = primCar(_35reg2817);
Obj body = _35reg2818;
Obj _35reg2819 = primCdr(closureRef(co, 0));
Obj _35reg2820 = primCar(_35reg2819);
Obj _35reg2821 = primCdr(_35reg2820);
Obj _35reg2822 = primCdr(_35reg2821);
Obj _35reg2823 = primCdr(_35reg2822);
Obj _35reg2824 = primEQ(Nil, _35reg2823);
if (True == _35reg2824) {
Obj _35reg2825 = primCdr(closureRef(co, 0));
Obj _35reg2826 = primCdr(_35reg2825);
Obj frees = _35reg2826;
Obj next = closureRef(co, 1);
pushCont(co, _35clofun3788, 3, args, frees, next);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = body;
co->args[2] = globalRef(intern("cora/lib/toc/include.id"));
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2097;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2097;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2097;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2097;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2097;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2097;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2097;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2097;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3788(struct Cora* co) {
Obj _35val2827 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj next = co->stack[co->base + 2];
Obj _35reg2828 = primCons(_35val2827, Nil);
Obj _35reg2829 = primCons(args, _35reg2828);
Obj _35reg2830 = primCons(intern("lambda"), _35reg2829);
Obj _35reg2831 = primCons(_35reg2830, frees);
Obj _35reg2832 = primCons(intern("%closure"), _35reg2831);
co->nargs = 2;
co->args[0] = next;
co->args[1] = _35reg2832;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3786(struct Cora* co) {
Obj _35cc2098 = makeNative(_35clofun3787, 0, 0);
Obj _35reg2785 = primIsCons(closureRef(co, 0));
if (True == _35reg2785) {
Obj _35reg2786 = primCar(closureRef(co, 0));
Obj f = _35reg2786;
Obj _35reg2787 = primCdr(closureRef(co, 0));
Obj args = _35reg2787;
Obj next = closureRef(co, 1);
Obj _35reg2788 = primCons(f, args);
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-list"));
co->args[1] = _35reg2788;
co->args[2] = Nil;
co->args[3] = next;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2098;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3787(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3779(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg2782 = primCons(x, Nil);
Obj _35reg2783 = primCons(intern("return"), _35reg2782);
co->nargs = 2;
co->args[1] = _35reg2783;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3764(struct Cora* co) {
Obj _35p2083 = co->args[1];
Obj _35p2084 = co->args[2];
Obj _35cc2085 = makeNative(_35clofun3765, 0, 2, _35p2083, _35p2084);
Obj __ = _35p2083;
Obj x = _35p2084;
pushCont(co, _35clofun3778, 2, x, _35cc2085);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3778(struct Cora* co) {
Obj _35val2780 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc2085 = co->stack[co->base + 1];
if (True == _35val2780) {
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2085;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3765(struct Cora* co) {
Obj _35cc2086 = makeNative(_35clofun3766, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj var = closureRef(co, 1);
Obj _35reg2775 = primIsSymbol(var);
if (True == _35reg2775) {
pushCont(co, _35clofun3777, 1, var);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = var;
co->args[2] = fvs;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2086;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3777(struct Cora* co) {
Obj _35val2776 = co->args[1];
Obj var = co->stack[co->base + 0];
Obj pos = _35val2776;
Obj _35reg2777 = primEQ(makeNumber(-1), pos);
if (True == _35reg2777) {
co->nargs = 2;
co->args[1] = var;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2778 = primCons(pos, Nil);
Obj _35reg2779 = primCons(intern("%closure-ref"), _35reg2778);
co->nargs = 2;
co->args[1] = _35reg2779;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun3766(struct Cora* co) {
Obj _35cc2087 = makeNative(_35clofun3767, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2746 = primIsCons(closureRef(co, 1));
if (True == _35reg2746) {
Obj _35reg2747 = primCar(closureRef(co, 1));
Obj _35reg2748 = primEQ(intern("lambda"), _35reg2747);
if (True == _35reg2748) {
Obj _35reg2749 = primCdr(closureRef(co, 1));
Obj _35reg2750 = primIsCons(_35reg2749);
if (True == _35reg2750) {
Obj _35reg2751 = primCdr(closureRef(co, 1));
Obj _35reg2752 = primCar(_35reg2751);
Obj args = _35reg2752;
Obj _35reg2753 = primCdr(closureRef(co, 1));
Obj _35reg2754 = primCdr(_35reg2753);
Obj _35reg2755 = primIsCons(_35reg2754);
if (True == _35reg2755) {
Obj _35reg2756 = primCdr(closureRef(co, 1));
Obj _35reg2757 = primCdr(_35reg2756);
Obj _35reg2758 = primCar(_35reg2757);
Obj body = _35reg2758;
Obj _35reg2759 = primCdr(closureRef(co, 1));
Obj _35reg2760 = primCdr(_35reg2759);
Obj _35reg2761 = primCdr(_35reg2760);
Obj _35reg2762 = primEQ(Nil, _35reg2761);
if (True == _35reg2762) {
Obj _35reg2763 = primCons(body, Nil);
Obj _35reg2764 = primCons(args, _35reg2763);
Obj _35reg2765 = primCons(intern("lambda"), _35reg2764);
pushCont(co, _35clofun3773, 3, body, args, fvs);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = _35reg2765;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2087;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2087;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2087;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2087;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2087;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3773(struct Cora* co) {
Obj _35val2766 = co->args[1];
Obj body = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj fvs = co->stack[co->base + 2];
Obj fvs1 = _35val2766;
pushCont(co, _35clofun3774, 3, args, fvs, fvs1);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs1;
co->args[2] = body;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3774(struct Cora* co) {
Obj _35val2767 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj fvs = co->stack[co->base + 1];
Obj fvs1 = co->stack[co->base + 2];
Obj _35reg2768 = primCons(_35val2767, Nil);
Obj _35reg2769 = primCons(args, _35reg2768);
Obj _35reg2770 = primCons(intern("lambda"), _35reg2769);
pushCont(co, _35clofun3775, 2, fvs1, _35reg2770);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3775(struct Cora* co) {
Obj _35val2771 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj _35reg2770 = co->stack[co->base + 1];
pushCont(co, _35clofun3776, 1, _35reg2770);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2771;
co->args[2] = fvs1;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3776(struct Cora* co) {
Obj _35val2772 = co->args[1];
Obj _35reg2770 = co->stack[co->base + 0];
Obj _35reg2773 = primCons(_35reg2770, _35val2772);
Obj _35reg2774 = primCons(intern("%closure"), _35reg2773);
co->nargs = 2;
co->args[1] = _35reg2774;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3767(struct Cora* co) {
Obj _35cc2088 = makeNative(_35clofun3768, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2714 = primIsCons(closureRef(co, 1));
if (True == _35reg2714) {
Obj _35reg2715 = primCar(closureRef(co, 1));
Obj _35reg2716 = primEQ(intern("let"), _35reg2715);
if (True == _35reg2716) {
Obj _35reg2717 = primCdr(closureRef(co, 1));
Obj _35reg2718 = primIsCons(_35reg2717);
if (True == _35reg2718) {
Obj _35reg2719 = primCdr(closureRef(co, 1));
Obj _35reg2720 = primCar(_35reg2719);
Obj a = _35reg2720;
Obj _35reg2721 = primCdr(closureRef(co, 1));
Obj _35reg2722 = primCdr(_35reg2721);
Obj _35reg2723 = primIsCons(_35reg2722);
if (True == _35reg2723) {
Obj _35reg2724 = primCdr(closureRef(co, 1));
Obj _35reg2725 = primCdr(_35reg2724);
Obj _35reg2726 = primCar(_35reg2725);
Obj b = _35reg2726;
Obj _35reg2727 = primCdr(closureRef(co, 1));
Obj _35reg2728 = primCdr(_35reg2727);
Obj _35reg2729 = primCdr(_35reg2728);
Obj _35reg2730 = primIsCons(_35reg2729);
if (True == _35reg2730) {
Obj _35reg2731 = primCdr(closureRef(co, 1));
Obj _35reg2732 = primCdr(_35reg2731);
Obj _35reg2733 = primCdr(_35reg2732);
Obj _35reg2734 = primCar(_35reg2733);
Obj c = _35reg2734;
Obj _35reg2735 = primCdr(closureRef(co, 1));
Obj _35reg2736 = primCdr(_35reg2735);
Obj _35reg2737 = primCdr(_35reg2736);
Obj _35reg2738 = primCdr(_35reg2737);
Obj _35reg2739 = primEQ(Nil, _35reg2738);
if (True == _35reg2739) {
pushCont(co, _35clofun3771, 3, fvs, c, a);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->args[2] = b;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2088;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2088;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2088;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2088;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2088;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2088;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3771(struct Cora* co) {
Obj _35val2740 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj a = co->stack[co->base + 2];
pushCont(co, _35clofun3772, 2, _35val2740, a);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->args[2] = c;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3772(struct Cora* co) {
Obj _35val2741 = co->args[1];
Obj _35val2740 = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj _35reg2742 = primCons(_35val2741, Nil);
Obj _35reg2743 = primCons(_35val2740, _35reg2742);
Obj _35reg2744 = primCons(a, _35reg2743);
Obj _35reg2745 = primCons(intern("let"), _35reg2744);
co->nargs = 2;
co->args[1] = _35reg2745;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3768(struct Cora* co) {
Obj _35cc2089 = makeNative(_35clofun3769, 0, 0);
Obj fvs = closureRef(co, 0);
Obj _35reg2709 = primIsCons(closureRef(co, 1));
if (True == _35reg2709) {
Obj _35reg2710 = primCar(closureRef(co, 1));
Obj f = _35reg2710;
Obj _35reg2711 = primCdr(closureRef(co, 1));
Obj args = _35reg2711;
pushCont(co, _35clofun3770, 2, f, args);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2089;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3770(struct Cora* co) {
Obj _35val2712 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj _35reg2713 = primCons(f, args);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2712;
co->args[2] = _35reg2713;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3769(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3741(struct Cora* co) {
Obj _35p2070 = co->args[1];
Obj _35cc2071 = makeNative(_35clofun3742, 0, 1, _35p2070);
Obj x = _35p2070;
pushCont(co, _35clofun3763, 1, _35cc2071);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3763(struct Cora* co) {
Obj _35val2707 = co->args[1];
Obj _35cc2071 = co->stack[co->base + 0];
if (True == _35val2707) {
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2071;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3742(struct Cora* co) {
Obj _35cc2072 = makeNative(_35clofun3743, 0, 1, closureRef(co, 0));
Obj x = closureRef(co, 0);
Obj _35reg2705 = primIsSymbol(x);
if (True == _35reg2705) {
Obj _35reg2706 = primCons(x, Nil);
co->nargs = 2;
co->args[1] = _35reg2706;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2072;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3743(struct Cora* co) {
Obj _35cc2073 = makeNative(_35clofun3744, 0, 1, closureRef(co, 0));
Obj _35reg2687 = primIsCons(closureRef(co, 0));
if (True == _35reg2687) {
Obj _35reg2688 = primCar(closureRef(co, 0));
Obj _35reg2689 = primEQ(intern("lambda"), _35reg2688);
if (True == _35reg2689) {
Obj _35reg2690 = primCdr(closureRef(co, 0));
Obj _35reg2691 = primIsCons(_35reg2690);
if (True == _35reg2691) {
Obj _35reg2692 = primCdr(closureRef(co, 0));
Obj _35reg2693 = primCar(_35reg2692);
Obj args = _35reg2693;
Obj _35reg2694 = primCdr(closureRef(co, 0));
Obj _35reg2695 = primCdr(_35reg2694);
Obj _35reg2696 = primIsCons(_35reg2695);
if (True == _35reg2696) {
Obj _35reg2697 = primCdr(closureRef(co, 0));
Obj _35reg2698 = primCdr(_35reg2697);
Obj _35reg2699 = primCar(_35reg2698);
Obj body = _35reg2699;
Obj _35reg2700 = primCdr(closureRef(co, 0));
Obj _35reg2701 = primCdr(_35reg2700);
Obj _35reg2702 = primCdr(_35reg2701);
Obj _35reg2703 = primEQ(Nil, _35reg2702);
if (True == _35reg2703) {
pushCont(co, _35clofun3762, 1, args);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2073;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2073;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2073;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2073;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2073;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3762(struct Cora* co) {
Obj _35val2704 = co->args[1];
Obj args = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val2704;
co->args[2] = args;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3744(struct Cora* co) {
Obj _35cc2074 = makeNative(_35clofun3745, 0, 1, closureRef(co, 0));
Obj _35reg2657 = primIsCons(closureRef(co, 0));
if (True == _35reg2657) {
Obj _35reg2658 = primCar(closureRef(co, 0));
Obj _35reg2659 = primEQ(intern("if"), _35reg2658);
if (True == _35reg2659) {
Obj _35reg2660 = primCdr(closureRef(co, 0));
Obj _35reg2661 = primIsCons(_35reg2660);
if (True == _35reg2661) {
Obj _35reg2662 = primCdr(closureRef(co, 0));
Obj _35reg2663 = primCar(_35reg2662);
Obj x = _35reg2663;
Obj _35reg2664 = primCdr(closureRef(co, 0));
Obj _35reg2665 = primCdr(_35reg2664);
Obj _35reg2666 = primIsCons(_35reg2665);
if (True == _35reg2666) {
Obj _35reg2667 = primCdr(closureRef(co, 0));
Obj _35reg2668 = primCdr(_35reg2667);
Obj _35reg2669 = primCar(_35reg2668);
Obj y = _35reg2669;
Obj _35reg2670 = primCdr(closureRef(co, 0));
Obj _35reg2671 = primCdr(_35reg2670);
Obj _35reg2672 = primCdr(_35reg2671);
Obj _35reg2673 = primIsCons(_35reg2672);
if (True == _35reg2673) {
Obj _35reg2674 = primCdr(closureRef(co, 0));
Obj _35reg2675 = primCdr(_35reg2674);
Obj _35reg2676 = primCdr(_35reg2675);
Obj _35reg2677 = primCar(_35reg2676);
Obj z = _35reg2677;
Obj _35reg2678 = primCdr(closureRef(co, 0));
Obj _35reg2679 = primCdr(_35reg2678);
Obj _35reg2680 = primCdr(_35reg2679);
Obj _35reg2681 = primCdr(_35reg2680);
Obj _35reg2682 = primEQ(Nil, _35reg2681);
if (True == _35reg2682) {
Obj _35reg2683 = primCons(z, Nil);
Obj _35reg2684 = primCons(y, _35reg2683);
Obj _35reg2685 = primCons(x, _35reg2684);
pushCont(co, _35clofun3761, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg2685;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2074;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2074;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2074;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2074;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2074;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2074;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3761(struct Cora* co) {
Obj _35val2686 = co->args[1];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val2686;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3745(struct Cora* co) {
Obj _35cc2075 = makeNative(_35clofun3746, 0, 1, closureRef(co, 0));
Obj _35reg2637 = primIsCons(closureRef(co, 0));
if (True == _35reg2637) {
Obj _35reg2638 = primCar(closureRef(co, 0));
Obj _35reg2639 = primEQ(intern("do"), _35reg2638);
if (True == _35reg2639) {
Obj _35reg2640 = primCdr(closureRef(co, 0));
Obj _35reg2641 = primIsCons(_35reg2640);
if (True == _35reg2641) {
Obj _35reg2642 = primCdr(closureRef(co, 0));
Obj _35reg2643 = primCar(_35reg2642);
Obj x = _35reg2643;
Obj _35reg2644 = primCdr(closureRef(co, 0));
Obj _35reg2645 = primCdr(_35reg2644);
Obj _35reg2646 = primIsCons(_35reg2645);
if (True == _35reg2646) {
Obj _35reg2647 = primCdr(closureRef(co, 0));
Obj _35reg2648 = primCdr(_35reg2647);
Obj _35reg2649 = primCar(_35reg2648);
Obj y = _35reg2649;
Obj _35reg2650 = primCdr(closureRef(co, 0));
Obj _35reg2651 = primCdr(_35reg2650);
Obj _35reg2652 = primCdr(_35reg2651);
Obj _35reg2653 = primEQ(Nil, _35reg2652);
if (True == _35reg2653) {
Obj _35reg2654 = primCons(y, Nil);
Obj _35reg2655 = primCons(x, _35reg2654);
pushCont(co, _35clofun3760, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg2655;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2075;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2075;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2075;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2075;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2075;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3760(struct Cora* co) {
Obj _35val2656 = co->args[1];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val2656;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3746(struct Cora* co) {
Obj _35cc2076 = makeNative(_35clofun3747, 0, 1, closureRef(co, 0));
Obj _35reg2607 = primIsCons(closureRef(co, 0));
if (True == _35reg2607) {
Obj _35reg2608 = primCar(closureRef(co, 0));
Obj _35reg2609 = primEQ(intern("let"), _35reg2608);
if (True == _35reg2609) {
Obj _35reg2610 = primCdr(closureRef(co, 0));
Obj _35reg2611 = primIsCons(_35reg2610);
if (True == _35reg2611) {
Obj _35reg2612 = primCdr(closureRef(co, 0));
Obj _35reg2613 = primCar(_35reg2612);
Obj a = _35reg2613;
Obj _35reg2614 = primCdr(closureRef(co, 0));
Obj _35reg2615 = primCdr(_35reg2614);
Obj _35reg2616 = primIsCons(_35reg2615);
if (True == _35reg2616) {
Obj _35reg2617 = primCdr(closureRef(co, 0));
Obj _35reg2618 = primCdr(_35reg2617);
Obj _35reg2619 = primCar(_35reg2618);
Obj b = _35reg2619;
Obj _35reg2620 = primCdr(closureRef(co, 0));
Obj _35reg2621 = primCdr(_35reg2620);
Obj _35reg2622 = primCdr(_35reg2621);
Obj _35reg2623 = primIsCons(_35reg2622);
if (True == _35reg2623) {
Obj _35reg2624 = primCdr(closureRef(co, 0));
Obj _35reg2625 = primCdr(_35reg2624);
Obj _35reg2626 = primCdr(_35reg2625);
Obj _35reg2627 = primCar(_35reg2626);
Obj c = _35reg2627;
Obj _35reg2628 = primCdr(closureRef(co, 0));
Obj _35reg2629 = primCdr(_35reg2628);
Obj _35reg2630 = primCdr(_35reg2629);
Obj _35reg2631 = primCdr(_35reg2630);
Obj _35reg2632 = primEQ(Nil, _35reg2631);
if (True == _35reg2632) {
pushCont(co, _35clofun3757, 2, c, a);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = b;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2076;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2076;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2076;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2076;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2076;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2076;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3757(struct Cora* co) {
Obj _35val2633 = co->args[1];
Obj c = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
pushCont(co, _35clofun3758, 2, a, _35val2633);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = c;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3758(struct Cora* co) {
Obj _35val2634 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj _35val2633 = co->stack[co->base + 1];
Obj _35reg2635 = primCons(a, Nil);
pushCont(co, _35clofun3759, 1, _35val2633);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val2634;
co->args[2] = _35reg2635;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3759(struct Cora* co) {
Obj _35val2636 = co->args[1];
Obj _35val2633 = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = _35val2633;
co->args[2] = _35val2636;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3747(struct Cora* co) {
Obj _35cc2077 = makeNative(_35clofun3748, 0, 1, closureRef(co, 0));
Obj _35reg2597 = primIsCons(closureRef(co, 0));
if (True == _35reg2597) {
Obj _35reg2598 = primCar(closureRef(co, 0));
Obj _35reg2599 = primEQ(intern("%closure"), _35reg2598);
if (True == _35reg2599) {
Obj _35reg2600 = primCdr(closureRef(co, 0));
Obj _35reg2601 = primIsCons(_35reg2600);
if (True == _35reg2601) {
Obj _35reg2602 = primCdr(closureRef(co, 0));
Obj _35reg2603 = primCar(_35reg2602);
Obj lam = _35reg2603;
Obj _35reg2604 = primCdr(closureRef(co, 0));
Obj _35reg2605 = primCdr(_35reg2604);
Obj more = _35reg2605;
Obj _35reg2606 = primCons(lam, more);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = _35reg2606;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2077;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2077;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2077;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3748(struct Cora* co) {
Obj _35cc2078 = makeNative(_35clofun3749, 0, 1, closureRef(co, 0));
Obj _35reg2587 = primIsCons(closureRef(co, 0));
if (True == _35reg2587) {
Obj _35reg2588 = primCar(closureRef(co, 0));
Obj _35reg2589 = primEQ(intern("return"), _35reg2588);
if (True == _35reg2589) {
Obj _35reg2590 = primCdr(closureRef(co, 0));
Obj _35reg2591 = primIsCons(_35reg2590);
if (True == _35reg2591) {
Obj _35reg2592 = primCdr(closureRef(co, 0));
Obj _35reg2593 = primCar(_35reg2592);
Obj x = _35reg2593;
Obj _35reg2594 = primCdr(closureRef(co, 0));
Obj _35reg2595 = primCdr(_35reg2594);
Obj _35reg2596 = primEQ(Nil, _35reg2595);
if (True == _35reg2596) {
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2078;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2078;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2078;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2078;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3749(struct Cora* co) {
Obj _35cc2079 = makeNative(_35clofun3750, 0, 1, closureRef(co, 0));
Obj _35reg2567 = primIsCons(closureRef(co, 0));
if (True == _35reg2567) {
Obj _35reg2568 = primCar(closureRef(co, 0));
Obj _35reg2569 = primEQ(intern("call"), _35reg2568);
if (True == _35reg2569) {
Obj _35reg2570 = primCdr(closureRef(co, 0));
Obj _35reg2571 = primIsCons(_35reg2570);
if (True == _35reg2571) {
Obj _35reg2572 = primCdr(closureRef(co, 0));
Obj _35reg2573 = primCar(_35reg2572);
Obj exp = _35reg2573;
Obj _35reg2574 = primCdr(closureRef(co, 0));
Obj _35reg2575 = primCdr(_35reg2574);
Obj _35reg2576 = primIsCons(_35reg2575);
if (True == _35reg2576) {
Obj _35reg2577 = primCdr(closureRef(co, 0));
Obj _35reg2578 = primCdr(_35reg2577);
Obj _35reg2579 = primCar(_35reg2578);
Obj cont = _35reg2579;
Obj _35reg2580 = primCdr(closureRef(co, 0));
Obj _35reg2581 = primCdr(_35reg2580);
Obj _35reg2582 = primCdr(_35reg2581);
Obj _35reg2583 = primEQ(Nil, _35reg2582);
if (True == _35reg2583) {
Obj _35reg2584 = primCons(cont, Nil);
Obj _35reg2585 = primCons(exp, _35reg2584);
pushCont(co, _35clofun3756, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg2585;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2079;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2079;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2079;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2079;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2079;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3756(struct Cora* co) {
Obj _35val2586 = co->args[1];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val2586;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3750(struct Cora* co) {
Obj _35cc2080 = makeNative(_35clofun3751, 0, 1, closureRef(co, 0));
Obj _35reg2557 = primIsCons(closureRef(co, 0));
if (True == _35reg2557) {
Obj _35reg2558 = primCar(closureRef(co, 0));
Obj _35reg2559 = primEQ(intern("tailcall"), _35reg2558);
if (True == _35reg2559) {
Obj _35reg2560 = primCdr(closureRef(co, 0));
Obj _35reg2561 = primIsCons(_35reg2560);
if (True == _35reg2561) {
Obj _35reg2562 = primCdr(closureRef(co, 0));
Obj _35reg2563 = primCar(_35reg2562);
Obj exp = _35reg2563;
Obj _35reg2564 = primCdr(closureRef(co, 0));
Obj _35reg2565 = primCdr(_35reg2564);
Obj _35reg2566 = primEQ(Nil, _35reg2565);
if (True == _35reg2566) {
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = exp;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2080;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2080;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2080;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2080;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3751(struct Cora* co) {
Obj _35cc2081 = makeNative(_35clofun3752, 0, 1, closureRef(co, 0));
Obj _35reg2539 = primIsCons(closureRef(co, 0));
if (True == _35reg2539) {
Obj _35reg2540 = primCar(closureRef(co, 0));
Obj _35reg2541 = primEQ(intern("continuation"), _35reg2540);
if (True == _35reg2541) {
Obj _35reg2542 = primCdr(closureRef(co, 0));
Obj _35reg2543 = primIsCons(_35reg2542);
if (True == _35reg2543) {
Obj _35reg2544 = primCdr(closureRef(co, 0));
Obj _35reg2545 = primCar(_35reg2544);
Obj arg = _35reg2545;
Obj _35reg2546 = primCdr(closureRef(co, 0));
Obj _35reg2547 = primCdr(_35reg2546);
Obj _35reg2548 = primIsCons(_35reg2547);
if (True == _35reg2548) {
Obj _35reg2549 = primCdr(closureRef(co, 0));
Obj _35reg2550 = primCdr(_35reg2549);
Obj _35reg2551 = primCar(_35reg2550);
Obj body = _35reg2551;
Obj _35reg2552 = primCdr(closureRef(co, 0));
Obj _35reg2553 = primCdr(_35reg2552);
Obj _35reg2554 = primCdr(_35reg2553);
Obj _35reg2555 = primEQ(Nil, _35reg2554);
if (True == _35reg2555) {
pushCont(co, _35clofun3755, 1, arg);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2081;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2081;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2081;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2081;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2081;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3755(struct Cora* co) {
Obj _35val2556 = co->args[1];
Obj arg = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val2556;
co->args[2] = arg;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3752(struct Cora* co) {
Obj _35cc2082 = makeNative(_35clofun3753, 0, 0);
Obj _35reg2534 = primIsCons(closureRef(co, 0));
if (True == _35reg2534) {
Obj _35reg2535 = primCar(closureRef(co, 0));
Obj f = _35reg2535;
Obj _35reg2536 = primCdr(closureRef(co, 0));
Obj args = _35reg2536;
Obj _35reg2537 = primCons(f, args);
pushCont(co, _35clofun3754, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg2537;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2082;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3754(struct Cora* co) {
Obj _35val2538 = co->args[1];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val2538;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3753(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3734(struct Cora* co) {
Obj _35p2063 = co->args[1];
Obj _35cc2064 = makeNative(_35clofun3735, 0, 1, _35p2063);
Obj _35reg2523 = primIsCons(_35p2063);
if (True == _35reg2523) {
Obj _35reg2524 = primCar(_35p2063);
Obj _35reg2525 = primEQ(intern("%const"), _35reg2524);
if (True == _35reg2525) {
Obj _35reg2526 = primCdr(_35p2063);
Obj _35reg2527 = primIsCons(_35reg2526);
if (True == _35reg2527) {
Obj _35reg2528 = primCdr(_35p2063);
Obj _35reg2529 = primCar(_35reg2528);
Obj x = _35reg2529;
Obj _35reg2530 = primCdr(_35p2063);
Obj _35reg2531 = primCdr(_35reg2530);
Obj _35reg2532 = primEQ(Nil, _35reg2531);
if (True == _35reg2532) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2064;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2064;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2064;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2064;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3735(struct Cora* co) {
Obj _35cc2065 = makeNative(_35clofun3736, 0, 1, closureRef(co, 0));
Obj _35reg2513 = primIsCons(closureRef(co, 0));
if (True == _35reg2513) {
Obj _35reg2514 = primCar(closureRef(co, 0));
Obj _35reg2515 = primEQ(intern("%global"), _35reg2514);
if (True == _35reg2515) {
Obj _35reg2516 = primCdr(closureRef(co, 0));
Obj _35reg2517 = primIsCons(_35reg2516);
if (True == _35reg2517) {
Obj _35reg2518 = primCdr(closureRef(co, 0));
Obj _35reg2519 = primCar(_35reg2518);
Obj x = _35reg2519;
Obj _35reg2520 = primCdr(closureRef(co, 0));
Obj _35reg2521 = primCdr(_35reg2520);
Obj _35reg2522 = primEQ(Nil, _35reg2521);
if (True == _35reg2522) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2065;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2065;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2065;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2065;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3736(struct Cora* co) {
Obj _35cc2066 = makeNative(_35clofun3737, 0, 1, closureRef(co, 0));
Obj _35reg2503 = primIsCons(closureRef(co, 0));
if (True == _35reg2503) {
Obj _35reg2504 = primCar(closureRef(co, 0));
Obj _35reg2505 = primEQ(intern("%builtin"), _35reg2504);
if (True == _35reg2505) {
Obj _35reg2506 = primCdr(closureRef(co, 0));
Obj _35reg2507 = primIsCons(_35reg2506);
if (True == _35reg2507) {
Obj _35reg2508 = primCdr(closureRef(co, 0));
Obj _35reg2509 = primCar(_35reg2508);
Obj op = _35reg2509;
Obj _35reg2510 = primCdr(closureRef(co, 0));
Obj _35reg2511 = primCdr(_35reg2510);
Obj _35reg2512 = primEQ(Nil, _35reg2511);
if (True == _35reg2512) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2066;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2066;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2066;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2066;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3737(struct Cora* co) {
Obj _35cc2067 = makeNative(_35clofun3738, 0, 1, closureRef(co, 0));
Obj _35reg2493 = primIsCons(closureRef(co, 0));
if (True == _35reg2493) {
Obj _35reg2494 = primCar(closureRef(co, 0));
Obj _35reg2495 = primEQ(intern("quote"), _35reg2494);
if (True == _35reg2495) {
Obj _35reg2496 = primCdr(closureRef(co, 0));
Obj _35reg2497 = primIsCons(_35reg2496);
if (True == _35reg2497) {
Obj _35reg2498 = primCdr(closureRef(co, 0));
Obj _35reg2499 = primCar(_35reg2498);
Obj x = _35reg2499;
Obj _35reg2500 = primCdr(closureRef(co, 0));
Obj _35reg2501 = primCdr(_35reg2500);
Obj _35reg2502 = primEQ(Nil, _35reg2501);
if (True == _35reg2502) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2067;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2067;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2067;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2067;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3738(struct Cora* co) {
Obj _35cc2068 = makeNative(_35clofun3739, 0, 1, closureRef(co, 0));
Obj _35reg2483 = primIsCons(closureRef(co, 0));
if (True == _35reg2483) {
Obj _35reg2484 = primCar(closureRef(co, 0));
Obj _35reg2485 = primEQ(intern("%closure-ref"), _35reg2484);
if (True == _35reg2485) {
Obj _35reg2486 = primCdr(closureRef(co, 0));
Obj _35reg2487 = primIsCons(_35reg2486);
if (True == _35reg2487) {
Obj _35reg2488 = primCdr(closureRef(co, 0));
Obj _35reg2489 = primCar(_35reg2488);
Obj __ = _35reg2489;
Obj _35reg2490 = primCdr(closureRef(co, 0));
Obj _35reg2491 = primCdr(_35reg2490);
Obj _35reg2492 = primEQ(Nil, _35reg2491);
if (True == _35reg2492) {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2068;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2068;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2068;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2068;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3739(struct Cora* co) {
Obj _35cc2069 = makeNative(_35clofun3740, 0, 0);
Obj x = closureRef(co, 0);
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3740(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3728(struct Cora* co) {
Obj _35p2058 = co->args[1];
Obj _35p2059 = co->args[2];
Obj _35cc2060 = makeNative(_35clofun3729, 0, 2, _35p2058, _35p2059);
Obj _35reg2481 = primEQ(Nil, _35p2058);
if (True == _35reg2481) {
Obj __ = _35p2059;
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2060;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3729(struct Cora* co) {
Obj _35cc2061 = makeNative(_35clofun3730, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2477 = primIsCons(closureRef(co, 0));
if (True == _35reg2477) {
Obj _35reg2478 = primCar(closureRef(co, 0));
Obj x = _35reg2478;
Obj _35reg2479 = primCdr(closureRef(co, 0));
Obj y = _35reg2479;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun3733, 3, y, s2, _35cc2061);
co->nargs = 3;
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = s2;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2061;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3733(struct Cora* co) {
Obj _35val2480 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj s2 = co->stack[co->base + 1];
Obj _35cc2061 = co->stack[co->base + 2];
if (True == _35val2480) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = y;
co->args[2] = s2;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2061;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3730(struct Cora* co) {
Obj _35cc2062 = makeNative(_35clofun3731, 0, 0);
Obj _35reg2472 = primIsCons(closureRef(co, 0));
if (True == _35reg2472) {
Obj _35reg2473 = primCar(closureRef(co, 0));
Obj x = _35reg2473;
Obj _35reg2474 = primCdr(closureRef(co, 0));
Obj y = _35reg2474;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun3732, 1, x);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = y;
co->args[2] = s2;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2062;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3732(struct Cora* co) {
Obj _35val2475 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg2476 = primCons(x, _35val2475);
co->nargs = 2;
co->args[1] = _35reg2476;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3731(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3722(struct Cora* co) {
Obj _35p2053 = co->args[1];
Obj _35p2054 = co->args[2];
Obj _35cc2055 = makeNative(_35clofun3723, 0, 2, _35p2053, _35p2054);
Obj _35reg2470 = primEQ(Nil, _35p2053);
if (True == _35reg2470) {
Obj s2 = _35p2054;
co->nargs = 2;
co->args[1] = s2;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2055;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3723(struct Cora* co) {
Obj _35cc2056 = makeNative(_35clofun3724, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2466 = primIsCons(closureRef(co, 0));
if (True == _35reg2466) {
Obj _35reg2467 = primCar(closureRef(co, 0));
Obj x = _35reg2467;
Obj _35reg2468 = primCdr(closureRef(co, 0));
Obj y = _35reg2468;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun3727, 3, y, s2, _35cc2056);
co->nargs = 3;
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = s2;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2056;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3727(struct Cora* co) {
Obj _35val2469 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj s2 = co->stack[co->base + 1];
Obj _35cc2056 = co->stack[co->base + 2];
if (True == _35val2469) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = y;
co->args[2] = s2;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2056;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3724(struct Cora* co) {
Obj _35cc2057 = makeNative(_35clofun3725, 0, 0);
Obj _35reg2461 = primIsCons(closureRef(co, 0));
if (True == _35reg2461) {
Obj _35reg2462 = primCar(closureRef(co, 0));
Obj x = _35reg2462;
Obj _35reg2463 = primCdr(closureRef(co, 0));
Obj y = _35reg2463;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun3726, 1, x);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = y;
co->args[2] = s2;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2057;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3726(struct Cora* co) {
Obj _35val2464 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg2465 = primCons(x, _35val2464);
co->nargs = 2;
co->args[1] = _35reg2465;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3725(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3692(struct Cora* co) {
Obj _35p2042 = co->args[1];
Obj _35p2043 = co->args[2];
Obj _35cc2044 = makeNative(_35clofun3693, 0, 2, _35p2042, _35p2043);
Obj __ = _35p2042;
Obj x = _35p2043;
pushCont(co, _35clofun3719, 2, x, _35cc2044);
co->nargs = 2;
co->args[0] = globalRef(intern("number?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3719(struct Cora* co) {
Obj _35val2446 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc2044 = co->stack[co->base + 1];
if (True == _35val2446) {
if (True == True) {
Obj _35reg2447 = primCons(x, Nil);
Obj _35reg2448 = primCons(intern("%const"), _35reg2447);
co->nargs = 2;
co->args[1] = _35reg2448;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
Obj _35reg2449 = primIsString(x);
if (True == _35reg2449) {
if (True == True) {
Obj _35reg2450 = primCons(x, Nil);
Obj _35reg2451 = primCons(intern("%const"), _35reg2450);
co->nargs = 2;
co->args[1] = _35reg2451;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun3720, 2, x, _35cc2044);
co->nargs = 2;
co->args[0] = globalRef(intern("boolean?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun3720(struct Cora* co) {
Obj _35val2452 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc2044 = co->stack[co->base + 1];
if (True == _35val2452) {
if (True == True) {
Obj _35reg2453 = primCons(x, Nil);
Obj _35reg2454 = primCons(intern("%const"), _35reg2453);
co->nargs = 2;
co->args[1] = _35reg2454;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun3721, 2, x, _35cc2044);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = x;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3721(struct Cora* co) {
Obj _35val2455 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc2044 = co->stack[co->base + 1];
if (True == _35val2455) {
if (True == True) {
Obj _35reg2456 = primCons(x, Nil);
Obj _35reg2457 = primCons(intern("%const"), _35reg2456);
co->nargs = 2;
co->args[1] = _35reg2457;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg2458 = primCons(x, Nil);
Obj _35reg2459 = primCons(intern("%const"), _35reg2458);
co->nargs = 2;
co->args[1] = _35reg2459;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2044;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun3693(struct Cora* co) {
Obj _35cc2045 = makeNative(_35clofun3694, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj __ = closureRef(co, 0);
Obj _35reg2434 = primIsCons(closureRef(co, 1));
if (True == _35reg2434) {
Obj _35reg2435 = primCar(closureRef(co, 1));
Obj _35reg2436 = primEQ(intern("quote"), _35reg2435);
if (True == _35reg2436) {
Obj _35reg2437 = primCdr(closureRef(co, 1));
Obj _35reg2438 = primIsCons(_35reg2437);
if (True == _35reg2438) {
Obj _35reg2439 = primCdr(closureRef(co, 1));
Obj _35reg2440 = primCar(_35reg2439);
Obj x = _35reg2440;
Obj _35reg2441 = primCdr(closureRef(co, 1));
Obj _35reg2442 = primCdr(_35reg2441);
Obj _35reg2443 = primEQ(Nil, _35reg2442);
if (True == _35reg2443) {
Obj _35reg2444 = primCons(x, Nil);
Obj _35reg2445 = primCons(intern("%const"), _35reg2444);
co->nargs = 2;
co->args[1] = _35reg2445;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2045;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3694(struct Cora* co) {
Obj _35cc2046 = makeNative(_35clofun3695, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg2430 = primIsSymbol(x);
if (True == _35reg2430) {
pushCont(co, _35clofun3718, 1, x);
co->nargs = 3;
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = env;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2046;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3718(struct Cora* co) {
Obj _35val2431 = co->args[1];
Obj x = co->stack[co->base + 0];
if (True == _35val2431) {
co->nargs = 2;
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2432 = primCons(x, Nil);
Obj _35reg2433 = primCons(intern("%global"), _35reg2432);
co->nargs = 2;
co->args[1] = _35reg2433;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun3695(struct Cora* co) {
Obj _35cc2047 = makeNative(_35clofun3696, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg2408 = primIsCons(closureRef(co, 1));
if (True == _35reg2408) {
Obj _35reg2409 = primCar(closureRef(co, 1));
Obj _35reg2410 = primEQ(intern("lambda"), _35reg2409);
if (True == _35reg2410) {
Obj _35reg2411 = primCdr(closureRef(co, 1));
Obj _35reg2412 = primIsCons(_35reg2411);
if (True == _35reg2412) {
Obj _35reg2413 = primCdr(closureRef(co, 1));
Obj _35reg2414 = primCar(_35reg2413);
Obj args = _35reg2414;
Obj _35reg2415 = primCdr(closureRef(co, 1));
Obj _35reg2416 = primCdr(_35reg2415);
Obj _35reg2417 = primIsCons(_35reg2416);
if (True == _35reg2417) {
Obj _35reg2418 = primCdr(closureRef(co, 1));
Obj _35reg2419 = primCdr(_35reg2418);
Obj _35reg2420 = primCar(_35reg2419);
Obj body = _35reg2420;
Obj _35reg2421 = primCdr(closureRef(co, 1));
Obj _35reg2422 = primCdr(_35reg2421);
Obj _35reg2423 = primCdr(_35reg2422);
Obj _35reg2424 = primEQ(Nil, _35reg2423);
if (True == _35reg2424) {
pushCont(co, _35clofun3716, 2, body, args);
co->nargs = 3;
co->args[0] = globalRef(intern("append"));
co->args[1] = args;
co->args[2] = env;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2047;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3716(struct Cora* co) {
Obj _35val2425 = co->args[1];
Obj body = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
pushCont(co, _35clofun3717, 1, args);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = _35val2425;
co->args[2] = body;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3717(struct Cora* co) {
Obj _35val2426 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg2427 = primCons(_35val2426, Nil);
Obj _35reg2428 = primCons(args, _35reg2427);
Obj _35reg2429 = primCons(intern("lambda"), _35reg2428);
co->nargs = 2;
co->args[1] = _35reg2429;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3696(struct Cora* co) {
Obj _35cc2048 = makeNative(_35clofun3697, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg2401 = primIsCons(closureRef(co, 1));
if (True == _35reg2401) {
Obj _35reg2402 = primCar(closureRef(co, 1));
Obj _35reg2403 = primEQ(intern("if"), _35reg2402);
if (True == _35reg2403) {
Obj _35reg2404 = primCdr(closureRef(co, 1));
Obj args = _35reg2404;
pushCont(co, _35clofun3714, 1, args);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2048;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3714(struct Cora* co) {
Obj _35val2405 = co->args[1];
Obj args = co->stack[co->base + 0];
pushCont(co, _35clofun3715, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2405;
co->args[2] = args;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3715(struct Cora* co) {
Obj _35val2406 = co->args[1];
Obj _35reg2407 = primCons(intern("if"), _35val2406);
co->nargs = 2;
co->args[1] = _35reg2407;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3697(struct Cora* co) {
Obj _35cc2049 = makeNative(_35clofun3698, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg2379 = primIsCons(closureRef(co, 1));
if (True == _35reg2379) {
Obj _35reg2380 = primCar(closureRef(co, 1));
Obj _35reg2381 = primEQ(intern("do"), _35reg2380);
if (True == _35reg2381) {
Obj _35reg2382 = primCdr(closureRef(co, 1));
Obj _35reg2383 = primIsCons(_35reg2382);
if (True == _35reg2383) {
Obj _35reg2384 = primCdr(closureRef(co, 1));
Obj _35reg2385 = primCar(_35reg2384);
Obj x = _35reg2385;
Obj _35reg2386 = primCdr(closureRef(co, 1));
Obj _35reg2387 = primCdr(_35reg2386);
Obj _35reg2388 = primIsCons(_35reg2387);
if (True == _35reg2388) {
Obj _35reg2389 = primCdr(closureRef(co, 1));
Obj _35reg2390 = primCdr(_35reg2389);
Obj _35reg2391 = primCar(_35reg2390);
Obj y = _35reg2391;
Obj _35reg2392 = primCdr(closureRef(co, 1));
Obj _35reg2393 = primCdr(_35reg2392);
Obj _35reg2394 = primCdr(_35reg2393);
Obj _35reg2395 = primEQ(Nil, _35reg2394);
if (True == _35reg2395) {
pushCont(co, _35clofun3712, 2, env, y);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = x;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2049;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3712(struct Cora* co) {
Obj _35val2396 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
pushCont(co, _35clofun3713, 1, _35val2396);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = y;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3713(struct Cora* co) {
Obj _35val2397 = co->args[1];
Obj _35val2396 = co->stack[co->base + 0];
Obj _35reg2398 = primCons(_35val2397, Nil);
Obj _35reg2399 = primCons(_35val2396, _35reg2398);
Obj _35reg2400 = primCons(intern("do"), _35reg2399);
co->nargs = 2;
co->args[1] = _35reg2400;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3698(struct Cora* co) {
Obj _35cc2050 = makeNative(_35clofun3699, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg2346 = primIsCons(closureRef(co, 1));
if (True == _35reg2346) {
Obj _35reg2347 = primCar(closureRef(co, 1));
Obj _35reg2348 = primEQ(intern("let"), _35reg2347);
if (True == _35reg2348) {
Obj _35reg2349 = primCdr(closureRef(co, 1));
Obj _35reg2350 = primIsCons(_35reg2349);
if (True == _35reg2350) {
Obj _35reg2351 = primCdr(closureRef(co, 1));
Obj _35reg2352 = primCar(_35reg2351);
Obj a = _35reg2352;
Obj _35reg2353 = primCdr(closureRef(co, 1));
Obj _35reg2354 = primCdr(_35reg2353);
Obj _35reg2355 = primIsCons(_35reg2354);
if (True == _35reg2355) {
Obj _35reg2356 = primCdr(closureRef(co, 1));
Obj _35reg2357 = primCdr(_35reg2356);
Obj _35reg2358 = primCar(_35reg2357);
Obj b = _35reg2358;
Obj _35reg2359 = primCdr(closureRef(co, 1));
Obj _35reg2360 = primCdr(_35reg2359);
Obj _35reg2361 = primCdr(_35reg2360);
Obj _35reg2362 = primIsCons(_35reg2361);
if (True == _35reg2362) {
Obj _35reg2363 = primCdr(closureRef(co, 1));
Obj _35reg2364 = primCdr(_35reg2363);
Obj _35reg2365 = primCdr(_35reg2364);
Obj _35reg2366 = primCar(_35reg2365);
Obj c = _35reg2366;
Obj _35reg2367 = primCdr(closureRef(co, 1));
Obj _35reg2368 = primCdr(_35reg2367);
Obj _35reg2369 = primCdr(_35reg2368);
Obj _35reg2370 = primCdr(_35reg2369);
Obj _35reg2371 = primEQ(Nil, _35reg2370);
if (True == _35reg2371) {
pushCont(co, _35clofun3710, 3, env, c, a);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = b;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2050;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2050;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2050;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2050;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2050;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2050;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3710(struct Cora* co) {
Obj _35val2372 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj a = co->stack[co->base + 2];
Obj _35reg2373 = primCons(a, env);
pushCont(co, _35clofun3711, 2, _35val2372, a);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = _35reg2373;
co->args[2] = c;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3711(struct Cora* co) {
Obj _35val2374 = co->args[1];
Obj _35val2372 = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj _35reg2375 = primCons(_35val2374, Nil);
Obj _35reg2376 = primCons(_35val2372, _35reg2375);
Obj _35reg2377 = primCons(a, _35reg2376);
Obj _35reg2378 = primCons(intern("let"), _35reg2377);
co->nargs = 2;
co->args[1] = _35reg2378;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3699(struct Cora* co) {
Obj _35cc2051 = makeNative(_35clofun3700, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg2326 = primIsCons(closureRef(co, 1));
if (True == _35reg2326) {
Obj _35reg2327 = primCar(closureRef(co, 1));
Obj op = _35reg2327;
Obj _35reg2328 = primCdr(closureRef(co, 1));
Obj args = _35reg2328;
pushCont(co, _35clofun3703, 4, op, args, env, _35cc2051);
co->nargs = 2;
co->args[0] = globalRef(intern("builtin?"));
co->args[1] = op;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2051;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3703(struct Cora* co) {
Obj _35val2329 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj _35cc2051 = co->stack[co->base + 3];
if (True == _35val2329) {
pushCont(co, _35clofun3704, 3, op, args, env);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.builtin->args"));
co->args[1] = op;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2051;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3704(struct Cora* co) {
Obj _35val2330 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj required = _35val2330;
pushCont(co, _35clofun3705, 4, required, op, args, env);
co->nargs = 2;
co->args[0] = globalRef(intern("length"));
co->args[1] = args;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3705(struct Cora* co) {
Obj _35val2331 = co->args[1];
Obj required = co->stack[co->base + 0];
Obj op = co->stack[co->base + 1];
Obj args = co->stack[co->base + 2];
Obj env = co->stack[co->base + 3];
Obj provided = _35val2331;
Obj _35reg2332 = primEQ(required, provided);
if (True == _35reg2332) {
Obj _35reg2333 = primCons(op, Nil);
Obj _35reg2334 = primCons(intern("%builtin"), _35reg2333);
pushCont(co, _35clofun3706, 2, args, _35reg2334);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2338 = primGT(required, provided);
if (True == _35reg2338) {
Obj _35reg2339 = primSub(required, provided);
pushCont(co, _35clofun3708, 3, op, args, env);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.temp-list"));
co->args[1] = _35reg2339;
co->args[2] = Nil;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("primitive call mismatch");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun3708(struct Cora* co) {
Obj _35val2340 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj tmp = _35val2340;
Obj _35reg2341 = primCons(op, args);
pushCont(co, _35clofun3709, 2, tmp, env);
co->nargs = 3;
co->args[0] = globalRef(intern("append"));
co->args[1] = _35reg2341;
co->args[2] = tmp;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3709(struct Cora* co) {
Obj _35val2342 = co->args[1];
Obj tmp = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj _35reg2343 = primCons(_35val2342, Nil);
Obj _35reg2344 = primCons(tmp, _35reg2343);
Obj _35reg2345 = primCons(intern("lambda"), _35reg2344);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = _35reg2345;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3706(struct Cora* co) {
Obj _35val2335 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg2334 = co->stack[co->base + 1];
pushCont(co, _35clofun3707, 1, _35reg2334);
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2335;
co->args[2] = args;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3707(struct Cora* co) {
Obj _35val2336 = co->args[1];
Obj _35reg2334 = co->stack[co->base + 0];
Obj _35reg2337 = primCons(_35reg2334, _35val2336);
co->nargs = 2;
co->args[1] = _35reg2337;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3700(struct Cora* co) {
Obj _35cc2052 = makeNative(_35clofun3701, 0, 0);
Obj env = closureRef(co, 0);
Obj ls = closureRef(co, 1);
pushCont(co, _35clofun3702, 1, ls);
co->nargs = 2;
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3702(struct Cora* co) {
Obj _35val2325 = co->args[1];
Obj ls = co->stack[co->base + 0];
co->nargs = 3;
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2325;
co->args[2] = ls;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3701(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3689(struct Cora* co) {
Obj _35p2038 = co->args[1];
Obj _35p2039 = co->args[2];
Obj _35cc2040 = makeNative(_35clofun3690, 0, 2, _35p2038, _35p2039);
Obj _35reg2323 = primEQ(makeNumber(0), _35p2038);
if (True == _35reg2323) {
Obj res = _35p2039;
co->nargs = 2;
co->args[1] = res;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2040;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3690(struct Cora* co) {
Obj _35cc2041 = makeNative(_35clofun3691, 0, 0);
Obj n = closureRef(co, 0);
Obj res = closureRef(co, 1);
Obj _35reg2320 = primSub(n, makeNumber(1));
Obj _35reg2321 = primGenSym(intern("tmp"));
Obj _35reg2322 = primCons(_35reg2321, res);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.temp-list"));
co->args[1] = _35reg2320;
co->args[2] = _35reg2322;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3691(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3686(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun3687, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3687(struct Cora* co) {
Obj _35val2317 = co->args[1];
Obj find = _35val2317;
pushCont(co, _35clofun3688, 1, find);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = find;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3688(struct Cora* co) {
Obj _35val2318 = co->args[1];
Obj find = co->stack[co->base + 0];
if (True == _35val2318) {
co->nargs = 2;
co->args[1] = makeString1("ERROR");
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("cadr"));
co->args[1] = find;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3683(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun3684, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3684(struct Cora* co) {
Obj _35val2314 = co->args[1];
Obj find = _35val2314;
pushCont(co, _35clofun3685, 1, find);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = find;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3685(struct Cora* co) {
Obj _35val2315 = co->args[1];
Obj find = co->stack[co->base + 0];
if (True == _35val2315) {
co->nargs = 2;
co->args[1] = makeString1("ERROR");
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 2;
co->args[0] = globalRef(intern("caddr"));
co->args[1] = find;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3680(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun3681, 0);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3681(struct Cora* co) {
Obj _35val2310 = co->args[1];
pushCont(co, _35clofun3682, 0);
co->nargs = 2;
co->args[0] = globalRef(intern("null?"));
co->args[1] = _35val2310;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3682(struct Cora* co) {
Obj _35val2311 = co->args[1];
Obj _35reg2312 = primNot(_35val2311);
co->nargs = 2;
co->args[1] = _35reg2312;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3676(struct Cora* co) {
Obj _35p2034 = co->args[1];
Obj _35p2035 = co->args[2];
Obj _35cc2036 = makeNative(_35clofun3677, 0, 2, _35p2034, _35p2035);
Obj x = _35p2034;
Obj _35reg2239 = primEQ(Nil, _35p2035);
if (True == _35reg2239) {
co->nargs = 2;
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2036;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3677(struct Cora* co) {
Obj _35cc2037 = makeNative(_35clofun3678, 0, 0);
Obj x = closureRef(co, 0);
Obj _35reg2234 = primIsCons(closureRef(co, 1));
if (True == _35reg2234) {
Obj _35reg2235 = primCar(closureRef(co, 1));
Obj hd = _35reg2235;
Obj _35reg2236 = primCdr(closureRef(co, 1));
Obj tl = _35reg2236;
pushCont(co, _35clofun3679, 2, x, tl);
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = x;
co->args[2] = hd;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2037;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3679(struct Cora* co) {
Obj _35val2237 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj tl = co->stack[co->base + 1];
Obj _35reg2238 = primLT(_35val2237, makeNumber(0));
if (True == _35reg2238) {
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.exist-in-env"));
co->args[1] = x;
co->args[2] = tl;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 2;
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun3678(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3675(struct Cora* co) {
Obj x = co->args[1];
Obj l = co->args[2];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.pos-in-list0"));
co->args[1] = makeNumber(0);
co->args[2] = x;
co->args[3] = l;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3671(struct Cora* co) {
Obj _35p2028 = co->args[1];
Obj _35p2029 = co->args[2];
Obj _35p2030 = co->args[3];
Obj _35cc2031 = makeNative(_35clofun3672, 0, 3, _35p2028, _35p2029, _35p2030);
Obj __ = _35p2028;
Obj x = _35p2029;
Obj _35reg2231 = primEQ(Nil, _35p2030);
if (True == _35reg2231) {
co->nargs = 2;
co->args[1] = makeNumber(-1);
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2031;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3672(struct Cora* co) {
Obj _35cc2032 = makeNative(_35clofun3673, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj pos = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg2227 = primIsCons(closureRef(co, 2));
if (True == _35reg2227) {
Obj _35reg2228 = primCar(closureRef(co, 2));
Obj a = _35reg2228;
Obj _35reg2229 = primCdr(closureRef(co, 2));
Obj b = _35reg2229;
Obj _35reg2230 = primEQ(x, a);
if (True == _35reg2230) {
co->nargs = 2;
co->args[1] = pos;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2032;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2032;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3673(struct Cora* co) {
Obj _35cc2033 = makeNative(_35clofun3674, 0, 0);
Obj pos = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg2223 = primIsCons(closureRef(co, 2));
if (True == _35reg2223) {
Obj _35reg2224 = primCar(closureRef(co, 2));
Obj a = _35reg2224;
Obj _35reg2225 = primCdr(closureRef(co, 2));
Obj b = _35reg2225;
Obj _35reg2226 = primAdd(pos, makeNumber(1));
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.pos-in-list0"));
co->args[1] = _35reg2226;
co->args[2] = x;
co->args[3] = b;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2033;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3674(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3667(struct Cora* co) {
Obj _35p2023 = co->args[1];
Obj _35p2024 = co->args[2];
Obj _35p2025 = co->args[3];
Obj _35cc2026 = makeNative(_35clofun3668, 0, 3, _35p2023, _35p2024, _35p2025);
Obj f = _35p2023;
Obj acc = _35p2024;
Obj _35reg2221 = primEQ(Nil, _35p2025);
if (True == _35reg2221) {
co->nargs = 2;
co->args[1] = acc;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2026;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3668(struct Cora* co) {
Obj _35cc2027 = makeNative(_35clofun3669, 0, 0);
Obj f = closureRef(co, 0);
Obj acc = closureRef(co, 1);
Obj _35reg2217 = primIsCons(closureRef(co, 2));
if (True == _35reg2217) {
Obj _35reg2218 = primCar(closureRef(co, 2));
Obj x = _35reg2218;
Obj _35reg2219 = primCdr(closureRef(co, 2));
Obj y = _35reg2219;
pushCont(co, _35clofun3670, 2, f, y);
co->nargs = 3;
co->args[0] = f;
co->args[1] = acc;
co->args[2] = x;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2027;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3670(struct Cora* co) {
Obj _35val2220 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
co->nargs = 4;
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = f;
co->args[2] = _35val2220;
co->args[3] = y;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3669(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3663(struct Cora* co) {
Obj _35p2018 = co->args[1];
Obj _35p2019 = co->args[2];
Obj _35cc2020 = makeNative(_35clofun3664, 0, 2, _35p2018, _35p2019);
Obj var = _35p2018;
Obj _35reg2215 = primEQ(Nil, _35p2019);
if (True == _35reg2215) {
co->nargs = 2;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2020;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3664(struct Cora* co) {
Obj _35cc2021 = makeNative(_35clofun3665, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj var = closureRef(co, 0);
Obj _35reg2205 = primIsCons(closureRef(co, 1));
if (True == _35reg2205) {
Obj _35reg2206 = primCar(closureRef(co, 1));
Obj _35reg2207 = primIsCons(_35reg2206);
if (True == _35reg2207) {
Obj _35reg2208 = primCar(closureRef(co, 1));
Obj _35reg2209 = primCar(_35reg2208);
Obj x = _35reg2209;
Obj _35reg2210 = primCar(closureRef(co, 1));
Obj _35reg2211 = primCdr(_35reg2210);
Obj y = _35reg2211;
Obj _35reg2212 = primCdr(closureRef(co, 1));
Obj __ = _35reg2212;
Obj _35reg2213 = primEQ(var, x);
if (True == _35reg2213) {
Obj _35reg2214 = primCons(x, y);
co->nargs = 2;
co->args[1] = _35reg2214;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2021;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2021;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->nargs = 1;
co->args[0] = _35cc2021;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3665(struct Cora* co) {
Obj _35cc2022 = makeNative(_35clofun3666, 0, 0);
Obj var = closureRef(co, 0);
Obj _35reg2202 = primIsCons(closureRef(co, 1));
if (True == _35reg2202) {
Obj _35reg2203 = primCar(closureRef(co, 1));
Obj __ = _35reg2203;
Obj _35reg2204 = primCdr(closureRef(co, 1));
Obj y = _35reg2204;
co->nargs = 3;
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = var;
co->args[2] = y;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->nargs = 1;
co->args[0] = _35cc2022;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3666(struct Cora* co) {
co->nargs = 2;
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

