#include "types.h"
#include "runtime.h"

void entry(struct Cora* co);
void _35clofun2858(struct Cora* co);
void _35clofun2859(struct Cora* co);
void _35clofun3177(struct Cora* co);
void _35clofun3217(struct Cora* co);
void _35clofun3218(struct Cora* co);
void _35clofun3223(struct Cora* co);
void _35clofun3226(struct Cora* co);
void _35clofun3229(struct Cora* co);
void _35clofun3230(struct Cora* co);
void _35clofun3227(struct Cora* co);
void _35clofun3228(struct Cora* co);
void _35clofun3224(struct Cora* co);
void _35clofun3225(struct Cora* co);
void _35clofun3221(struct Cora* co);
void _35clofun3222(struct Cora* co);
void _35clofun3219(struct Cora* co);
void _35clofun3220(struct Cora* co);
void _35clofun3216(struct Cora* co);
void _35clofun3215(struct Cora* co);
void _35clofun3214(struct Cora* co);
void _35clofun3213(struct Cora* co);
void _35clofun3212(struct Cora* co);
void _35clofun3211(struct Cora* co);
void _35clofun3210(struct Cora* co);
void _35clofun3209(struct Cora* co);
void _35clofun3208(struct Cora* co);
void _35clofun3207(struct Cora* co);
void _35clofun3206(struct Cora* co);
void _35clofun3205(struct Cora* co);
void _35clofun3204(struct Cora* co);
void _35clofun3203(struct Cora* co);
void _35clofun3202(struct Cora* co);
void _35clofun3201(struct Cora* co);
void _35clofun3195(struct Cora* co);
void _35clofun3196(struct Cora* co);
void _35clofun3197(struct Cora* co);
void _35clofun3198(struct Cora* co);
void _35clofun3199(struct Cora* co);
void _35clofun3200(struct Cora* co);
void _35clofun3187(struct Cora* co);
void _35clofun3188(struct Cora* co);
void _35clofun3189(struct Cora* co);
void _35clofun3192(struct Cora* co);
void _35clofun3193(struct Cora* co);
void _35clofun3194(struct Cora* co);
void _35clofun3190(struct Cora* co);
void _35clofun3191(struct Cora* co);
void _35clofun3183(struct Cora* co);
void _35clofun3184(struct Cora* co);
void _35clofun3186(struct Cora* co);
void _35clofun3185(struct Cora* co);
void _35clofun3178(struct Cora* co);
void _35clofun3179(struct Cora* co);
void _35clofun3180(struct Cora* co);
void _35clofun3181(struct Cora* co);
void _35clofun3182(struct Cora* co);
void _35clofun3174(struct Cora* co);
void _35clofun3175(struct Cora* co);
void _35clofun3176(struct Cora* co);
void _35clofun3171(struct Cora* co);
void _35clofun3172(struct Cora* co);
void _35clofun3173(struct Cora* co);
void _35clofun3169(struct Cora* co);
void _35clofun3170(struct Cora* co);
void _35clofun3168(struct Cora* co);
void _35clofun3167(struct Cora* co);
void _35clofun3166(struct Cora* co);
void _35clofun3165(struct Cora* co);
void _35clofun3158(struct Cora* co);
void _35clofun3160(struct Cora* co);
void _35clofun3161(struct Cora* co);
void _35clofun3162(struct Cora* co);
void _35clofun3163(struct Cora* co);
void _35clofun3164(struct Cora* co);
void _35clofun3159(struct Cora* co);
void _35clofun3150(struct Cora* co);
void _35clofun3151(struct Cora* co);
void _35clofun3153(struct Cora* co);
void _35clofun3154(struct Cora* co);
void _35clofun3155(struct Cora* co);
void _35clofun3156(struct Cora* co);
void _35clofun3157(struct Cora* co);
void _35clofun3152(struct Cora* co);
void _35clofun3146(struct Cora* co);
void _35clofun3147(struct Cora* co);
void _35clofun3148(struct Cora* co);
void _35clofun3149(struct Cora* co);
void _35clofun3145(struct Cora* co);
void _35clofun3139(struct Cora* co);
void _35clofun3140(struct Cora* co);
void _35clofun3142(struct Cora* co);
void _35clofun3143(struct Cora* co);
void _35clofun3144(struct Cora* co);
void _35clofun3141(struct Cora* co);
void _35clofun3128(struct Cora* co);
void _35clofun3130(struct Cora* co);
void _35clofun3131(struct Cora* co);
void _35clofun3132(struct Cora* co);
void _35clofun3133(struct Cora* co);
void _35clofun3134(struct Cora* co);
void _35clofun3135(struct Cora* co);
void _35clofun3138(struct Cora* co);
void _35clofun3136(struct Cora* co);
void _35clofun3137(struct Cora* co);
void _35clofun3129(struct Cora* co);
void _35clofun3120(struct Cora* co);
void _35clofun3121(struct Cora* co);
void _35clofun3123(struct Cora* co);
void _35clofun3124(struct Cora* co);
void _35clofun3125(struct Cora* co);
void _35clofun3126(struct Cora* co);
void _35clofun3127(struct Cora* co);
void _35clofun3122(struct Cora* co);
void _35clofun3040(struct Cora* co);
void _35clofun3041(struct Cora* co);
void _35clofun3117(struct Cora* co);
void _35clofun3118(struct Cora* co);
void _35clofun3119(struct Cora* co);
void _35clofun3042(struct Cora* co);
void _35clofun3115(struct Cora* co);
void _35clofun3116(struct Cora* co);
void _35clofun3043(struct Cora* co);
void _35clofun3113(struct Cora* co);
void _35clofun3114(struct Cora* co);
void _35clofun3044(struct Cora* co);
void _35clofun3107(struct Cora* co);
void _35clofun3110(struct Cora* co);
void _35clofun3111(struct Cora* co);
void _35clofun3112(struct Cora* co);
void _35clofun3108(struct Cora* co);
void _35clofun3109(struct Cora* co);
void _35clofun3104(struct Cora* co);
void _35clofun3105(struct Cora* co);
void _35clofun3106(struct Cora* co);
void _35clofun3045(struct Cora* co);
void _35clofun3094(struct Cora* co);
void _35clofun3100(struct Cora* co);
void _35clofun3101(struct Cora* co);
void _35clofun3102(struct Cora* co);
void _35clofun3103(struct Cora* co);
void _35clofun3095(struct Cora* co);
void _35clofun3096(struct Cora* co);
void _35clofun3097(struct Cora* co);
void _35clofun3098(struct Cora* co);
void _35clofun3099(struct Cora* co);
void _35clofun3046(struct Cora* co);
void _35clofun3090(struct Cora* co);
void _35clofun3091(struct Cora* co);
void _35clofun3092(struct Cora* co);
void _35clofun3093(struct Cora* co);
void _35clofun3047(struct Cora* co);
void _35clofun3084(struct Cora* co);
void _35clofun3085(struct Cora* co);
void _35clofun3086(struct Cora* co);
void _35clofun3087(struct Cora* co);
void _35clofun3088(struct Cora* co);
void _35clofun3089(struct Cora* co);
void _35clofun3048(struct Cora* co);
void _35clofun3074(struct Cora* co);
void _35clofun3075(struct Cora* co);
void _35clofun3076(struct Cora* co);
void _35clofun3077(struct Cora* co);
void _35clofun3078(struct Cora* co);
void _35clofun3079(struct Cora* co);
void _35clofun3080(struct Cora* co);
void _35clofun3081(struct Cora* co);
void _35clofun3082(struct Cora* co);
void _35clofun3083(struct Cora* co);
void _35clofun3049(struct Cora* co);
void _35clofun3072(struct Cora* co);
void _35clofun3073(struct Cora* co);
void _35clofun3050(struct Cora* co);
void _35clofun3069(struct Cora* co);
void _35clofun3070(struct Cora* co);
void _35clofun3071(struct Cora* co);
void _35clofun3051(struct Cora* co);
void _35clofun3052(struct Cora* co);
void _35clofun3068(struct Cora* co);
void _35clofun3053(struct Cora* co);
void _35clofun3055(struct Cora* co);
void _35clofun3056(struct Cora* co);
void _35clofun3057(struct Cora* co);
void _35clofun3058(struct Cora* co);
void _35clofun3059(struct Cora* co);
void _35clofun3060(struct Cora* co);
void _35clofun3061(struct Cora* co);
void _35clofun3062(struct Cora* co);
void _35clofun3063(struct Cora* co);
void _35clofun3064(struct Cora* co);
void _35clofun3065(struct Cora* co);
void _35clofun3066(struct Cora* co);
void _35clofun3067(struct Cora* co);
void _35clofun3054(struct Cora* co);
void _35clofun3038(struct Cora* co);
void _35clofun3039(struct Cora* co);
void _35clofun3033(struct Cora* co);
void _35clofun3037(struct Cora* co);
void _35clofun3034(struct Cora* co);
void _35clofun3036(struct Cora* co);
void _35clofun3035(struct Cora* co);
void _35clofun3023(struct Cora* co);
void _35clofun3031(struct Cora* co);
void _35clofun3032(struct Cora* co);
void _35clofun3029(struct Cora* co);
void _35clofun3030(struct Cora* co);
void _35clofun3027(struct Cora* co);
void _35clofun3028(struct Cora* co);
void _35clofun3024(struct Cora* co);
void _35clofun3025(struct Cora* co);
void _35clofun3026(struct Cora* co);
void _35clofun3005(struct Cora* co);
void _35clofun3022(struct Cora* co);
void _35clofun3006(struct Cora* co);
void _35clofun3007(struct Cora* co);
void _35clofun3021(struct Cora* co);
void _35clofun3008(struct Cora* co);
void _35clofun3016(struct Cora* co);
void _35clofun3017(struct Cora* co);
void _35clofun3018(struct Cora* co);
void _35clofun3019(struct Cora* co);
void _35clofun3020(struct Cora* co);
void _35clofun3009(struct Cora* co);
void _35clofun3013(struct Cora* co);
void _35clofun3014(struct Cora* co);
void _35clofun3015(struct Cora* co);
void _35clofun3010(struct Cora* co);
void _35clofun3012(struct Cora* co);
void _35clofun3011(struct Cora* co);
void _35clofun2995(struct Cora* co);
void _35clofun2999(struct Cora* co);
void _35clofun3000(struct Cora* co);
void _35clofun3004(struct Cora* co);
void _35clofun3001(struct Cora* co);
void _35clofun3003(struct Cora* co);
void _35clofun3002(struct Cora* co);
void _35clofun2996(struct Cora* co);
void _35clofun2998(struct Cora* co);
void _35clofun2997(struct Cora* co);
void _35clofun2977(struct Cora* co);
void _35clofun2994(struct Cora* co);
void _35clofun2978(struct Cora* co);
void _35clofun2993(struct Cora* co);
void _35clofun2979(struct Cora* co);
void _35clofun2990(struct Cora* co);
void _35clofun2991(struct Cora* co);
void _35clofun2992(struct Cora* co);
void _35clofun2980(struct Cora* co);
void _35clofun2988(struct Cora* co);
void _35clofun2989(struct Cora* co);
void _35clofun2981(struct Cora* co);
void _35clofun2986(struct Cora* co);
void _35clofun2987(struct Cora* co);
void _35clofun2982(struct Cora* co);
void _35clofun2985(struct Cora* co);
void _35clofun2983(struct Cora* co);
void _35clofun2984(struct Cora* co);
void _35clofun2976(struct Cora* co);
void _35clofun2961(struct Cora* co);
void _35clofun2975(struct Cora* co);
void _35clofun2962(struct Cora* co);
void _35clofun2974(struct Cora* co);
void _35clofun2963(struct Cora* co);
void _35clofun2970(struct Cora* co);
void _35clofun2971(struct Cora* co);
void _35clofun2972(struct Cora* co);
void _35clofun2973(struct Cora* co);
void _35clofun2964(struct Cora* co);
void _35clofun2968(struct Cora* co);
void _35clofun2969(struct Cora* co);
void _35clofun2965(struct Cora* co);
void _35clofun2967(struct Cora* co);
void _35clofun2966(struct Cora* co);
void _35clofun2938(struct Cora* co);
void _35clofun2960(struct Cora* co);
void _35clofun2939(struct Cora* co);
void _35clofun2940(struct Cora* co);
void _35clofun2959(struct Cora* co);
void _35clofun2941(struct Cora* co);
void _35clofun2958(struct Cora* co);
void _35clofun2942(struct Cora* co);
void _35clofun2957(struct Cora* co);
void _35clofun2943(struct Cora* co);
void _35clofun2954(struct Cora* co);
void _35clofun2955(struct Cora* co);
void _35clofun2956(struct Cora* co);
void _35clofun2944(struct Cora* co);
void _35clofun2945(struct Cora* co);
void _35clofun2946(struct Cora* co);
void _35clofun2953(struct Cora* co);
void _35clofun2947(struct Cora* co);
void _35clofun2948(struct Cora* co);
void _35clofun2952(struct Cora* co);
void _35clofun2949(struct Cora* co);
void _35clofun2951(struct Cora* co);
void _35clofun2950(struct Cora* co);
void _35clofun2931(struct Cora* co);
void _35clofun2932(struct Cora* co);
void _35clofun2933(struct Cora* co);
void _35clofun2934(struct Cora* co);
void _35clofun2935(struct Cora* co);
void _35clofun2936(struct Cora* co);
void _35clofun2937(struct Cora* co);
void _35clofun2925(struct Cora* co);
void _35clofun2926(struct Cora* co);
void _35clofun2930(struct Cora* co);
void _35clofun2927(struct Cora* co);
void _35clofun2929(struct Cora* co);
void _35clofun2928(struct Cora* co);
void _35clofun2919(struct Cora* co);
void _35clofun2920(struct Cora* co);
void _35clofun2924(struct Cora* co);
void _35clofun2921(struct Cora* co);
void _35clofun2923(struct Cora* co);
void _35clofun2922(struct Cora* co);
void _35clofun2889(struct Cora* co);
void _35clofun2916(struct Cora* co);
void _35clofun2917(struct Cora* co);
void _35clofun2918(struct Cora* co);
void _35clofun2890(struct Cora* co);
void _35clofun2891(struct Cora* co);
void _35clofun2915(struct Cora* co);
void _35clofun2892(struct Cora* co);
void _35clofun2913(struct Cora* co);
void _35clofun2914(struct Cora* co);
void _35clofun2893(struct Cora* co);
void _35clofun2911(struct Cora* co);
void _35clofun2912(struct Cora* co);
void _35clofun2894(struct Cora* co);
void _35clofun2909(struct Cora* co);
void _35clofun2910(struct Cora* co);
void _35clofun2895(struct Cora* co);
void _35clofun2907(struct Cora* co);
void _35clofun2908(struct Cora* co);
void _35clofun2896(struct Cora* co);
void _35clofun2900(struct Cora* co);
void _35clofun2901(struct Cora* co);
void _35clofun2902(struct Cora* co);
void _35clofun2905(struct Cora* co);
void _35clofun2906(struct Cora* co);
void _35clofun2903(struct Cora* co);
void _35clofun2904(struct Cora* co);
void _35clofun2897(struct Cora* co);
void _35clofun2899(struct Cora* co);
void _35clofun2898(struct Cora* co);
void _35clofun2886(struct Cora* co);
void _35clofun2887(struct Cora* co);
void _35clofun2888(struct Cora* co);
void _35clofun2883(struct Cora* co);
void _35clofun2884(struct Cora* co);
void _35clofun2885(struct Cora* co);
void _35clofun2880(struct Cora* co);
void _35clofun2881(struct Cora* co);
void _35clofun2882(struct Cora* co);
void _35clofun2877(struct Cora* co);
void _35clofun2878(struct Cora* co);
void _35clofun2879(struct Cora* co);
void _35clofun2873(struct Cora* co);
void _35clofun2874(struct Cora* co);
void _35clofun2876(struct Cora* co);
void _35clofun2875(struct Cora* co);
void _35clofun2872(struct Cora* co);
void _35clofun2868(struct Cora* co);
void _35clofun2869(struct Cora* co);
void _35clofun2870(struct Cora* co);
void _35clofun2871(struct Cora* co);
void _35clofun2864(struct Cora* co);
void _35clofun2865(struct Cora* co);
void _35clofun2867(struct Cora* co);
void _35clofun2866(struct Cora* co);
void _35clofun2860(struct Cora* co);
void _35clofun2861(struct Cora* co);
void _35clofun2862(struct Cora* co);
void _35clofun2863(struct Cora* co);

void entry(struct Cora* co) {
pushCont(co, _35clofun2858, 0);
co->args[0] = globalRef(intern("import"));
co->args[1] = makeString1("cora/lib/toc/internal");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2858(struct Cora* co) {
Obj _35val1398 = co->args[1];
pushCont(co, _35clofun2859, 0);
co->args[0] = globalRef(intern("import"));
co->args[1] = makeString1("cora/lib/io");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2859(struct Cora* co) {
Obj _35val1399 = co->args[1];
Obj _35reg1414 = primSet(intern("cora/lib/toc/include.assq"), makeNative(_35clofun2860, 2, 0));
Obj _35reg1420 = primSet(intern("cora/lib/toc/include.foldl"), makeNative(_35clofun2864, 3, 0));
Obj _35reg1430 = primSet(intern("cora/lib/toc/include.pos-in-list0"), makeNative(_35clofun2868, 3, 0));
Obj _35reg1431 = primSet(intern("cora/lib/toc/include.index"), makeNative(_35clofun2872, 2, 0));
Obj _35reg1438 = primSet(intern("cora/lib/toc/include.exist-in-env"), makeNative(_35clofun2873, 2, 0));
Obj _35reg1439 = primCons(intern("primSet"), Nil);
Obj _35reg1440 = primCons(makeNumber(2), _35reg1439);
Obj _35reg1441 = primCons(intern("set"), _35reg1440);
Obj _35reg1442 = primCons(intern("primCar"), Nil);
Obj _35reg1443 = primCons(makeNumber(1), _35reg1442);
Obj _35reg1444 = primCons(intern("car"), _35reg1443);
Obj _35reg1445 = primCons(intern("primCdr"), Nil);
Obj _35reg1446 = primCons(makeNumber(1), _35reg1445);
Obj _35reg1447 = primCons(intern("cdr"), _35reg1446);
Obj _35reg1448 = primCons(intern("primCons"), Nil);
Obj _35reg1449 = primCons(makeNumber(2), _35reg1448);
Obj _35reg1450 = primCons(intern("cons"), _35reg1449);
Obj _35reg1451 = primCons(intern("primIsCons"), Nil);
Obj _35reg1452 = primCons(makeNumber(1), _35reg1451);
Obj _35reg1453 = primCons(intern("cons?"), _35reg1452);
Obj _35reg1454 = primCons(intern("primAdd"), Nil);
Obj _35reg1455 = primCons(makeNumber(2), _35reg1454);
Obj _35reg1456 = primCons(intern("+"), _35reg1455);
Obj _35reg1457 = primCons(intern("primSub"), Nil);
Obj _35reg1458 = primCons(makeNumber(2), _35reg1457);
Obj _35reg1459 = primCons(intern("-"), _35reg1458);
Obj _35reg1460 = primCons(intern("primMul"), Nil);
Obj _35reg1461 = primCons(makeNumber(2), _35reg1460);
Obj _35reg1462 = primCons(intern("*"), _35reg1461);
Obj _35reg1463 = primCons(intern("primDiv"), Nil);
Obj _35reg1464 = primCons(makeNumber(2), _35reg1463);
Obj _35reg1465 = primCons(intern("/"), _35reg1464);
Obj _35reg1466 = primCons(intern("primEQ"), Nil);
Obj _35reg1467 = primCons(makeNumber(2), _35reg1466);
Obj _35reg1468 = primCons(intern("="), _35reg1467);
Obj _35reg1469 = primCons(intern("primGT"), Nil);
Obj _35reg1470 = primCons(makeNumber(2), _35reg1469);
Obj _35reg1471 = primCons(intern(">"), _35reg1470);
Obj _35reg1472 = primCons(intern("primLT"), Nil);
Obj _35reg1473 = primCons(makeNumber(2), _35reg1472);
Obj _35reg1474 = primCons(intern("<"), _35reg1473);
Obj _35reg1475 = primCons(intern("primGenSym"), Nil);
Obj _35reg1476 = primCons(makeNumber(1), _35reg1475);
Obj _35reg1477 = primCons(intern("gensym"), _35reg1476);
Obj _35reg1478 = primCons(intern("primIsSymbol"), Nil);
Obj _35reg1479 = primCons(makeNumber(1), _35reg1478);
Obj _35reg1480 = primCons(intern("symbol?"), _35reg1479);
Obj _35reg1481 = primCons(intern("primNot"), Nil);
Obj _35reg1482 = primCons(makeNumber(1), _35reg1481);
Obj _35reg1483 = primCons(intern("not"), _35reg1482);
Obj _35reg1484 = primCons(intern("primIsNumber"), Nil);
Obj _35reg1485 = primCons(makeNumber(1), _35reg1484);
Obj _35reg1486 = primCons(intern("integer?"), _35reg1485);
Obj _35reg1487 = primCons(intern("primIsString"), Nil);
Obj _35reg1488 = primCons(makeNumber(1), _35reg1487);
Obj _35reg1489 = primCons(intern("string?"), _35reg1488);
Obj _35reg1490 = primCons(_35reg1489, Nil);
Obj _35reg1491 = primCons(_35reg1486, _35reg1490);
Obj _35reg1492 = primCons(_35reg1483, _35reg1491);
Obj _35reg1493 = primCons(_35reg1480, _35reg1492);
Obj _35reg1494 = primCons(_35reg1477, _35reg1493);
Obj _35reg1495 = primCons(_35reg1474, _35reg1494);
Obj _35reg1496 = primCons(_35reg1471, _35reg1495);
Obj _35reg1497 = primCons(_35reg1468, _35reg1496);
Obj _35reg1498 = primCons(_35reg1465, _35reg1497);
Obj _35reg1499 = primCons(_35reg1462, _35reg1498);
Obj _35reg1500 = primCons(_35reg1459, _35reg1499);
Obj _35reg1501 = primCons(_35reg1456, _35reg1500);
Obj _35reg1502 = primCons(_35reg1453, _35reg1501);
Obj _35reg1503 = primCons(_35reg1450, _35reg1502);
Obj _35reg1504 = primCons(_35reg1447, _35reg1503);
Obj _35reg1505 = primCons(_35reg1444, _35reg1504);
Obj _35reg1506 = primCons(_35reg1441, _35reg1505);
Obj _35reg1507 = primSet(intern("cora/lib/toc/include.*builtin-prims*"), _35reg1506);
Obj _35reg1511 = primSet(intern("builtin?"), makeNative(_35clofun2877, 1, 0));
Obj _35reg1514 = primSet(intern("cora/lib/toc/include.builtin->name"), makeNative(_35clofun2880, 1, 0));
Obj _35reg1517 = primSet(intern("cora/lib/toc/include.builtin->args"), makeNative(_35clofun2883, 1, 0));
Obj _35reg1522 = primSet(intern("cora/lib/toc/include.temp-list"), makeNative(_35clofun2886, 2, 0));
Obj _35reg1658 = primSet(intern("cora/lib/toc/include.parse"), makeNative(_35clofun2889, 2, 0));
Obj _35reg1669 = primSet(intern("cora/lib/toc/include.union"), makeNative(_35clofun2919, 2, 0));
Obj _35reg1680 = primSet(intern("cora/lib/toc/include.diff"), makeNative(_35clofun2925, 2, 0));
Obj _35reg1731 = primSet(intern("cora/lib/toc/include.convert-protect?"), makeNative(_35clofun2931, 1, 0));
Obj _35reg1906 = primSet(intern("cora/lib/toc/include.free-vars"), makeNative(_35clofun2938, 1, 0));
Obj _35reg1979 = primSet(intern("cora/lib/toc/include.closure-convert"), makeNative(_35clofun2961, 2, 0));
Obj _35reg1982 = primSet(intern("cora/lib/toc/include.id"), makeNative(_35clofun2976, 1, 0));
Obj _35reg2119 = primSet(intern("cora/lib/toc/include.tailify"), makeNative(_35clofun2977, 2, 0));
Obj _35reg2166 = primSet(intern("cora/lib/toc/include.tailify-list"), makeNative(_35clofun2995, 3, 0));
Obj _35reg2245 = primSet(intern("cora/lib/toc/include.explicit-stack"), makeNative(_35clofun3005, 2, 0));
Obj _35reg2352 = primSet(intern("cora/lib/toc/include.collect-lambda"), makeNative(_35clofun3023, 3, 0));
Obj _35reg2359 = primSet(intern("cora/lib/toc/include.collect-lambda-list"), makeNative(_35clofun3033, 4, 0));
Obj _35reg2366 = primSet(intern("cora/lib/toc/include.wrap-var"), makeNative(_35clofun3038, 2, 0));
Obj _35reg2626 = primSet(intern("cora/lib/toc/include.generate-inst"), makeNative(_35clofun3040, 3, 0));
Obj _35reg2637 = primSet(intern("cora/lib/toc/include.generate-call-args"), makeNative(_35clofun3120, 4, 0));
Obj _35reg2656 = primSet(intern("cora/lib/toc/include.generate-cont"), makeNative(_35clofun3128, 2, 0));
Obj _35reg2665 = primSet(intern("cora/lib/toc/include.generate-inst-list-h"), makeNative(_35clofun3139, 4, 0));
Obj _35reg2666 = primSet(intern("cora/lib/toc/include.generate-inst-list"), makeNative(_35clofun3145, 3, 0));
Obj _35reg2670 = primSet(intern("cora/lib/toc/include.code-gen-func-declare"), makeNative(_35clofun3146, 2, 0));
Obj _35reg2681 = primSet(intern("cora/lib/toc/include.generate-call-args-reverse"), makeNative(_35clofun3150, 5, 0));
Obj _35reg2738 = primSet(intern("cora/lib/toc/include.code-gen-toplevel"), makeNative(_35clofun3158, 2, 0));
Obj _35reg2739 = primSet(intern("cora/lib/toc/include.parse-pass"), makeNative(_35clofun3165, 1, 0));
Obj _35reg2740 = primSet(intern("cora/lib/toc/include.closure-convert-pass"), makeNative(_35clofun3166, 1, 0));
Obj _35reg2741 = primSet(intern("cora/lib/toc/include.tailify-pass"), makeNative(_35clofun3167, 1, 0));
Obj _35reg2742 = primSet(intern("cora/lib/toc/include.explicit-stack-pass"), makeNative(_35clofun3168, 1, 0));
Obj _35reg2750 = primSet(intern("cora/lib/toc/include.collect-lambda-pass"), makeNative(_35clofun3169, 1, 0));
Obj _35reg2757 = primSet(intern("cora/lib/toc/include.rewrite-->macro"), makeNative(_35clofun3171, 2, 0));
pushCont(co, _35clofun3177, 0);
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("->");
co->args[2] = makeNative(_35clofun3174, 1, 0);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3177(struct Cora* co) {
Obj _35val2760 = co->args[1];
Obj _35reg2765 = primSet(intern("cora/lib/toc/include.compile"), makeNative(_35clofun3178, 1, 0));
Obj _35reg2771 = primSet(intern("for-each"), makeNative(_35clofun3183, 2, 0));
Obj _35reg2778 = primSet(intern("cora/lib/toc/include.generate-c"), makeNative(_35clofun3187, 2, 0));
Obj _35reg2784 = primSet(intern("cora/lib/toc/include.compile-to-c"), makeNative(_35clofun3195, 3, 0));
Obj _35reg2786 = primSet(intern("set"), makeNative(_35clofun3201, 2, 0));
Obj _35reg2788 = primSet(intern("car"), makeNative(_35clofun3202, 1, 0));
Obj _35reg2790 = primSet(intern("cdr"), makeNative(_35clofun3203, 1, 0));
Obj _35reg2792 = primSet(intern("cons"), makeNative(_35clofun3204, 2, 0));
Obj _35reg2794 = primSet(intern("cons"), makeNative(_35clofun3205, 2, 0));
Obj _35reg2796 = primSet(intern("+"), makeNative(_35clofun3206, 2, 0));
Obj _35reg2798 = primSet(intern("-"), makeNative(_35clofun3207, 2, 0));
Obj _35reg2800 = primSet(intern("*"), makeNative(_35clofun3208, 2, 0));
Obj _35reg2802 = primSet(intern("/"), makeNative(_35clofun3209, 2, 0));
Obj _35reg2804 = primSet(intern("="), makeNative(_35clofun3210, 2, 0));
Obj _35reg2806 = primSet(intern(">"), makeNative(_35clofun3211, 2, 0));
Obj _35reg2808 = primSet(intern("<"), makeNative(_35clofun3212, 2, 0));
Obj _35reg2810 = primSet(intern("gensym"), makeNative(_35clofun3213, 1, 0));
Obj _35reg2812 = primSet(intern("symbol?"), makeNative(_35clofun3214, 1, 0));
Obj _35reg2814 = primSet(intern("not"), makeNative(_35clofun3215, 1, 0));
Obj _35reg2816 = primSet(intern("string?"), makeNative(_35clofun3216, 1, 0));
Obj _35reg2857 = primSet(intern("cora/lib/toc/include.eval0"), makeNative(_35clofun3217, 1, 0));
co->args[1] = _35reg2857;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3217(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg2817 = primIsSymbol(exp);
if (True == _35reg2817) {
co->args[0] = globalRef(intern("value"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun3218, 1, exp);
co->args[0] = globalRef(intern("number?"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3218(struct Cora* co) {
Obj _35val2818 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val2818) {
if (True == True) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2819 = primIsCons(exp);
if (True == _35reg2819) {
Obj _35reg2820 = primCar(exp);
Obj _35reg2821 = primEQ(_35reg2820, intern("quote"));
if (True == _35reg2821) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2822 = primCar(exp);
pushCont(co, _35clofun3219, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2822;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
Obj _35reg2826 = primIsString(exp);
if (True == _35reg2826) {
if (True == True) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2827 = primIsCons(exp);
if (True == _35reg2827) {
Obj _35reg2828 = primCar(exp);
Obj _35reg2829 = primEQ(_35reg2828, intern("quote"));
if (True == _35reg2829) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2830 = primCar(exp);
pushCont(co, _35clofun3221, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2830;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
pushCont(co, _35clofun3223, 1, exp);
co->args[0] = globalRef(intern("boolean?"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun3223(struct Cora* co) {
Obj _35val2834 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val2834) {
if (True == True) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2835 = primIsCons(exp);
if (True == _35reg2835) {
Obj _35reg2836 = primCar(exp);
Obj _35reg2837 = primEQ(_35reg2836, intern("quote"));
if (True == _35reg2837) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2838 = primCar(exp);
pushCont(co, _35clofun3224, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2838;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
pushCont(co, _35clofun3226, 1, exp);
co->args[0] = globalRef(intern("null?"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3226(struct Cora* co) {
Obj _35val2842 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val2842) {
if (True == True) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2843 = primIsCons(exp);
if (True == _35reg2843) {
Obj _35reg2844 = primCar(exp);
Obj _35reg2845 = primEQ(_35reg2844, intern("quote"));
if (True == _35reg2845) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2846 = primCar(exp);
pushCont(co, _35clofun3227, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2846;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2850 = primIsCons(exp);
if (True == _35reg2850) {
Obj _35reg2851 = primCar(exp);
Obj _35reg2852 = primEQ(_35reg2851, intern("quote"));
if (True == _35reg2852) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2853 = primCar(exp);
pushCont(co, _35clofun3229, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2853;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun3229(struct Cora* co) {
Obj _35val2854 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2855 = primCdr(exp);
pushCont(co, _35clofun3230, 1, _35val2854);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2855;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3230(struct Cora* co) {
Obj _35val2856 = co->args[1];
Obj _35val2854 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2854;
co->args[2] = _35val2856;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3227(struct Cora* co) {
Obj _35val2847 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2848 = primCdr(exp);
pushCont(co, _35clofun3228, 1, _35val2847);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2848;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3228(struct Cora* co) {
Obj _35val2849 = co->args[1];
Obj _35val2847 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2847;
co->args[2] = _35val2849;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3224(struct Cora* co) {
Obj _35val2839 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2840 = primCdr(exp);
pushCont(co, _35clofun3225, 1, _35val2839);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2840;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3225(struct Cora* co) {
Obj _35val2841 = co->args[1];
Obj _35val2839 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2839;
co->args[2] = _35val2841;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3221(struct Cora* co) {
Obj _35val2831 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2832 = primCdr(exp);
pushCont(co, _35clofun3222, 1, _35val2831);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2832;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3222(struct Cora* co) {
Obj _35val2833 = co->args[1];
Obj _35val2831 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2831;
co->args[2] = _35val2833;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3219(struct Cora* co) {
Obj _35val2823 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2824 = primCdr(exp);
pushCont(co, _35clofun3220, 1, _35val2823);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2824;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3220(struct Cora* co) {
Obj _35val2825 = co->args[1];
Obj _35val2823 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2823;
co->args[2] = _35val2825;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3216(struct Cora* co) {
Obj _35tmp1397 = co->args[1];
Obj _35reg2815 = primIsString(_35tmp1397);
co->args[1] = _35reg2815;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3215(struct Cora* co) {
Obj _35tmp1396 = co->args[1];
Obj _35reg2813 = primNot(_35tmp1396);
co->args[1] = _35reg2813;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3214(struct Cora* co) {
Obj _35tmp1395 = co->args[1];
Obj _35reg2811 = primIsSymbol(_35tmp1395);
co->args[1] = _35reg2811;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3213(struct Cora* co) {
Obj _35tmp1394 = co->args[1];
Obj _35reg2809 = primGenSym(_35tmp1394);
co->args[1] = _35reg2809;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3212(struct Cora* co) {
Obj _35tmp1393 = co->args[1];
Obj _35tmp1392 = co->args[2];
Obj _35reg2807 = primLT(_35tmp1393, _35tmp1392);
co->args[1] = _35reg2807;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3211(struct Cora* co) {
Obj _35tmp1391 = co->args[1];
Obj _35tmp1390 = co->args[2];
Obj _35reg2805 = primGT(_35tmp1391, _35tmp1390);
co->args[1] = _35reg2805;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3210(struct Cora* co) {
Obj _35tmp1389 = co->args[1];
Obj _35tmp1388 = co->args[2];
Obj _35reg2803 = primEQ(_35tmp1389, _35tmp1388);
co->args[1] = _35reg2803;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3209(struct Cora* co) {
Obj _35tmp1387 = co->args[1];
Obj _35tmp1386 = co->args[2];
Obj _35reg2801 = primDiv(_35tmp1387, _35tmp1386);
co->args[1] = _35reg2801;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3208(struct Cora* co) {
Obj _35tmp1385 = co->args[1];
Obj _35tmp1384 = co->args[2];
Obj _35reg2799 = primMul(_35tmp1385, _35tmp1384);
co->args[1] = _35reg2799;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3207(struct Cora* co) {
Obj _35tmp1383 = co->args[1];
Obj _35tmp1382 = co->args[2];
Obj _35reg2797 = primSub(_35tmp1383, _35tmp1382);
co->args[1] = _35reg2797;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3206(struct Cora* co) {
Obj _35tmp1381 = co->args[1];
Obj _35tmp1380 = co->args[2];
Obj _35reg2795 = primAdd(_35tmp1381, _35tmp1380);
co->args[1] = _35reg2795;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3205(struct Cora* co) {
Obj _35tmp1379 = co->args[1];
Obj _35tmp1378 = co->args[2];
Obj _35reg2793 = primCons(_35tmp1379, _35tmp1378);
co->args[1] = _35reg2793;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3204(struct Cora* co) {
Obj _35tmp1377 = co->args[1];
Obj _35tmp1376 = co->args[2];
Obj _35reg2791 = primCons(_35tmp1377, _35tmp1376);
co->args[1] = _35reg2791;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3203(struct Cora* co) {
Obj _35tmp1375 = co->args[1];
Obj _35reg2789 = primCdr(_35tmp1375);
co->args[1] = _35reg2789;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3202(struct Cora* co) {
Obj _35tmp1374 = co->args[1];
Obj _35reg2787 = primCar(_35tmp1374);
co->args[1] = _35reg2787;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3201(struct Cora* co) {
Obj _35tmp1373 = co->args[1];
Obj _35tmp1372 = co->args[2];
Obj _35reg2785 = primSet(_35tmp1373, _35tmp1372);
co->args[1] = _35reg2785;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3195(struct Cora* co) {
Obj from = co->args[1];
Obj to = co->args[2];
Obj pkg_45str = co->args[3];
pushCont(co, _35clofun3196, 1, to);
co->args[0] = globalRef(intern("read-file-as-sexp"));
co->args[1] = from;
co->args[2] = pkg_45str;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3196(struct Cora* co) {
Obj _35val2779 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj sexp = _35val2779;
pushCont(co, _35clofun3197, 1, to);
co->args[0] = globalRef(intern("macroexpand"));
co->args[1] = sexp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3197(struct Cora* co) {
Obj _35val2780 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj input = _35val2780;
pushCont(co, _35clofun3198, 1, to);
co->args[0] = globalRef(intern("cora/lib/toc/include.compile"));
co->args[1] = input;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3198(struct Cora* co) {
Obj _35val2781 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = _35val2781;
pushCont(co, _35clofun3199, 1, bc);
co->args[0] = globalRef(intern("cora/lib/io.open-output-file"));
co->args[1] = to;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3199(struct Cora* co) {
Obj _35val2782 = co->args[1];
Obj bc = co->stack[co->base + 0];
Obj stream = _35val2782;
pushCont(co, _35clofun3200, 1, stream);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-c"));
co->args[1] = stream;
co->args[2] = bc;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3200(struct Cora* co) {
Obj _35val2783 = co->args[1];
Obj stream = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/io.close-output-file"));
co->args[1] = stream;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3187(struct Cora* co) {
Obj to = co->args[1];
Obj bc = co->args[2];
pushCont(co, _35clofun3188, 2, to, bc);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("#include \"types.h\"\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3188(struct Cora* co) {
Obj _35val2772 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3189, 2, to, bc);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("#include \"runtime.h\"\n\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3189(struct Cora* co) {
Obj _35val2773 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3192, 2, to, bc);
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3190, 1, 1, to);
co->args[2] = bc;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3192(struct Cora* co) {
Obj _35val2776 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3193, 2, to, bc);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3193(struct Cora* co) {
Obj _35val2777 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3194, 1, 1, to);
co->args[2] = bc;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3194(struct Cora* co) {
Obj x = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-toplevel"));
co->args[1] = closureRef(co, 0);
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3190(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg2774 = primCar(x);
pushCont(co, _35clofun3191, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-func-declare"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg2774;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3191(struct Cora* co) {
Obj _35val2775 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = closureRef(co, 0);
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3183(struct Cora* co) {
Obj _35p1368 = co->args[1];
Obj _35p1369 = co->args[2];
Obj _35cc1370 = makeNative(_35clofun3184, 0, 2, _35p1368, _35p1369);
Obj fn = _35p1368;
Obj _35reg2770 = primEQ(Nil, _35p1369);
if (True == _35reg2770) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1370;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3184(struct Cora* co) {
Obj _35cc1371 = makeNative(_35clofun3185, 0, 0);
Obj fn = closureRef(co, 0);
Obj _35reg2766 = primIsCons(closureRef(co, 1));
if (True == _35reg2766) {
Obj _35reg2767 = primCar(closureRef(co, 1));
Obj x = _35reg2767;
Obj _35reg2768 = primCdr(closureRef(co, 1));
Obj y = _35reg2768;
pushCont(co, _35clofun3186, 2, fn, y);
co->args[0] = fn;
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1371;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3186(struct Cora* co) {
Obj _35val2769 = co->args[1];
Obj fn = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
co->args[0] = globalRef(intern("for-each"));
co->args[1] = fn;
co->args[2] = y;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3185(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3178(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun3179, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse-pass"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3179(struct Cora* co) {
Obj _35val2761 = co->args[1];
pushCont(co, _35clofun3180, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert-pass"));
co->args[1] = _35val2761;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3180(struct Cora* co) {
Obj _35val2762 = co->args[1];
pushCont(co, _35clofun3181, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-pass"));
co->args[1] = _35val2762;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3181(struct Cora* co) {
Obj _35val2763 = co->args[1];
pushCont(co, _35clofun3182, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack-pass"));
co->args[1] = _35val2763;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3182(struct Cora* co) {
Obj _35val2764 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-pass"));
co->args[1] = _35val2764;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3174(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun3175, 1, exp);
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3175(struct Cora* co) {
Obj _35val2758 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj obj = _35val2758;
pushCont(co, _35clofun3176, 1, obj);
co->args[0] = globalRef(intern("cddr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3176(struct Cora* co) {
Obj _35val2759 = co->args[1];
Obj obj = co->stack[co->base + 0];
Obj fns = _35val2759;
co->args[0] = globalRef(intern("cora/lib/toc/include.rewrite-->macro"));
co->args[1] = obj;
co->args[2] = fns;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3171(struct Cora* co) {
Obj _35p1364 = co->args[1];
Obj _35p1365 = co->args[2];
Obj _35cc1366 = makeNative(_35clofun3172, 0, 2, _35p1364, _35p1365);
Obj obj = _35p1364;
Obj _35reg2756 = primEQ(Nil, _35p1365);
if (True == _35reg2756) {
co->args[1] = obj;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1366;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3172(struct Cora* co) {
Obj _35cc1367 = makeNative(_35clofun3173, 0, 0);
Obj obj = closureRef(co, 0);
Obj _35reg2751 = primIsCons(closureRef(co, 1));
if (True == _35reg2751) {
Obj _35reg2752 = primCar(closureRef(co, 1));
Obj hd = _35reg2752;
Obj _35reg2753 = primCdr(closureRef(co, 1));
Obj more = _35reg2753;
Obj _35reg2754 = primCons(obj, Nil);
Obj _35reg2755 = primCons(hd, _35reg2754);
co->args[0] = globalRef(intern("cora/lib/toc/include.rewrite-->macro"));
co->args[1] = _35reg2755;
co->args[2] = more;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1367;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3173(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3169(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = Nil;
co->args[2] = exp;
co->args[3] = makeNative(_35clofun3170, 2, 0);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3170(struct Cora* co) {
Obj ls = co->args[1];
Obj e1 = co->args[2];
Obj _35reg2743 = primCons(e1, Nil);
Obj _35reg2744 = primCons(Nil, _35reg2743);
Obj _35reg2745 = primCons(Nil, _35reg2744);
Obj _35reg2746 = primCons(intern("lambda"), _35reg2745);
Obj _35reg2747 = primCons(_35reg2746, Nil);
Obj _35reg2748 = primCons(intern("entry"), _35reg2747);
Obj _35reg2749 = primCons(_35reg2748, ls);
co->args[1] = _35reg2749;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3168(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = Nil;
co->args[2] = exp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3167(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = exp;
co->args[2] = globalRef(intern("cora/lib/toc/include.id"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3166(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = Nil;
co->args[2] = exp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3165(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = Nil;
co->args[2] = exp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3158(struct Cora* co) {
Obj _35p1361 = co->args[1];
Obj _35p1362 = co->args[2];
Obj _35cc1363 = makeNative(_35clofun3159, 0, 0);
Obj w = _35p1361;
Obj _35reg2682 = primIsCons(_35p1362);
if (True == _35reg2682) {
Obj _35reg2683 = primCar(_35p1362);
Obj name = _35reg2683;
Obj _35reg2684 = primCdr(_35p1362);
Obj _35reg2685 = primIsCons(_35reg2684);
if (True == _35reg2685) {
Obj _35reg2686 = primCdr(_35p1362);
Obj _35reg2687 = primCar(_35reg2686);
Obj _35reg2688 = primIsCons(_35reg2687);
if (True == _35reg2688) {
Obj _35reg2689 = primCdr(_35p1362);
Obj _35reg2690 = primCar(_35reg2689);
Obj _35reg2691 = primCar(_35reg2690);
Obj _35reg2692 = primEQ(intern("lambda"), _35reg2691);
if (True == _35reg2692) {
Obj _35reg2693 = primCdr(_35p1362);
Obj _35reg2694 = primCar(_35reg2693);
Obj _35reg2695 = primCdr(_35reg2694);
Obj _35reg2696 = primIsCons(_35reg2695);
if (True == _35reg2696) {
Obj _35reg2697 = primCdr(_35p1362);
Obj _35reg2698 = primCar(_35reg2697);
Obj _35reg2699 = primCdr(_35reg2698);
Obj _35reg2700 = primCar(_35reg2699);
Obj params = _35reg2700;
Obj _35reg2701 = primCdr(_35p1362);
Obj _35reg2702 = primCar(_35reg2701);
Obj _35reg2703 = primCdr(_35reg2702);
Obj _35reg2704 = primCdr(_35reg2703);
Obj _35reg2705 = primIsCons(_35reg2704);
if (True == _35reg2705) {
Obj _35reg2706 = primCdr(_35p1362);
Obj _35reg2707 = primCar(_35reg2706);
Obj _35reg2708 = primCdr(_35reg2707);
Obj _35reg2709 = primCdr(_35reg2708);
Obj _35reg2710 = primCar(_35reg2709);
Obj actives = _35reg2710;
Obj _35reg2711 = primCdr(_35p1362);
Obj _35reg2712 = primCar(_35reg2711);
Obj _35reg2713 = primCdr(_35reg2712);
Obj _35reg2714 = primCdr(_35reg2713);
Obj _35reg2715 = primCdr(_35reg2714);
Obj _35reg2716 = primIsCons(_35reg2715);
if (True == _35reg2716) {
Obj _35reg2717 = primCdr(_35p1362);
Obj _35reg2718 = primCar(_35reg2717);
Obj _35reg2719 = primCdr(_35reg2718);
Obj _35reg2720 = primCdr(_35reg2719);
Obj _35reg2721 = primCdr(_35reg2720);
Obj _35reg2722 = primCar(_35reg2721);
Obj body = _35reg2722;
Obj _35reg2723 = primCdr(_35p1362);
Obj _35reg2724 = primCar(_35reg2723);
Obj _35reg2725 = primCdr(_35reg2724);
Obj _35reg2726 = primCdr(_35reg2725);
Obj _35reg2727 = primCdr(_35reg2726);
Obj _35reg2728 = primCdr(_35reg2727);
Obj _35reg2729 = primEQ(Nil, _35reg2728);
if (True == _35reg2729) {
Obj _35reg2730 = primCdr(_35p1362);
Obj _35reg2731 = primCdr(_35reg2730);
Obj _35reg2732 = primEQ(Nil, _35reg2731);
if (True == _35reg2732) {
pushCont(co, _35clofun3160, 4, actives, params, body, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-func-declare"));
co->args[1] = w;
co->args[2] = name;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3160(struct Cora* co) {
Obj _35val2733 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3161, 4, actives, params, body, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3161(struct Cora* co) {
Obj _35val2734 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3162, 4, actives, params, body, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = Nil;
co->args[2] = w;
co->args[3] = makeString1(" = co->args[");
co->args[4] = makeNumber(1);
co->args[5] = params;
co->nargs = 6;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3162(struct Cora* co) {
Obj _35val2735 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3163, 3, params, body, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = Nil;
co->args[2] = w;
co->args[3] = makeString1(" = co->stack[co->base + ");
co->args[4] = makeNumber(0);
co->args[5] = actives;
co->nargs = 6;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3163(struct Cora* co) {
Obj _35val2736 = co->args[1];
Obj params = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3164, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = params;
co->args[2] = w;
co->args[3] = body;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3164(struct Cora* co) {
Obj _35val2737 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("}\n\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3159(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3150(struct Cora* co) {
Obj _35p1354 = co->args[1];
Obj _35p1355 = co->args[2];
Obj _35p1356 = co->args[3];
Obj _35p1357 = co->args[4];
Obj _35p1358 = co->args[5];
Obj _35cc1359 = makeNative(_35clofun3151, 0, 5, _35p1354, _35p1355, _35p1356, _35p1357, _35p1358);
Obj env = _35p1354;
Obj w = _35p1355;
Obj dest_45str = _35p1356;
Obj idx = _35p1357;
Obj _35reg2680 = primEQ(Nil, _35p1358);
if (True == _35reg2680) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1359;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3151(struct Cora* co) {
Obj _35cc1360 = makeNative(_35clofun3152, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj dest_45str = closureRef(co, 2);
Obj idx = closureRef(co, 3);
Obj _35reg2671 = primIsCons(closureRef(co, 4));
if (True == _35reg2671) {
Obj _35reg2672 = primCar(closureRef(co, 4));
Obj a = _35reg2672;
Obj _35reg2673 = primCdr(closureRef(co, 4));
Obj b = _35reg2673;
pushCont(co, _35clofun3153, 6, a, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Obj ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1360;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3153(struct Cora* co) {
Obj _35val2674 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj dest_45str = co->stack[co->base + 4];
Obj b = co->stack[co->base + 5];
pushCont(co, _35clofun3154, 5, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3154(struct Cora* co) {
Obj _35val2675 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3155, 5, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = dest_45str;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3155(struct Cora* co) {
Obj _35val2676 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3156, 5, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = idx;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3156(struct Cora* co) {
Obj _35val2677 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3157, 5, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("];\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3157(struct Cora* co) {
Obj _35val2678 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
Obj _35reg2679 = primAdd(idx, makeNumber(1));
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = dest_45str;
co->args[4] = _35reg2679;
co->args[5] = b;
co->nargs = 6;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3152(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3146(struct Cora* co) {
Obj w = co->args[1];
Obj name = co->args[2];
pushCont(co, _35clofun3147, 2, name, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("void ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3147(struct Cora* co) {
Obj _35val2667 = co->args[1];
Obj name = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3148, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = name;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3148(struct Cora* co) {
Obj _35val2668 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3149, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("(struct Cora* co");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3149(struct Cora* co) {
Obj _35val2669 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3145(struct Cora* co) {
Obj env = co->args[1];
Obj w = co->args[2];
Obj l = co->args[3];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[3] = w;
co->args[4] = l;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3139(struct Cora* co) {
Obj _35p1348 = co->args[1];
Obj _35p1349 = co->args[2];
Obj _35p1350 = co->args[3];
Obj _35p1351 = co->args[4];
Obj _35cc1352 = makeNative(_35clofun3140, 0, 4, _35p1348, _35p1349, _35p1350, _35p1351);
Obj env = _35p1348;
Obj fn = _35p1349;
Obj w = _35p1350;
Obj _35reg2664 = primEQ(Nil, _35p1351);
if (True == _35reg2664) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1352;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3140(struct Cora* co) {
Obj _35cc1353 = makeNative(_35clofun3141, 0, 0);
Obj env = closureRef(co, 0);
Obj fn = closureRef(co, 1);
Obj w = closureRef(co, 2);
Obj _35reg2657 = primIsCons(closureRef(co, 3));
if (True == _35reg2657) {
Obj _35reg2658 = primCar(closureRef(co, 3));
Obj a = _35reg2658;
Obj _35reg2659 = primCdr(closureRef(co, 3));
Obj b = _35reg2659;
pushCont(co, _35clofun3142, 4, env, fn, w, b);
co->args[0] = fn;
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1353;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3142(struct Cora* co) {
Obj _35val2660 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
pushCont(co, _35clofun3143, 4, env, fn, w, b);
co->args[0] = globalRef(intern("null?"));
co->args[1] = b;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3143(struct Cora* co) {
Obj _35val2661 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
Obj _35reg2662 = primNot(_35val2661);
if (True == _35reg2662) {
pushCont(co, _35clofun3144, 4, env, fn, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = fn;
co->args[3] = w;
co->args[4] = b;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3144(struct Cora* co) {
Obj _35val2663 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = fn;
co->args[3] = w;
co->args[4] = b;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3141(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3128(struct Cora* co) {
Obj _35p1345 = co->args[1];
Obj _35p1346 = co->args[2];
Obj _35cc1347 = makeNative(_35clofun3129, 0, 0);
Obj w = _35p1345;
Obj _35reg2638 = primIsCons(_35p1346);
if (True == _35reg2638) {
Obj _35reg2639 = primCar(_35p1346);
Obj _35reg2640 = primEQ(intern("%continuation"), _35reg2639);
if (True == _35reg2640) {
Obj _35reg2641 = primCdr(_35p1346);
Obj _35reg2642 = primIsCons(_35reg2641);
if (True == _35reg2642) {
Obj _35reg2643 = primCdr(_35p1346);
Obj _35reg2644 = primCar(_35reg2643);
Obj label = _35reg2644;
Obj _35reg2645 = primCdr(_35p1346);
Obj _35reg2646 = primCdr(_35reg2645);
Obj stacks = _35reg2646;
pushCont(co, _35clofun3130, 3, label, stacks, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("pushCont(co, ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1347;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1347;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1347;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3130(struct Cora* co) {
Obj _35val2647 = co->args[1];
Obj label = co->stack[co->base + 0];
Obj stacks = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3131, 2, stacks, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = label;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3131(struct Cora* co) {
Obj _35val2648 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3132, 2, stacks, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3132(struct Cora* co) {
Obj _35val2649 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3133, 2, stacks, w);
co->args[0] = globalRef(intern("length"));
co->args[1] = stacks;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3133(struct Cora* co) {
Obj _35val2650 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3134, 2, stacks, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = _35val2650;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3134(struct Cora* co) {
Obj _35val2651 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3135, 2, stacks, w);
co->args[0] = globalRef(intern("null?"));
co->args[1] = stacks;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3135(struct Cora* co) {
Obj _35val2652 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj _35reg2653 = primNot(_35val2652);
if (True == _35reg2653) {
pushCont(co, _35clofun3138, 1, w);
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3136, 1, 1, w);
co->args[2] = stacks;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(");\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3138(struct Cora* co) {
Obj _35val2655 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(");\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3136(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun3137, 1, x);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = closureRef(co, 0);
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3137(struct Cora* co) {
Obj _35val2654 = co->args[1];
Obj x = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = Nil;
co->args[2] = closureRef(co, 0);
co->args[3] = x;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3129(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3120(struct Cora* co) {
Obj _35p1339 = co->args[1];
Obj _35p1340 = co->args[2];
Obj _35p1341 = co->args[3];
Obj _35p1342 = co->args[4];
Obj _35cc1343 = makeNative(_35clofun3121, 0, 4, _35p1339, _35p1340, _35p1341, _35p1342);
Obj env = _35p1339;
Obj w = _35p1340;
Obj idx = _35p1341;
Obj _35reg2636 = primEQ(Nil, _35p1342);
if (True == _35reg2636) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1343;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3121(struct Cora* co) {
Obj _35cc1344 = makeNative(_35clofun3122, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj idx = closureRef(co, 2);
Obj _35reg2627 = primIsCons(closureRef(co, 3));
if (True == _35reg2627) {
Obj _35reg2628 = primCar(closureRef(co, 3));
Obj a = _35reg2628;
Obj _35reg2629 = primCdr(closureRef(co, 3));
Obj b = _35reg2629;
pushCont(co, _35clofun3123, 5, a, idx, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->args[");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1344;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3123(struct Cora* co) {
Obj _35val2630 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3124, 5, a, idx, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = idx;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3124(struct Cora* co) {
Obj _35val2631 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3125, 5, a, idx, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("] = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3125(struct Cora* co) {
Obj _35val2632 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3126, 4, idx, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3126(struct Cora* co) {
Obj _35val2633 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
pushCont(co, _35clofun3127, 4, idx, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3127(struct Cora* co) {
Obj _35val2634 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
Obj _35reg2635 = primAdd(idx, makeNumber(1));
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = _35reg2635;
co->args[4] = b;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3122(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3040(struct Cora* co) {
Obj _35p1322 = co->args[1];
Obj _35p1323 = co->args[2];
Obj _35p1324 = co->args[3];
Obj _35cc1325 = makeNative(_35clofun3041, 0, 3, _35p1322, _35p1323, _35p1324);
Obj env = _35p1322;
Obj w = _35p1323;
Obj x = _35p1324;
Obj _35reg2625 = primIsSymbol(x);
if (True == _35reg2625) {
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1325;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3041(struct Cora* co) {
Obj _35cc1326 = makeNative(_35clofun3042, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2612 = primIsCons(closureRef(co, 2));
if (True == _35reg2612) {
Obj _35reg2613 = primCar(closureRef(co, 2));
Obj _35reg2614 = primEQ(intern("%global"), _35reg2613);
if (True == _35reg2614) {
Obj _35reg2615 = primCdr(closureRef(co, 2));
Obj _35reg2616 = primIsCons(_35reg2615);
if (True == _35reg2616) {
Obj _35reg2617 = primCdr(closureRef(co, 2));
Obj _35reg2618 = primCar(_35reg2617);
Obj x = _35reg2618;
Obj _35reg2619 = primCdr(closureRef(co, 2));
Obj _35reg2620 = primCdr(_35reg2619);
Obj _35reg2621 = primEQ(Nil, _35reg2620);
if (True == _35reg2621) {
pushCont(co, _35clofun3117, 2, x, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("globalRef(intern(\"");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1326;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1326;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1326;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1326;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3117(struct Cora* co) {
Obj _35val2622 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3118, 1, w);
co->args[0] = globalRef(intern("symbol->string"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3118(struct Cora* co) {
Obj _35val2623 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3119, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = _35val2623;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3119(struct Cora* co) {
Obj _35val2624 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\"))");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3042(struct Cora* co) {
Obj _35cc1327 = makeNative(_35clofun3043, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2600 = primIsCons(closureRef(co, 2));
if (True == _35reg2600) {
Obj _35reg2601 = primCar(closureRef(co, 2));
Obj _35reg2602 = primEQ(intern("%closure-ref"), _35reg2601);
if (True == _35reg2602) {
Obj _35reg2603 = primCdr(closureRef(co, 2));
Obj _35reg2604 = primIsCons(_35reg2603);
if (True == _35reg2604) {
Obj _35reg2605 = primCdr(closureRef(co, 2));
Obj _35reg2606 = primCar(_35reg2605);
Obj idx = _35reg2606;
Obj _35reg2607 = primCdr(closureRef(co, 2));
Obj _35reg2608 = primCdr(_35reg2607);
Obj _35reg2609 = primEQ(Nil, _35reg2608);
if (True == _35reg2609) {
pushCont(co, _35clofun3115, 2, idx, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("closureRef(co, ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1327;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1327;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1327;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1327;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3115(struct Cora* co) {
Obj _35val2610 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3116, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = idx;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3116(struct Cora* co) {
Obj _35val2611 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3043(struct Cora* co) {
Obj _35cc1328 = makeNative(_35clofun3044, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2588 = primIsCons(closureRef(co, 2));
if (True == _35reg2588) {
Obj _35reg2589 = primCar(closureRef(co, 2));
Obj _35reg2590 = primEQ(intern("%stack-ref"), _35reg2589);
if (True == _35reg2590) {
Obj _35reg2591 = primCdr(closureRef(co, 2));
Obj _35reg2592 = primIsCons(_35reg2591);
if (True == _35reg2592) {
Obj _35reg2593 = primCdr(closureRef(co, 2));
Obj _35reg2594 = primCar(_35reg2593);
Obj idx = _35reg2594;
Obj _35reg2595 = primCdr(closureRef(co, 2));
Obj _35reg2596 = primCdr(_35reg2595);
Obj _35reg2597 = primEQ(Nil, _35reg2596);
if (True == _35reg2597) {
pushCont(co, _35clofun3113, 2, idx, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("stackRef(co, ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1328;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1328;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1328;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1328;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3113(struct Cora* co) {
Obj _35val2598 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3114, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = idx;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3114(struct Cora* co) {
Obj _35val2599 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3044(struct Cora* co) {
Obj _35cc1329 = makeNative(_35clofun3045, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2564 = primIsCons(closureRef(co, 2));
if (True == _35reg2564) {
Obj _35reg2565 = primCar(closureRef(co, 2));
Obj _35reg2566 = primEQ(intern("%const"), _35reg2565);
if (True == _35reg2566) {
Obj _35reg2567 = primCdr(closureRef(co, 2));
Obj _35reg2568 = primIsCons(_35reg2567);
if (True == _35reg2568) {
Obj _35reg2569 = primCdr(closureRef(co, 2));
Obj _35reg2570 = primCar(_35reg2569);
Obj x = _35reg2570;
Obj _35reg2571 = primCdr(closureRef(co, 2));
Obj _35reg2572 = primCdr(_35reg2571);
Obj _35reg2573 = primEQ(Nil, _35reg2572);
if (True == _35reg2573) {
Obj _35reg2574 = primIsSymbol(x);
if (True == _35reg2574) {
pushCont(co, _35clofun3104, 2, x, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("intern(\"");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun3107, 2, x, w);
co->args[0] = globalRef(intern("number?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1329;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1329;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1329;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1329;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3107(struct Cora* co) {
Obj _35val2578 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
if (True == _35val2578) {
pushCont(co, _35clofun3108, 2, x, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeNumber(");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2581 = primIsString(x);
if (True == _35reg2581) {
pushCont(co, _35clofun3110, 2, x, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeString1(\"");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2585 = primEQ(x, Nil);
if (True == _35reg2585) {
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Nil");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2586 = primEQ(x, True);
if (True == _35reg2586) {
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("True");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2587 = primEQ(x, False);
if (True == _35reg2587) {
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("False");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
}
}
}

void _35clofun3110(struct Cora* co) {
Obj _35val2582 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3111, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.escape-str"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3111(struct Cora* co) {
Obj _35val2583 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3112, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = _35val2583;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3112(struct Cora* co) {
Obj _35val2584 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3108(struct Cora* co) {
Obj _35val2579 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3109, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3109(struct Cora* co) {
Obj _35val2580 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3104(struct Cora* co) {
Obj _35val2575 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3105, 1, w);
co->args[0] = globalRef(intern("symbol->string"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3105(struct Cora* co) {
Obj _35val2576 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3106, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = _35val2576;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3106(struct Cora* co) {
Obj _35val2577 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3045(struct Cora* co) {
Obj _35cc1330 = makeNative(_35clofun3046, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2525 = primIsCons(closureRef(co, 2));
if (True == _35reg2525) {
Obj _35reg2526 = primCar(closureRef(co, 2));
Obj _35reg2527 = primEQ(intern("let"), _35reg2526);
if (True == _35reg2527) {
Obj _35reg2528 = primCdr(closureRef(co, 2));
Obj _35reg2529 = primIsCons(_35reg2528);
if (True == _35reg2529) {
Obj _35reg2530 = primCdr(closureRef(co, 2));
Obj _35reg2531 = primCar(_35reg2530);
Obj a = _35reg2531;
Obj _35reg2532 = primCdr(closureRef(co, 2));
Obj _35reg2533 = primCdr(_35reg2532);
Obj _35reg2534 = primIsCons(_35reg2533);
if (True == _35reg2534) {
Obj _35reg2535 = primCdr(closureRef(co, 2));
Obj _35reg2536 = primCdr(_35reg2535);
Obj _35reg2537 = primCar(_35reg2536);
Obj b = _35reg2537;
Obj _35reg2538 = primCdr(closureRef(co, 2));
Obj _35reg2539 = primCdr(_35reg2538);
Obj _35reg2540 = primCdr(_35reg2539);
Obj _35reg2541 = primIsCons(_35reg2540);
if (True == _35reg2541) {
Obj _35reg2542 = primCdr(closureRef(co, 2));
Obj _35reg2543 = primCdr(_35reg2542);
Obj _35reg2544 = primCdr(_35reg2543);
Obj _35reg2545 = primCar(_35reg2544);
Obj c = _35reg2545;
Obj _35reg2546 = primCdr(closureRef(co, 2));
Obj _35reg2547 = primCdr(_35reg2546);
Obj _35reg2548 = primCdr(_35reg2547);
Obj _35reg2549 = primCdr(_35reg2548);
Obj _35reg2550 = primEQ(Nil, _35reg2549);
if (True == _35reg2550) {
pushCont(co, _35clofun3094, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = a;
co->args[2] = env;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3094(struct Cora* co) {
Obj _35val2551 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
Obj idx = _35val2551;
Obj _35reg2552 = primLT(idx, makeNumber(0));
if (True == _35reg2552) {
pushCont(co, _35clofun3095, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Obj ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
pushCont(co, _35clofun3100, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = a;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3100(struct Cora* co) {
Obj _35val2559 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3101, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3101(struct Cora* co) {
Obj _35val2560 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3102, 4, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3102(struct Cora* co) {
Obj _35val2561 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
pushCont(co, _35clofun3103, 4, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3103(struct Cora* co) {
Obj _35val2562 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj _35reg2563 = primCons(a, env);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = _35reg2563;
co->args[2] = w;
co->args[3] = c;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3095(struct Cora* co) {
Obj _35val2553 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3096, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = a;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3096(struct Cora* co) {
Obj _35val2554 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3097, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3097(struct Cora* co) {
Obj _35val2555 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3098, 4, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3098(struct Cora* co) {
Obj _35val2556 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
pushCont(co, _35clofun3099, 4, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3099(struct Cora* co) {
Obj _35val2557 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj _35reg2558 = primCons(a, env);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = _35reg2558;
co->args[2] = w;
co->args[3] = c;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3046(struct Cora* co) {
Obj _35cc1331 = makeNative(_35clofun3047, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2504 = primIsCons(closureRef(co, 2));
if (True == _35reg2504) {
Obj _35reg2505 = primCar(closureRef(co, 2));
Obj _35reg2506 = primIsCons(_35reg2505);
if (True == _35reg2506) {
Obj _35reg2507 = primCar(closureRef(co, 2));
Obj _35reg2508 = primCar(_35reg2507);
Obj _35reg2509 = primEQ(intern("%builtin"), _35reg2508);
if (True == _35reg2509) {
Obj _35reg2510 = primCar(closureRef(co, 2));
Obj _35reg2511 = primCdr(_35reg2510);
Obj _35reg2512 = primIsCons(_35reg2511);
if (True == _35reg2512) {
Obj _35reg2513 = primCar(closureRef(co, 2));
Obj _35reg2514 = primCdr(_35reg2513);
Obj _35reg2515 = primCar(_35reg2514);
Obj f = _35reg2515;
Obj _35reg2516 = primCar(closureRef(co, 2));
Obj _35reg2517 = primCdr(_35reg2516);
Obj _35reg2518 = primCdr(_35reg2517);
Obj _35reg2519 = primEQ(Nil, _35reg2518);
if (True == _35reg2519) {
Obj _35reg2520 = primCdr(closureRef(co, 2));
Obj args = _35reg2520;
pushCont(co, _35clofun3090, 3, env, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.builtin->name"));
co->args[1] = f;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3090(struct Cora* co) {
Obj _35val2521 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3091, 3, env, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = _35val2521;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3091(struct Cora* co) {
Obj _35val2522 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3092, 3, env, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("(");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3092(struct Cora* co) {
Obj _35val2523 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3093, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = args;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3093(struct Cora* co) {
Obj _35val2524 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3047(struct Cora* co) {
Obj _35cc1332 = makeNative(_35clofun3048, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2472 = primIsCons(closureRef(co, 2));
if (True == _35reg2472) {
Obj _35reg2473 = primCar(closureRef(co, 2));
Obj _35reg2474 = primEQ(intern("if"), _35reg2473);
if (True == _35reg2474) {
Obj _35reg2475 = primCdr(closureRef(co, 2));
Obj _35reg2476 = primIsCons(_35reg2475);
if (True == _35reg2476) {
Obj _35reg2477 = primCdr(closureRef(co, 2));
Obj _35reg2478 = primCar(_35reg2477);
Obj a = _35reg2478;
Obj _35reg2479 = primCdr(closureRef(co, 2));
Obj _35reg2480 = primCdr(_35reg2479);
Obj _35reg2481 = primIsCons(_35reg2480);
if (True == _35reg2481) {
Obj _35reg2482 = primCdr(closureRef(co, 2));
Obj _35reg2483 = primCdr(_35reg2482);
Obj _35reg2484 = primCar(_35reg2483);
Obj b = _35reg2484;
Obj _35reg2485 = primCdr(closureRef(co, 2));
Obj _35reg2486 = primCdr(_35reg2485);
Obj _35reg2487 = primCdr(_35reg2486);
Obj _35reg2488 = primIsCons(_35reg2487);
if (True == _35reg2488) {
Obj _35reg2489 = primCdr(closureRef(co, 2));
Obj _35reg2490 = primCdr(_35reg2489);
Obj _35reg2491 = primCdr(_35reg2490);
Obj _35reg2492 = primCar(_35reg2491);
Obj c = _35reg2492;
Obj _35reg2493 = primCdr(closureRef(co, 2));
Obj _35reg2494 = primCdr(_35reg2493);
Obj _35reg2495 = primCdr(_35reg2494);
Obj _35reg2496 = primCdr(_35reg2495);
Obj _35reg2497 = primEQ(Nil, _35reg2496);
if (True == _35reg2497) {
pushCont(co, _35clofun3084, 5, a, b, env, c, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("if (True == ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3084(struct Cora* co) {
Obj _35val2498 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj b = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj w = co->stack[co->base + 4];
pushCont(co, _35clofun3085, 4, b, env, c, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3085(struct Cora* co) {
Obj _35val2499 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj c = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3086, 4, b, env, c, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(") {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3086(struct Cora* co) {
Obj _35val2500 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj c = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3087, 3, env, c, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3087(struct Cora* co) {
Obj _35val2501 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3088, 3, env, c, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("} else {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3088(struct Cora* co) {
Obj _35val2502 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3089, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = c;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3089(struct Cora* co) {
Obj _35val2503 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("}\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3048(struct Cora* co) {
Obj _35cc1333 = makeNative(_35clofun3049, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2445 = primIsCons(closureRef(co, 2));
if (True == _35reg2445) {
Obj _35reg2446 = primCar(closureRef(co, 2));
Obj _35reg2447 = primEQ(intern("%closure"), _35reg2446);
if (True == _35reg2447) {
Obj _35reg2448 = primCdr(closureRef(co, 2));
Obj _35reg2449 = primIsCons(_35reg2448);
if (True == _35reg2449) {
Obj _35reg2450 = primCdr(closureRef(co, 2));
Obj _35reg2451 = primCar(_35reg2450);
Obj label = _35reg2451;
Obj _35reg2452 = primCdr(closureRef(co, 2));
Obj _35reg2453 = primCdr(_35reg2452);
Obj _35reg2454 = primIsCons(_35reg2453);
if (True == _35reg2454) {
Obj _35reg2455 = primCdr(closureRef(co, 2));
Obj _35reg2456 = primCdr(_35reg2455);
Obj _35reg2457 = primCar(_35reg2456);
Obj nargs = _35reg2457;
Obj _35reg2458 = primCdr(closureRef(co, 2));
Obj _35reg2459 = primCdr(_35reg2458);
Obj _35reg2460 = primCdr(_35reg2459);
Obj frees = _35reg2460;
pushCont(co, _35clofun3074, 5, label, nargs, env, frees, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeNative(");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1333;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1333;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1333;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1333;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3074(struct Cora* co) {
Obj _35val2461 = co->args[1];
Obj label = co->stack[co->base + 0];
Obj nargs = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj frees = co->stack[co->base + 3];
Obj w = co->stack[co->base + 4];
pushCont(co, _35clofun3075, 4, nargs, env, frees, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-sym"));
co->args[1] = w;
co->args[2] = label;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3075(struct Cora* co) {
Obj _35val2462 = co->args[1];
Obj nargs = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj frees = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3076, 4, nargs, env, frees, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3076(struct Cora* co) {
Obj _35val2463 = co->args[1];
Obj nargs = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj frees = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3077, 3, env, frees, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = nargs;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3077(struct Cora* co) {
Obj _35val2464 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3078, 3, env, frees, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3078(struct Cora* co) {
Obj _35val2465 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3079, 3, env, frees, w);
co->args[0] = globalRef(intern("length"));
co->args[1] = frees;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3079(struct Cora* co) {
Obj _35val2466 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3080, 3, env, frees, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = _35val2466;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3080(struct Cora* co) {
Obj _35val2467 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3081, 3, env, frees, w);
co->args[0] = globalRef(intern("null?"));
co->args[1] = frees;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3081(struct Cora* co) {
Obj _35val2468 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj _35reg2469 = primNot(_35val2468);
if (True == _35reg2469) {
pushCont(co, _35clofun3082, 3, env, frees, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3082(struct Cora* co) {
Obj _35val2470 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3083, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = frees;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3083(struct Cora* co) {
Obj _35val2471 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3049(struct Cora* co) {
Obj _35cc1334 = makeNative(_35clofun3050, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2426 = primIsCons(closureRef(co, 2));
if (True == _35reg2426) {
Obj _35reg2427 = primCar(closureRef(co, 2));
Obj _35reg2428 = primEQ(intern("do"), _35reg2427);
if (True == _35reg2428) {
Obj _35reg2429 = primCdr(closureRef(co, 2));
Obj _35reg2430 = primIsCons(_35reg2429);
if (True == _35reg2430) {
Obj _35reg2431 = primCdr(closureRef(co, 2));
Obj _35reg2432 = primCar(_35reg2431);
Obj a = _35reg2432;
Obj _35reg2433 = primCdr(closureRef(co, 2));
Obj _35reg2434 = primCdr(_35reg2433);
Obj _35reg2435 = primIsCons(_35reg2434);
if (True == _35reg2435) {
Obj _35reg2436 = primCdr(closureRef(co, 2));
Obj _35reg2437 = primCdr(_35reg2436);
Obj _35reg2438 = primCar(_35reg2437);
Obj b = _35reg2438;
Obj _35reg2439 = primCdr(closureRef(co, 2));
Obj _35reg2440 = primCdr(_35reg2439);
Obj _35reg2441 = primCdr(_35reg2440);
Obj _35reg2442 = primEQ(Nil, _35reg2441);
if (True == _35reg2442) {
pushCont(co, _35clofun3072, 3, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3072(struct Cora* co) {
Obj _35val2443 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj b = co->stack[co->base + 2];
pushCont(co, _35clofun3073, 3, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3073(struct Cora* co) {
Obj _35val2444 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj b = co->stack[co->base + 2];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3050(struct Cora* co) {
Obj _35cc1335 = makeNative(_35clofun3051, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2413 = primIsCons(closureRef(co, 2));
if (True == _35reg2413) {
Obj _35reg2414 = primCar(closureRef(co, 2));
Obj _35reg2415 = primEQ(intern("return"), _35reg2414);
if (True == _35reg2415) {
Obj _35reg2416 = primCdr(closureRef(co, 2));
Obj _35reg2417 = primIsCons(_35reg2416);
if (True == _35reg2417) {
Obj _35reg2418 = primCdr(closureRef(co, 2));
Obj _35reg2419 = primCar(_35reg2418);
Obj x = _35reg2419;
Obj _35reg2420 = primCdr(closureRef(co, 2));
Obj _35reg2421 = primCdr(_35reg2420);
Obj _35reg2422 = primEQ(Nil, _35reg2421);
if (True == _35reg2422) {
pushCont(co, _35clofun3069, 3, env, x, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->args[1] = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1335;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1335;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1335;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1335;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3069(struct Cora* co) {
Obj _35val2423 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj x = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3070, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = x;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3070(struct Cora* co) {
Obj _35val2424 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3071, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\npopStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3071(struct Cora* co) {
Obj _35val2425 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\nreturn;\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3051(struct Cora* co) {
Obj _35cc1336 = makeNative(_35clofun3052, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2403 = primIsCons(closureRef(co, 2));
if (True == _35reg2403) {
Obj _35reg2404 = primCar(closureRef(co, 2));
Obj _35reg2405 = primEQ(intern("tailcall"), _35reg2404);
if (True == _35reg2405) {
Obj _35reg2406 = primCdr(closureRef(co, 2));
Obj _35reg2407 = primIsCons(_35reg2406);
if (True == _35reg2407) {
Obj _35reg2408 = primCdr(closureRef(co, 2));
Obj _35reg2409 = primCar(_35reg2408);
Obj exp = _35reg2409;
Obj _35reg2410 = primCdr(closureRef(co, 2));
Obj _35reg2411 = primCdr(_35reg2410);
Obj _35reg2412 = primEQ(Nil, _35reg2411);
if (True == _35reg2412) {
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = exp;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1336;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1336;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1336;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1336;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3052(struct Cora* co) {
Obj _35cc1337 = makeNative(_35clofun3053, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2385 = primIsCons(closureRef(co, 2));
if (True == _35reg2385) {
Obj _35reg2386 = primCar(closureRef(co, 2));
Obj _35reg2387 = primEQ(intern("call"), _35reg2386);
if (True == _35reg2387) {
Obj _35reg2388 = primCdr(closureRef(co, 2));
Obj _35reg2389 = primIsCons(_35reg2388);
if (True == _35reg2389) {
Obj _35reg2390 = primCdr(closureRef(co, 2));
Obj _35reg2391 = primCar(_35reg2390);
Obj exp = _35reg2391;
Obj _35reg2392 = primCdr(closureRef(co, 2));
Obj _35reg2393 = primCdr(_35reg2392);
Obj _35reg2394 = primIsCons(_35reg2393);
if (True == _35reg2394) {
Obj _35reg2395 = primCdr(closureRef(co, 2));
Obj _35reg2396 = primCdr(_35reg2395);
Obj _35reg2397 = primCar(_35reg2396);
Obj cont = _35reg2397;
Obj _35reg2398 = primCdr(closureRef(co, 2));
Obj _35reg2399 = primCdr(_35reg2398);
Obj _35reg2400 = primCdr(_35reg2399);
Obj _35reg2401 = primEQ(Nil, _35reg2400);
if (True == _35reg2401) {
pushCont(co, _35clofun3068, 3, env, w, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-cont"));
co->args[1] = w;
co->args[2] = cont;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3068(struct Cora* co) {
Obj _35val2402 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj exp = co->stack[co->base + 2];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = exp;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3053(struct Cora* co) {
Obj _35cc1338 = makeNative(_35clofun3054, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2367 = primIsCons(closureRef(co, 2));
if (True == _35reg2367) {
Obj _35reg2368 = primCar(closureRef(co, 2));
Obj f = _35reg2368;
Obj _35reg2369 = primCdr(closureRef(co, 2));
Obj args = _35reg2369;
Obj _35reg2370 = primCons(f, args);
pushCont(co, _35clofun3055, 3, f, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = makeNumber(0);
co->args[4] = _35reg2370;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1338;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3055(struct Cora* co) {
Obj _35val2371 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3056, 3, f, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->nargs = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3056(struct Cora* co) {
Obj _35val2372 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj _35reg2373 = primCons(f, args);
pushCont(co, _35clofun3057, 2, args, w);
co->args[0] = globalRef(intern("length"));
co->args[1] = _35reg2373;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3057(struct Cora* co) {
Obj _35val2374 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3058, 2, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = _35val2374;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3058(struct Cora* co) {
Obj _35val2375 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3059, 2, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3059(struct Cora* co) {
Obj _35val2376 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3060, 2, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("if (nativeRequired(co->args[0]) == ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3060(struct Cora* co) {
Obj _35val2377 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3061, 1, w);
co->args[0] = globalRef(intern("length"));
co->args[1] = args;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3061(struct Cora* co) {
Obj _35val2378 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3062, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-num"));
co->args[1] = w;
co->args[2] = _35val2378;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3062(struct Cora* co) {
Obj _35val2379 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3063, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(") {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3063(struct Cora* co) {
Obj _35val2380 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3064, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->pc = nativeFuncPtr(co->args[0]);\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3064(struct Cora* co) {
Obj _35val2381 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3065, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->frees = co->args[0];\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3065(struct Cora* co) {
Obj _35val2382 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3066, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("} else {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3066(struct Cora* co) {
Obj _35val2383 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3067, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->pc = coraCall;\n}\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3067(struct Cora* co) {
Obj _35val2384 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/internal.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("return;\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3054(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3038(struct Cora* co) {
Obj x = co->args[1];
Obj k = co->args[2];
Obj _35reg2360 = primGenSym(intern("reg"));
Obj tmp = _35reg2360;
pushCont(co, _35clofun3039, 2, x, tmp);
co->args[0] = k;
co->args[1] = tmp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3039(struct Cora* co) {
Obj _35val2361 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj tmp = co->stack[co->base + 1];
Obj _35reg2362 = primCons(_35val2361, Nil);
Obj _35reg2363 = primCons(x, _35reg2362);
Obj _35reg2364 = primCons(tmp, _35reg2363);
Obj _35reg2365 = primCons(intern("let"), _35reg2364);
co->args[1] = _35reg2365;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3033(struct Cora* co) {
Obj _35p1316 = co->args[1];
Obj _35p1317 = co->args[2];
Obj _35p1318 = co->args[3];
Obj _35p1319 = co->args[4];
Obj _35cc1320 = makeNative(_35clofun3034, 0, 4, _35p1316, _35p1317, _35p1318, _35p1319);
Obj res = _35p1316;
Obj init = _35p1317;
Obj _35reg2357 = primEQ(Nil, _35p1318);
if (True == _35reg2357) {
Obj k = _35p1319;
pushCont(co, _35clofun3037, 2, k, init);
co->args[0] = globalRef(intern("reverse"));
co->args[1] = res;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1320;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3037(struct Cora* co) {
Obj _35val2358 = co->args[1];
Obj k = co->stack[co->base + 0];
Obj init = co->stack[co->base + 1];
co->args[0] = k;
co->args[1] = init;
co->args[2] = _35val2358;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3034(struct Cora* co) {
Obj _35cc1321 = makeNative(_35clofun3035, 0, 0);
Obj res = closureRef(co, 0);
Obj init = closureRef(co, 1);
Obj _35reg2353 = primIsCons(closureRef(co, 2));
if (True == _35reg2353) {
Obj _35reg2354 = primCar(closureRef(co, 2));
Obj x = _35reg2354;
Obj _35reg2355 = primCdr(closureRef(co, 2));
Obj y = _35reg2355;
Obj k = closureRef(co, 3);
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = init;
co->args[2] = x;
co->args[3] = makeNative(_35clofun3036, 2, 3, res, y, k);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1321;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3036(struct Cora* co) {
Obj init1 = co->args[1];
Obj x1 = co->args[2];
Obj _35reg2356 = primCons(x1, closureRef(co, 0));
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-list"));
co->args[1] = _35reg2356;
co->args[2] = init1;
co->args[3] = closureRef(co, 1);
co->args[4] = closureRef(co, 2);
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3035(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3023(struct Cora* co) {
Obj _35p1310 = co->args[1];
Obj _35p1311 = co->args[2];
Obj _35p1312 = co->args[3];
Obj _35cc1313 = makeNative(_35clofun3024, 0, 3, _35p1310, _35p1311, _35p1312);
Obj res = _35p1310;
Obj _35reg2247 = primIsCons(_35p1311);
if (True == _35reg2247) {
Obj _35reg2248 = primCar(_35p1311);
Obj clo_45or_45cont = _35reg2248;
Obj _35reg2249 = primCdr(_35p1311);
Obj _35reg2250 = primIsCons(_35reg2249);
if (True == _35reg2250) {
Obj _35reg2251 = primCdr(_35p1311);
Obj _35reg2252 = primCar(_35reg2251);
Obj _35reg2253 = primIsCons(_35reg2252);
if (True == _35reg2253) {
Obj _35reg2254 = primCdr(_35p1311);
Obj _35reg2255 = primCar(_35reg2254);
Obj _35reg2256 = primCar(_35reg2255);
Obj _35reg2257 = primEQ(intern("lambda"), _35reg2256);
if (True == _35reg2257) {
Obj _35reg2258 = primCdr(_35p1311);
Obj _35reg2259 = primCar(_35reg2258);
Obj _35reg2260 = primCdr(_35reg2259);
Obj _35reg2261 = primIsCons(_35reg2260);
if (True == _35reg2261) {
Obj _35reg2262 = primCdr(_35p1311);
Obj _35reg2263 = primCar(_35reg2262);
Obj _35reg2264 = primCdr(_35reg2263);
Obj _35reg2265 = primCar(_35reg2264);
Obj params = _35reg2265;
Obj _35reg2266 = primCdr(_35p1311);
Obj _35reg2267 = primCar(_35reg2266);
Obj _35reg2268 = primCdr(_35reg2267);
Obj _35reg2269 = primCdr(_35reg2268);
Obj _35reg2270 = primIsCons(_35reg2269);
if (True == _35reg2270) {
Obj _35reg2271 = primCdr(_35p1311);
Obj _35reg2272 = primCar(_35reg2271);
Obj _35reg2273 = primCdr(_35reg2272);
Obj _35reg2274 = primCdr(_35reg2273);
Obj _35reg2275 = primCar(_35reg2274);
Obj body = _35reg2275;
Obj _35reg2276 = primCdr(_35p1311);
Obj _35reg2277 = primCar(_35reg2276);
Obj _35reg2278 = primCdr(_35reg2277);
Obj _35reg2279 = primCdr(_35reg2278);
Obj _35reg2280 = primCdr(_35reg2279);
Obj _35reg2281 = primEQ(Nil, _35reg2280);
if (True == _35reg2281) {
Obj _35reg2282 = primCdr(_35p1311);
Obj _35reg2283 = primCdr(_35reg2282);
Obj fvs = _35reg2283;
Obj k = _35p1312;
Obj _35reg2284 = primEQ(clo_45or_45cont, intern("%closure"));
if (True == _35reg2284) {
if (True == True) {
Obj _35reg2285 = primGenSym(intern("clofun"));
Obj name = _35reg2285;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3027, 2, 5, k, params, clo_45or_45cont, name, fvs);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
Obj _35reg2307 = primEQ(clo_45or_45cont, intern("%continuation"));
if (True == _35reg2307) {
if (True == True) {
Obj _35reg2308 = primGenSym(intern("clofun"));
Obj name = _35reg2308;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3029, 2, 5, k, params, clo_45or_45cont, name, fvs);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg2330 = primGenSym(intern("clofun"));
Obj name = _35reg2330;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3031, 2, 5, k, params, clo_45or_45cont, name, fvs);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3031(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2331 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2331) {
Obj _35reg2332 = primCons(body1, Nil);
Obj _35reg2333 = primCons(Nil, _35reg2332);
Obj _35reg2334 = primCons(closureRef(co, 1), _35reg2333);
Obj _35reg2335 = primCons(intern("lambda"), _35reg2334);
Obj _35reg2336 = primCons(_35reg2335, Nil);
Obj _35reg2337 = primCons(closureRef(co, 3), _35reg2336);
Obj _35reg2338 = primCons(_35reg2337, res1);
pushCont(co, _35clofun3032, 1, _35reg2338);
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2343 = primCons(body1, Nil);
Obj _35reg2344 = primCons(closureRef(co, 4), _35reg2343);
Obj _35reg2345 = primCons(closureRef(co, 1), _35reg2344);
Obj _35reg2346 = primCons(intern("lambda"), _35reg2345);
Obj _35reg2347 = primCons(_35reg2346, Nil);
Obj _35reg2348 = primCons(closureRef(co, 3), _35reg2347);
Obj _35reg2349 = primCons(_35reg2348, res1);
Obj _35reg2350 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2351 = primCons(closureRef(co, 2), _35reg2350);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2349;
co->args[2] = _35reg2351;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3032(struct Cora* co) {
Obj _35val2339 = co->args[1];
Obj _35reg2338 = co->stack[co->base + 0];
Obj _35reg2340 = primCons(_35val2339, closureRef(co, 4));
Obj _35reg2341 = primCons(closureRef(co, 3), _35reg2340);
Obj _35reg2342 = primCons(closureRef(co, 2), _35reg2341);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2338;
co->args[2] = _35reg2342;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3029(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2309 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2309) {
Obj _35reg2310 = primCons(body1, Nil);
Obj _35reg2311 = primCons(Nil, _35reg2310);
Obj _35reg2312 = primCons(closureRef(co, 1), _35reg2311);
Obj _35reg2313 = primCons(intern("lambda"), _35reg2312);
Obj _35reg2314 = primCons(_35reg2313, Nil);
Obj _35reg2315 = primCons(closureRef(co, 3), _35reg2314);
Obj _35reg2316 = primCons(_35reg2315, res1);
pushCont(co, _35clofun3030, 1, _35reg2316);
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2321 = primCons(body1, Nil);
Obj _35reg2322 = primCons(closureRef(co, 4), _35reg2321);
Obj _35reg2323 = primCons(closureRef(co, 1), _35reg2322);
Obj _35reg2324 = primCons(intern("lambda"), _35reg2323);
Obj _35reg2325 = primCons(_35reg2324, Nil);
Obj _35reg2326 = primCons(closureRef(co, 3), _35reg2325);
Obj _35reg2327 = primCons(_35reg2326, res1);
Obj _35reg2328 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2329 = primCons(closureRef(co, 2), _35reg2328);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2327;
co->args[2] = _35reg2329;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3030(struct Cora* co) {
Obj _35val2317 = co->args[1];
Obj _35reg2316 = co->stack[co->base + 0];
Obj _35reg2318 = primCons(_35val2317, closureRef(co, 4));
Obj _35reg2319 = primCons(closureRef(co, 3), _35reg2318);
Obj _35reg2320 = primCons(closureRef(co, 2), _35reg2319);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2316;
co->args[2] = _35reg2320;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3027(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2286 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2286) {
Obj _35reg2287 = primCons(body1, Nil);
Obj _35reg2288 = primCons(Nil, _35reg2287);
Obj _35reg2289 = primCons(closureRef(co, 1), _35reg2288);
Obj _35reg2290 = primCons(intern("lambda"), _35reg2289);
Obj _35reg2291 = primCons(_35reg2290, Nil);
Obj _35reg2292 = primCons(closureRef(co, 3), _35reg2291);
Obj _35reg2293 = primCons(_35reg2292, res1);
pushCont(co, _35clofun3028, 1, _35reg2293);
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2298 = primCons(body1, Nil);
Obj _35reg2299 = primCons(closureRef(co, 4), _35reg2298);
Obj _35reg2300 = primCons(closureRef(co, 1), _35reg2299);
Obj _35reg2301 = primCons(intern("lambda"), _35reg2300);
Obj _35reg2302 = primCons(_35reg2301, Nil);
Obj _35reg2303 = primCons(closureRef(co, 3), _35reg2302);
Obj _35reg2304 = primCons(_35reg2303, res1);
Obj _35reg2305 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2306 = primCons(closureRef(co, 2), _35reg2305);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2304;
co->args[2] = _35reg2306;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3028(struct Cora* co) {
Obj _35val2294 = co->args[1];
Obj _35reg2293 = co->stack[co->base + 0];
Obj _35reg2295 = primCons(_35val2294, closureRef(co, 4));
Obj _35reg2296 = primCons(closureRef(co, 3), _35reg2295);
Obj _35reg2297 = primCons(closureRef(co, 2), _35reg2296);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2293;
co->args[2] = _35reg2297;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3024(struct Cora* co) {
Obj _35cc1314 = makeNative(_35clofun3025, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj res = closureRef(co, 0);
Obj f_45args = closureRef(co, 1);
Obj k = closureRef(co, 2);
Obj _35reg2246 = primIsCons(f_45args);
if (True == _35reg2246) {
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-list"));
co->args[1] = Nil;
co->args[2] = res;
co->args[3] = f_45args;
co->args[4] = k;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1314;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3025(struct Cora* co) {
Obj _35cc1315 = makeNative(_35clofun3026, 0, 0);
Obj res = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj k = closureRef(co, 2);
co->args[0] = k;
co->args[1] = res;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3026(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3005(struct Cora* co) {
Obj _35p1302 = co->args[1];
Obj _35p1303 = co->args[2];
Obj _35cc1304 = makeNative(_35clofun3006, 0, 2, _35p1302, _35p1303);
Obj __ = _35p1302;
Obj x = _35p1303;
pushCont(co, _35clofun3022, 2, x, _35cc1304);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3022(struct Cora* co) {
Obj _35val2244 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1304 = co->stack[co->base + 1];
if (True == _35val2244) {
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1304;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3006(struct Cora* co) {
Obj _35cc1305 = makeNative(_35clofun3007, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj var = closureRef(co, 1);
Obj _35reg2243 = primIsSymbol(var);
if (True == _35reg2243) {
co->args[1] = var;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1305;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3007(struct Cora* co) {
Obj _35cc1306 = makeNative(_35clofun3008, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2222 = primIsCons(closureRef(co, 1));
if (True == _35reg2222) {
Obj _35reg2223 = primCar(closureRef(co, 1));
Obj _35reg2224 = primEQ(intern("lambda"), _35reg2223);
if (True == _35reg2224) {
Obj _35reg2225 = primCdr(closureRef(co, 1));
Obj _35reg2226 = primIsCons(_35reg2225);
if (True == _35reg2226) {
Obj _35reg2227 = primCdr(closureRef(co, 1));
Obj _35reg2228 = primCar(_35reg2227);
Obj args = _35reg2228;
Obj _35reg2229 = primCdr(closureRef(co, 1));
Obj _35reg2230 = primCdr(_35reg2229);
Obj _35reg2231 = primIsCons(_35reg2230);
if (True == _35reg2231) {
Obj _35reg2232 = primCdr(closureRef(co, 1));
Obj _35reg2233 = primCdr(_35reg2232);
Obj _35reg2234 = primCar(_35reg2233);
Obj body = _35reg2234;
Obj _35reg2235 = primCdr(closureRef(co, 1));
Obj _35reg2236 = primCdr(_35reg2235);
Obj _35reg2237 = primCdr(_35reg2236);
Obj _35reg2238 = primEQ(Nil, _35reg2237);
if (True == _35reg2238) {
pushCont(co, _35clofun3021, 1, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->args[2] = body;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3021(struct Cora* co) {
Obj _35val2239 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg2240 = primCons(_35val2239, Nil);
Obj _35reg2241 = primCons(args, _35reg2240);
Obj _35reg2242 = primCons(intern("lambda"), _35reg2241);
co->args[1] = _35reg2242;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3008(struct Cora* co) {
Obj _35cc1307 = makeNative(_35clofun3009, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2195 = primIsCons(closureRef(co, 1));
if (True == _35reg2195) {
Obj _35reg2196 = primCar(closureRef(co, 1));
Obj _35reg2197 = primEQ(intern("continuation"), _35reg2196);
if (True == _35reg2197) {
Obj _35reg2198 = primCdr(closureRef(co, 1));
Obj _35reg2199 = primIsCons(_35reg2198);
if (True == _35reg2199) {
Obj _35reg2200 = primCdr(closureRef(co, 1));
Obj _35reg2201 = primCar(_35reg2200);
Obj val = _35reg2201;
Obj _35reg2202 = primCdr(closureRef(co, 1));
Obj _35reg2203 = primCdr(_35reg2202);
Obj _35reg2204 = primIsCons(_35reg2203);
if (True == _35reg2204) {
Obj _35reg2205 = primCdr(closureRef(co, 1));
Obj _35reg2206 = primCdr(_35reg2205);
Obj _35reg2207 = primCar(_35reg2206);
Obj body = _35reg2207;
Obj _35reg2208 = primCdr(closureRef(co, 1));
Obj _35reg2209 = primCdr(_35reg2208);
Obj _35reg2210 = primCdr(_35reg2209);
Obj _35reg2211 = primEQ(Nil, _35reg2210);
if (True == _35reg2211) {
pushCont(co, _35clofun3016, 3, fvs, body, val);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3016(struct Cora* co) {
Obj _35val2212 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
pushCont(co, _35clofun3017, 3, fvs, body, val);
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val2212;
co->args[2] = val;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3017(struct Cora* co) {
Obj _35val2213 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
Obj fvs1 = _35val2213;
pushCont(co, _35clofun3018, 3, fvs1, body, val);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3018(struct Cora* co) {
Obj _35val2214 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
pushCont(co, _35clofun3019, 3, fvs1, body, val);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2214;
co->args[2] = fvs1;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3019(struct Cora* co) {
Obj _35val2215 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
Obj fvs2 = _35val2215;
pushCont(co, _35clofun3020, 2, val, fvs2);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs1;
co->args[2] = body;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3020(struct Cora* co) {
Obj _35val2216 = co->args[1];
Obj val = co->stack[co->base + 0];
Obj fvs2 = co->stack[co->base + 1];
Obj _35reg2217 = primCons(_35val2216, Nil);
Obj _35reg2218 = primCons(val, _35reg2217);
Obj _35reg2219 = primCons(intern("lambda"), _35reg2218);
Obj _35reg2220 = primCons(_35reg2219, fvs2);
Obj _35reg2221 = primCons(intern("%continuation"), _35reg2220);
co->args[1] = _35reg2221;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3009(struct Cora* co) {
Obj _35cc1308 = makeNative(_35clofun3010, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2172 = primIsCons(closureRef(co, 1));
if (True == _35reg2172) {
Obj _35reg2173 = primCar(closureRef(co, 1));
Obj _35reg2174 = primEQ(intern("call"), _35reg2173);
if (True == _35reg2174) {
Obj _35reg2175 = primCdr(closureRef(co, 1));
Obj _35reg2176 = primIsCons(_35reg2175);
if (True == _35reg2176) {
Obj _35reg2177 = primCdr(closureRef(co, 1));
Obj _35reg2178 = primCar(_35reg2177);
Obj exp = _35reg2178;
Obj _35reg2179 = primCdr(closureRef(co, 1));
Obj _35reg2180 = primCdr(_35reg2179);
Obj _35reg2181 = primIsCons(_35reg2180);
if (True == _35reg2181) {
Obj _35reg2182 = primCdr(closureRef(co, 1));
Obj _35reg2183 = primCdr(_35reg2182);
Obj _35reg2184 = primCar(_35reg2183);
Obj cont = _35reg2184;
Obj _35reg2185 = primCdr(closureRef(co, 1));
Obj _35reg2186 = primCdr(_35reg2185);
Obj _35reg2187 = primCdr(_35reg2186);
Obj _35reg2188 = primEQ(Nil, _35reg2187);
if (True == _35reg2188) {
pushCont(co, _35clofun3013, 3, exp, fvs, cont);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3013(struct Cora* co) {
Obj _35val2189 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj fvs = co->stack[co->base + 1];
Obj cont = co->stack[co->base + 2];
pushCont(co, _35clofun3014, 2, fvs, cont);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2189;
co->args[2] = exp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3014(struct Cora* co) {
Obj _35val2190 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj cont = co->stack[co->base + 1];
pushCont(co, _35clofun3015, 1, _35val2190);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->args[2] = cont;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3015(struct Cora* co) {
Obj _35val2191 = co->args[1];
Obj _35val2190 = co->stack[co->base + 0];
Obj _35reg2192 = primCons(_35val2191, Nil);
Obj _35reg2193 = primCons(_35val2190, _35reg2192);
Obj _35reg2194 = primCons(intern("call"), _35reg2193);
co->args[1] = _35reg2194;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3010(struct Cora* co) {
Obj _35cc1309 = makeNative(_35clofun3011, 0, 0);
Obj fvs = closureRef(co, 0);
Obj _35reg2167 = primIsCons(closureRef(co, 1));
if (True == _35reg2167) {
Obj _35reg2168 = primCar(closureRef(co, 1));
Obj f = _35reg2168;
Obj _35reg2169 = primCdr(closureRef(co, 1));
Obj args = _35reg2169;
pushCont(co, _35clofun3012, 2, f, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1309;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3012(struct Cora* co) {
Obj _35val2170 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj _35reg2171 = primCons(f, args);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2170;
co->args[2] = _35reg2171;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3011(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2995(struct Cora* co) {
Obj _35p1297 = co->args[1];
Obj _35p1298 = co->args[2];
Obj _35p1299 = co->args[3];
Obj _35cc1300 = makeNative(_35clofun2996, 0, 3, _35p1297, _35p1298, _35p1299);
Obj _35reg2124 = primEQ(Nil, _35p1297);
if (True == _35reg2124) {
Obj ls = _35p1298;
Obj next = _35p1299;
pushCont(co, _35clofun2999, 1, next);
co->args[0] = globalRef(intern("reverse"));
co->args[1] = ls;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1300;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2999(struct Cora* co) {
Obj _35val2125 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = _35val2125;
Obj _35reg2126 = primCar(exp);
pushCont(co, _35clofun3000, 2, next, exp);
co->args[0] = globalRef(intern("pair?"));
co->args[1] = _35reg2126;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3000(struct Cora* co) {
Obj _35val2127 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
if (True == _35val2127) {
pushCont(co, _35clofun3001, 2, next, exp);
co->args[0] = globalRef(intern("caar"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
if (True == False) {
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2154 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2154) {
Obj _35reg2155 = primCons(exp, Nil);
Obj _35reg2156 = primCons(intern("tailcall"), _35reg2155);
co->args[1] = _35reg2156;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2157 = primGenSym(intern("val"));
Obj val = _35reg2157;
Obj _35reg2158 = primCons(val, Nil);
pushCont(co, _35clofun3004, 2, _35reg2158, exp);
co->args[0] = next;
co->args[1] = val;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun3004(struct Cora* co) {
Obj _35val2159 = co->args[1];
Obj _35reg2158 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2160 = primCons(_35val2159, Nil);
Obj _35reg2161 = primCons(_35reg2158, _35reg2160);
Obj _35reg2162 = primCons(intern("continuation"), _35reg2161);
Obj _35reg2163 = primCons(_35reg2162, Nil);
Obj _35reg2164 = primCons(exp, _35reg2163);
Obj _35reg2165 = primCons(intern("call"), _35reg2164);
co->args[1] = _35reg2165;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3001(struct Cora* co) {
Obj _35val2128 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2129 = primEQ(_35val2128, intern("%builtin"));
if (True == _35reg2129) {
if (True == True) {
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2130 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2130) {
Obj _35reg2131 = primCons(exp, Nil);
Obj _35reg2132 = primCons(intern("tailcall"), _35reg2131);
co->args[1] = _35reg2132;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2133 = primGenSym(intern("val"));
Obj val = _35reg2133;
Obj _35reg2134 = primCons(val, Nil);
pushCont(co, _35clofun3002, 2, _35reg2134, exp);
co->args[0] = next;
co->args[1] = val;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2142 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2142) {
Obj _35reg2143 = primCons(exp, Nil);
Obj _35reg2144 = primCons(intern("tailcall"), _35reg2143);
co->args[1] = _35reg2144;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2145 = primGenSym(intern("val"));
Obj val = _35reg2145;
Obj _35reg2146 = primCons(val, Nil);
pushCont(co, _35clofun3003, 2, _35reg2146, exp);
co->args[0] = next;
co->args[1] = val;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun3003(struct Cora* co) {
Obj _35val2147 = co->args[1];
Obj _35reg2146 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2148 = primCons(_35val2147, Nil);
Obj _35reg2149 = primCons(_35reg2146, _35reg2148);
Obj _35reg2150 = primCons(intern("continuation"), _35reg2149);
Obj _35reg2151 = primCons(_35reg2150, Nil);
Obj _35reg2152 = primCons(exp, _35reg2151);
Obj _35reg2153 = primCons(intern("call"), _35reg2152);
co->args[1] = _35reg2153;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3002(struct Cora* co) {
Obj _35val2135 = co->args[1];
Obj _35reg2134 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2136 = primCons(_35val2135, Nil);
Obj _35reg2137 = primCons(_35reg2134, _35reg2136);
Obj _35reg2138 = primCons(intern("continuation"), _35reg2137);
Obj _35reg2139 = primCons(_35reg2138, Nil);
Obj _35reg2140 = primCons(exp, _35reg2139);
Obj _35reg2141 = primCons(intern("call"), _35reg2140);
co->args[1] = _35reg2141;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2996(struct Cora* co) {
Obj _35cc1301 = makeNative(_35clofun2997, 0, 0);
Obj _35reg2120 = primIsCons(closureRef(co, 0));
if (True == _35reg2120) {
Obj _35reg2121 = primCar(closureRef(co, 0));
Obj hd = _35reg2121;
Obj _35reg2122 = primCdr(closureRef(co, 0));
Obj tl = _35reg2122;
Obj ls = closureRef(co, 1);
Obj next = closureRef(co, 2);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = hd;
co->args[2] = makeNative(_35clofun2998, 1, 3, tl, ls, next);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1301;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2998(struct Cora* co) {
Obj hd1 = co->args[1];
Obj _35reg2123 = primCons(hd1, closureRef(co, 1));
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-list"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg2123;
co->args[3] = closureRef(co, 2);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2997(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2977(struct Cora* co) {
Obj _35p1288 = co->args[1];
Obj _35p1289 = co->args[2];
Obj _35cc1290 = makeNative(_35clofun2978, 0, 2, _35p1288, _35p1289);
Obj x = _35p1288;
Obj next = _35p1289;
Obj _35reg2117 = primIsSymbol(x);
if (True == _35reg2117) {
if (True == True) {
co->args[0] = next;
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1290;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun2994, 3, next, x, _35cc1290);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2994(struct Cora* co) {
Obj _35val2118 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj x = co->stack[co->base + 1];
Obj _35cc1290 = co->stack[co->base + 2];
if (True == _35val2118) {
if (True == True) {
co->args[0] = next;
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1290;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
co->args[0] = next;
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1290;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun2978(struct Cora* co) {
Obj _35cc1291 = makeNative(_35clofun2979, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj x = closureRef(co, 0);
Obj __ = closureRef(co, 1);
pushCont(co, _35clofun2993, 2, x, _35cc1291);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2993(struct Cora* co) {
Obj _35val2116 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1291 = co->stack[co->base + 1];
if (True == _35val2116) {
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1291;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2979(struct Cora* co) {
Obj _35cc1292 = makeNative(_35clofun2980, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2084 = primIsCons(closureRef(co, 0));
if (True == _35reg2084) {
Obj _35reg2085 = primCar(closureRef(co, 0));
Obj _35reg2086 = primEQ(intern("if"), _35reg2085);
if (True == _35reg2086) {
Obj _35reg2087 = primCdr(closureRef(co, 0));
Obj _35reg2088 = primIsCons(_35reg2087);
if (True == _35reg2088) {
Obj _35reg2089 = primCdr(closureRef(co, 0));
Obj _35reg2090 = primCar(_35reg2089);
Obj a = _35reg2090;
Obj _35reg2091 = primCdr(closureRef(co, 0));
Obj _35reg2092 = primCdr(_35reg2091);
Obj _35reg2093 = primIsCons(_35reg2092);
if (True == _35reg2093) {
Obj _35reg2094 = primCdr(closureRef(co, 0));
Obj _35reg2095 = primCdr(_35reg2094);
Obj _35reg2096 = primCar(_35reg2095);
Obj b = _35reg2096;
Obj _35reg2097 = primCdr(closureRef(co, 0));
Obj _35reg2098 = primCdr(_35reg2097);
Obj _35reg2099 = primCdr(_35reg2098);
Obj _35reg2100 = primIsCons(_35reg2099);
if (True == _35reg2100) {
Obj _35reg2101 = primCdr(closureRef(co, 0));
Obj _35reg2102 = primCdr(_35reg2101);
Obj _35reg2103 = primCdr(_35reg2102);
Obj _35reg2104 = primCar(_35reg2103);
Obj c = _35reg2104;
Obj _35reg2105 = primCdr(closureRef(co, 0));
Obj _35reg2106 = primCdr(_35reg2105);
Obj _35reg2107 = primCdr(_35reg2106);
Obj _35reg2108 = primCdr(_35reg2107);
Obj _35reg2109 = primEQ(Nil, _35reg2108);
if (True == _35reg2109) {
Obj next = closureRef(co, 1);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = a;
co->args[2] = makeNative(_35clofun2990, 1, 3, b, c, next);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2990(struct Cora* co) {
Obj ra = co->args[1];
pushCont(co, _35clofun2991, 1, ra);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 2);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2991(struct Cora* co) {
Obj _35val2110 = co->args[1];
Obj ra = co->stack[co->base + 0];
pushCont(co, _35clofun2992, 2, _35val2110, ra);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 1);
co->args[2] = closureRef(co, 2);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2992(struct Cora* co) {
Obj _35val2111 = co->args[1];
Obj _35val2110 = co->stack[co->base + 0];
Obj ra = co->stack[co->base + 1];
Obj _35reg2112 = primCons(_35val2111, Nil);
Obj _35reg2113 = primCons(_35val2110, _35reg2112);
Obj _35reg2114 = primCons(ra, _35reg2113);
Obj _35reg2115 = primCons(intern("if"), _35reg2114);
co->args[1] = _35reg2115;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2980(struct Cora* co) {
Obj _35cc1293 = makeNative(_35clofun2981, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2062 = primIsCons(closureRef(co, 0));
if (True == _35reg2062) {
Obj _35reg2063 = primCar(closureRef(co, 0));
Obj _35reg2064 = primEQ(intern("do"), _35reg2063);
if (True == _35reg2064) {
Obj _35reg2065 = primCdr(closureRef(co, 0));
Obj _35reg2066 = primIsCons(_35reg2065);
if (True == _35reg2066) {
Obj _35reg2067 = primCdr(closureRef(co, 0));
Obj _35reg2068 = primCar(_35reg2067);
Obj a = _35reg2068;
Obj _35reg2069 = primCdr(closureRef(co, 0));
Obj _35reg2070 = primCdr(_35reg2069);
Obj _35reg2071 = primIsCons(_35reg2070);
if (True == _35reg2071) {
Obj _35reg2072 = primCdr(closureRef(co, 0));
Obj _35reg2073 = primCdr(_35reg2072);
Obj _35reg2074 = primCar(_35reg2073);
Obj b = _35reg2074;
Obj _35reg2075 = primCdr(closureRef(co, 0));
Obj _35reg2076 = primCdr(_35reg2075);
Obj _35reg2077 = primCdr(_35reg2076);
Obj _35reg2078 = primEQ(Nil, _35reg2077);
if (True == _35reg2078) {
Obj next = closureRef(co, 1);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = a;
co->args[2] = makeNative(_35clofun2988, 1, 2, b, next);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2988(struct Cora* co) {
Obj ra = co->args[1];
Obj _35reg2079 = primIsSymbol(ra);
if (True == _35reg2079) {
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 1);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun2989, 1, ra);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 1);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2989(struct Cora* co) {
Obj _35val2080 = co->args[1];
Obj ra = co->stack[co->base + 0];
Obj _35reg2081 = primCons(_35val2080, Nil);
Obj _35reg2082 = primCons(ra, _35reg2081);
Obj _35reg2083 = primCons(intern("do"), _35reg2082);
co->args[1] = _35reg2083;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2981(struct Cora* co) {
Obj _35cc1294 = makeNative(_35clofun2982, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2031 = primIsCons(closureRef(co, 0));
if (True == _35reg2031) {
Obj _35reg2032 = primCar(closureRef(co, 0));
Obj _35reg2033 = primEQ(intern("let"), _35reg2032);
if (True == _35reg2033) {
Obj _35reg2034 = primCdr(closureRef(co, 0));
Obj _35reg2035 = primIsCons(_35reg2034);
if (True == _35reg2035) {
Obj _35reg2036 = primCdr(closureRef(co, 0));
Obj _35reg2037 = primCar(_35reg2036);
Obj a = _35reg2037;
Obj _35reg2038 = primCdr(closureRef(co, 0));
Obj _35reg2039 = primCdr(_35reg2038);
Obj _35reg2040 = primIsCons(_35reg2039);
if (True == _35reg2040) {
Obj _35reg2041 = primCdr(closureRef(co, 0));
Obj _35reg2042 = primCdr(_35reg2041);
Obj _35reg2043 = primCar(_35reg2042);
Obj b = _35reg2043;
Obj _35reg2044 = primCdr(closureRef(co, 0));
Obj _35reg2045 = primCdr(_35reg2044);
Obj _35reg2046 = primCdr(_35reg2045);
Obj _35reg2047 = primIsCons(_35reg2046);
if (True == _35reg2047) {
Obj _35reg2048 = primCdr(closureRef(co, 0));
Obj _35reg2049 = primCdr(_35reg2048);
Obj _35reg2050 = primCdr(_35reg2049);
Obj _35reg2051 = primCar(_35reg2050);
Obj c = _35reg2051;
Obj _35reg2052 = primCdr(closureRef(co, 0));
Obj _35reg2053 = primCdr(_35reg2052);
Obj _35reg2054 = primCdr(_35reg2053);
Obj _35reg2055 = primCdr(_35reg2054);
Obj _35reg2056 = primEQ(Nil, _35reg2055);
if (True == _35reg2056) {
Obj next = closureRef(co, 1);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = b;
co->args[2] = makeNative(_35clofun2986, 1, 3, a, c, next);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2986(struct Cora* co) {
Obj rb = co->args[1];
pushCont(co, _35clofun2987, 1, rb);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 1);
co->args[2] = closureRef(co, 2);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2987(struct Cora* co) {
Obj _35val2057 = co->args[1];
Obj rb = co->stack[co->base + 0];
Obj _35reg2058 = primCons(_35val2057, Nil);
Obj _35reg2059 = primCons(rb, _35reg2058);
Obj _35reg2060 = primCons(closureRef(co, 0), _35reg2059);
Obj _35reg2061 = primCons(intern("let"), _35reg2060);
co->args[1] = _35reg2061;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2982(struct Cora* co) {
Obj _35cc1295 = makeNative(_35clofun2983, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1987 = primIsCons(closureRef(co, 0));
if (True == _35reg1987) {
Obj _35reg1988 = primCar(closureRef(co, 0));
Obj _35reg1989 = primEQ(intern("%closure"), _35reg1988);
if (True == _35reg1989) {
Obj _35reg1990 = primCdr(closureRef(co, 0));
Obj _35reg1991 = primIsCons(_35reg1990);
if (True == _35reg1991) {
Obj _35reg1992 = primCdr(closureRef(co, 0));
Obj _35reg1993 = primCar(_35reg1992);
Obj _35reg1994 = primIsCons(_35reg1993);
if (True == _35reg1994) {
Obj _35reg1995 = primCdr(closureRef(co, 0));
Obj _35reg1996 = primCar(_35reg1995);
Obj _35reg1997 = primCar(_35reg1996);
Obj _35reg1998 = primEQ(intern("lambda"), _35reg1997);
if (True == _35reg1998) {
Obj _35reg1999 = primCdr(closureRef(co, 0));
Obj _35reg2000 = primCar(_35reg1999);
Obj _35reg2001 = primCdr(_35reg2000);
Obj _35reg2002 = primIsCons(_35reg2001);
if (True == _35reg2002) {
Obj _35reg2003 = primCdr(closureRef(co, 0));
Obj _35reg2004 = primCar(_35reg2003);
Obj _35reg2005 = primCdr(_35reg2004);
Obj _35reg2006 = primCar(_35reg2005);
Obj args = _35reg2006;
Obj _35reg2007 = primCdr(closureRef(co, 0));
Obj _35reg2008 = primCar(_35reg2007);
Obj _35reg2009 = primCdr(_35reg2008);
Obj _35reg2010 = primCdr(_35reg2009);
Obj _35reg2011 = primIsCons(_35reg2010);
if (True == _35reg2011) {
Obj _35reg2012 = primCdr(closureRef(co, 0));
Obj _35reg2013 = primCar(_35reg2012);
Obj _35reg2014 = primCdr(_35reg2013);
Obj _35reg2015 = primCdr(_35reg2014);
Obj _35reg2016 = primCar(_35reg2015);
Obj body = _35reg2016;
Obj _35reg2017 = primCdr(closureRef(co, 0));
Obj _35reg2018 = primCar(_35reg2017);
Obj _35reg2019 = primCdr(_35reg2018);
Obj _35reg2020 = primCdr(_35reg2019);
Obj _35reg2021 = primCdr(_35reg2020);
Obj _35reg2022 = primEQ(Nil, _35reg2021);
if (True == _35reg2022) {
Obj _35reg2023 = primCdr(closureRef(co, 0));
Obj _35reg2024 = primCdr(_35reg2023);
Obj frees = _35reg2024;
Obj next = closureRef(co, 1);
pushCont(co, _35clofun2985, 3, args, frees, next);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = body;
co->args[2] = globalRef(intern("cora/lib/toc/include.id"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2985(struct Cora* co) {
Obj _35val2025 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj next = co->stack[co->base + 2];
Obj _35reg2026 = primCons(_35val2025, Nil);
Obj _35reg2027 = primCons(args, _35reg2026);
Obj _35reg2028 = primCons(intern("lambda"), _35reg2027);
Obj _35reg2029 = primCons(_35reg2028, frees);
Obj _35reg2030 = primCons(intern("%closure"), _35reg2029);
co->args[0] = next;
co->args[1] = _35reg2030;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2983(struct Cora* co) {
Obj _35cc1296 = makeNative(_35clofun2984, 0, 0);
Obj _35reg1983 = primIsCons(closureRef(co, 0));
if (True == _35reg1983) {
Obj _35reg1984 = primCar(closureRef(co, 0));
Obj f = _35reg1984;
Obj _35reg1985 = primCdr(closureRef(co, 0));
Obj args = _35reg1985;
Obj next = closureRef(co, 1);
Obj _35reg1986 = primCons(f, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-list"));
co->args[1] = _35reg1986;
co->args[2] = Nil;
co->args[3] = next;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1296;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2984(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2976(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg1980 = primCons(x, Nil);
Obj _35reg1981 = primCons(intern("return"), _35reg1980);
co->args[1] = _35reg1981;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2961(struct Cora* co) {
Obj _35p1281 = co->args[1];
Obj _35p1282 = co->args[2];
Obj _35cc1283 = makeNative(_35clofun2962, 0, 2, _35p1281, _35p1282);
Obj __ = _35p1281;
Obj x = _35p1282;
pushCont(co, _35clofun2975, 2, x, _35cc1283);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2975(struct Cora* co) {
Obj _35val1978 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1283 = co->stack[co->base + 1];
if (True == _35val1978) {
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1283;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2962(struct Cora* co) {
Obj _35cc1284 = makeNative(_35clofun2963, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj var = closureRef(co, 1);
Obj _35reg1973 = primIsSymbol(var);
if (True == _35reg1973) {
pushCont(co, _35clofun2974, 1, var);
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = var;
co->args[2] = fvs;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1284;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2974(struct Cora* co) {
Obj _35val1974 = co->args[1];
Obj var = co->stack[co->base + 0];
Obj pos = _35val1974;
Obj _35reg1975 = primEQ(makeNumber(-1), pos);
if (True == _35reg1975) {
co->args[1] = var;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg1976 = primCons(pos, Nil);
Obj _35reg1977 = primCons(intern("%closure-ref"), _35reg1976);
co->args[1] = _35reg1977;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun2963(struct Cora* co) {
Obj _35cc1285 = makeNative(_35clofun2964, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg1944 = primIsCons(closureRef(co, 1));
if (True == _35reg1944) {
Obj _35reg1945 = primCar(closureRef(co, 1));
Obj _35reg1946 = primEQ(intern("lambda"), _35reg1945);
if (True == _35reg1946) {
Obj _35reg1947 = primCdr(closureRef(co, 1));
Obj _35reg1948 = primIsCons(_35reg1947);
if (True == _35reg1948) {
Obj _35reg1949 = primCdr(closureRef(co, 1));
Obj _35reg1950 = primCar(_35reg1949);
Obj args = _35reg1950;
Obj _35reg1951 = primCdr(closureRef(co, 1));
Obj _35reg1952 = primCdr(_35reg1951);
Obj _35reg1953 = primIsCons(_35reg1952);
if (True == _35reg1953) {
Obj _35reg1954 = primCdr(closureRef(co, 1));
Obj _35reg1955 = primCdr(_35reg1954);
Obj _35reg1956 = primCar(_35reg1955);
Obj body = _35reg1956;
Obj _35reg1957 = primCdr(closureRef(co, 1));
Obj _35reg1958 = primCdr(_35reg1957);
Obj _35reg1959 = primCdr(_35reg1958);
Obj _35reg1960 = primEQ(Nil, _35reg1959);
if (True == _35reg1960) {
Obj _35reg1961 = primCons(body, Nil);
Obj _35reg1962 = primCons(args, _35reg1961);
Obj _35reg1963 = primCons(intern("lambda"), _35reg1962);
pushCont(co, _35clofun2970, 3, body, args, fvs);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = _35reg1963;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2970(struct Cora* co) {
Obj _35val1964 = co->args[1];
Obj body = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj fvs = co->stack[co->base + 2];
Obj fvs1 = _35val1964;
pushCont(co, _35clofun2971, 3, args, fvs, fvs1);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs1;
co->args[2] = body;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2971(struct Cora* co) {
Obj _35val1965 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj fvs = co->stack[co->base + 1];
Obj fvs1 = co->stack[co->base + 2];
Obj _35reg1966 = primCons(_35val1965, Nil);
Obj _35reg1967 = primCons(args, _35reg1966);
Obj _35reg1968 = primCons(intern("lambda"), _35reg1967);
pushCont(co, _35clofun2972, 2, fvs1, _35reg1968);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2972(struct Cora* co) {
Obj _35val1969 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj _35reg1968 = co->stack[co->base + 1];
pushCont(co, _35clofun2973, 1, _35reg1968);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1969;
co->args[2] = fvs1;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2973(struct Cora* co) {
Obj _35val1970 = co->args[1];
Obj _35reg1968 = co->stack[co->base + 0];
Obj _35reg1971 = primCons(_35reg1968, _35val1970);
Obj _35reg1972 = primCons(intern("%closure"), _35reg1971);
co->args[1] = _35reg1972;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2964(struct Cora* co) {
Obj _35cc1286 = makeNative(_35clofun2965, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg1912 = primIsCons(closureRef(co, 1));
if (True == _35reg1912) {
Obj _35reg1913 = primCar(closureRef(co, 1));
Obj _35reg1914 = primEQ(intern("let"), _35reg1913);
if (True == _35reg1914) {
Obj _35reg1915 = primCdr(closureRef(co, 1));
Obj _35reg1916 = primIsCons(_35reg1915);
if (True == _35reg1916) {
Obj _35reg1917 = primCdr(closureRef(co, 1));
Obj _35reg1918 = primCar(_35reg1917);
Obj a = _35reg1918;
Obj _35reg1919 = primCdr(closureRef(co, 1));
Obj _35reg1920 = primCdr(_35reg1919);
Obj _35reg1921 = primIsCons(_35reg1920);
if (True == _35reg1921) {
Obj _35reg1922 = primCdr(closureRef(co, 1));
Obj _35reg1923 = primCdr(_35reg1922);
Obj _35reg1924 = primCar(_35reg1923);
Obj b = _35reg1924;
Obj _35reg1925 = primCdr(closureRef(co, 1));
Obj _35reg1926 = primCdr(_35reg1925);
Obj _35reg1927 = primCdr(_35reg1926);
Obj _35reg1928 = primIsCons(_35reg1927);
if (True == _35reg1928) {
Obj _35reg1929 = primCdr(closureRef(co, 1));
Obj _35reg1930 = primCdr(_35reg1929);
Obj _35reg1931 = primCdr(_35reg1930);
Obj _35reg1932 = primCar(_35reg1931);
Obj c = _35reg1932;
Obj _35reg1933 = primCdr(closureRef(co, 1));
Obj _35reg1934 = primCdr(_35reg1933);
Obj _35reg1935 = primCdr(_35reg1934);
Obj _35reg1936 = primCdr(_35reg1935);
Obj _35reg1937 = primEQ(Nil, _35reg1936);
if (True == _35reg1937) {
pushCont(co, _35clofun2968, 3, fvs, c, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->args[2] = b;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2968(struct Cora* co) {
Obj _35val1938 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj a = co->stack[co->base + 2];
pushCont(co, _35clofun2969, 2, _35val1938, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->args[2] = c;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2969(struct Cora* co) {
Obj _35val1939 = co->args[1];
Obj _35val1938 = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj _35reg1940 = primCons(_35val1939, Nil);
Obj _35reg1941 = primCons(_35val1938, _35reg1940);
Obj _35reg1942 = primCons(a, _35reg1941);
Obj _35reg1943 = primCons(intern("let"), _35reg1942);
co->args[1] = _35reg1943;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2965(struct Cora* co) {
Obj _35cc1287 = makeNative(_35clofun2966, 0, 0);
Obj fvs = closureRef(co, 0);
Obj _35reg1907 = primIsCons(closureRef(co, 1));
if (True == _35reg1907) {
Obj _35reg1908 = primCar(closureRef(co, 1));
Obj f = _35reg1908;
Obj _35reg1909 = primCdr(closureRef(co, 1));
Obj args = _35reg1909;
pushCont(co, _35clofun2967, 2, f, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1287;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2967(struct Cora* co) {
Obj _35val1910 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj _35reg1911 = primCons(f, args);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1910;
co->args[2] = _35reg1911;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2966(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2938(struct Cora* co) {
Obj _35p1268 = co->args[1];
Obj _35cc1269 = makeNative(_35clofun2939, 0, 1, _35p1268);
Obj x = _35p1268;
pushCont(co, _35clofun2960, 1, _35cc1269);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2960(struct Cora* co) {
Obj _35val1905 = co->args[1];
Obj _35cc1269 = co->stack[co->base + 0];
if (True == _35val1905) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1269;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2939(struct Cora* co) {
Obj _35cc1270 = makeNative(_35clofun2940, 0, 1, closureRef(co, 0));
Obj x = closureRef(co, 0);
Obj _35reg1903 = primIsSymbol(x);
if (True == _35reg1903) {
Obj _35reg1904 = primCons(x, Nil);
co->args[1] = _35reg1904;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1270;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2940(struct Cora* co) {
Obj _35cc1271 = makeNative(_35clofun2941, 0, 1, closureRef(co, 0));
Obj _35reg1885 = primIsCons(closureRef(co, 0));
if (True == _35reg1885) {
Obj _35reg1886 = primCar(closureRef(co, 0));
Obj _35reg1887 = primEQ(intern("lambda"), _35reg1886);
if (True == _35reg1887) {
Obj _35reg1888 = primCdr(closureRef(co, 0));
Obj _35reg1889 = primIsCons(_35reg1888);
if (True == _35reg1889) {
Obj _35reg1890 = primCdr(closureRef(co, 0));
Obj _35reg1891 = primCar(_35reg1890);
Obj args = _35reg1891;
Obj _35reg1892 = primCdr(closureRef(co, 0));
Obj _35reg1893 = primCdr(_35reg1892);
Obj _35reg1894 = primIsCons(_35reg1893);
if (True == _35reg1894) {
Obj _35reg1895 = primCdr(closureRef(co, 0));
Obj _35reg1896 = primCdr(_35reg1895);
Obj _35reg1897 = primCar(_35reg1896);
Obj body = _35reg1897;
Obj _35reg1898 = primCdr(closureRef(co, 0));
Obj _35reg1899 = primCdr(_35reg1898);
Obj _35reg1900 = primCdr(_35reg1899);
Obj _35reg1901 = primEQ(Nil, _35reg1900);
if (True == _35reg1901) {
pushCont(co, _35clofun2959, 1, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2959(struct Cora* co) {
Obj _35val1902 = co->args[1];
Obj args = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val1902;
co->args[2] = args;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2941(struct Cora* co) {
Obj _35cc1272 = makeNative(_35clofun2942, 0, 1, closureRef(co, 0));
Obj _35reg1855 = primIsCons(closureRef(co, 0));
if (True == _35reg1855) {
Obj _35reg1856 = primCar(closureRef(co, 0));
Obj _35reg1857 = primEQ(intern("if"), _35reg1856);
if (True == _35reg1857) {
Obj _35reg1858 = primCdr(closureRef(co, 0));
Obj _35reg1859 = primIsCons(_35reg1858);
if (True == _35reg1859) {
Obj _35reg1860 = primCdr(closureRef(co, 0));
Obj _35reg1861 = primCar(_35reg1860);
Obj x = _35reg1861;
Obj _35reg1862 = primCdr(closureRef(co, 0));
Obj _35reg1863 = primCdr(_35reg1862);
Obj _35reg1864 = primIsCons(_35reg1863);
if (True == _35reg1864) {
Obj _35reg1865 = primCdr(closureRef(co, 0));
Obj _35reg1866 = primCdr(_35reg1865);
Obj _35reg1867 = primCar(_35reg1866);
Obj y = _35reg1867;
Obj _35reg1868 = primCdr(closureRef(co, 0));
Obj _35reg1869 = primCdr(_35reg1868);
Obj _35reg1870 = primCdr(_35reg1869);
Obj _35reg1871 = primIsCons(_35reg1870);
if (True == _35reg1871) {
Obj _35reg1872 = primCdr(closureRef(co, 0));
Obj _35reg1873 = primCdr(_35reg1872);
Obj _35reg1874 = primCdr(_35reg1873);
Obj _35reg1875 = primCar(_35reg1874);
Obj z = _35reg1875;
Obj _35reg1876 = primCdr(closureRef(co, 0));
Obj _35reg1877 = primCdr(_35reg1876);
Obj _35reg1878 = primCdr(_35reg1877);
Obj _35reg1879 = primCdr(_35reg1878);
Obj _35reg1880 = primEQ(Nil, _35reg1879);
if (True == _35reg1880) {
Obj _35reg1881 = primCons(z, Nil);
Obj _35reg1882 = primCons(y, _35reg1881);
Obj _35reg1883 = primCons(x, _35reg1882);
pushCont(co, _35clofun2958, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg1883;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2958(struct Cora* co) {
Obj _35val1884 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val1884;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2942(struct Cora* co) {
Obj _35cc1273 = makeNative(_35clofun2943, 0, 1, closureRef(co, 0));
Obj _35reg1835 = primIsCons(closureRef(co, 0));
if (True == _35reg1835) {
Obj _35reg1836 = primCar(closureRef(co, 0));
Obj _35reg1837 = primEQ(intern("do"), _35reg1836);
if (True == _35reg1837) {
Obj _35reg1838 = primCdr(closureRef(co, 0));
Obj _35reg1839 = primIsCons(_35reg1838);
if (True == _35reg1839) {
Obj _35reg1840 = primCdr(closureRef(co, 0));
Obj _35reg1841 = primCar(_35reg1840);
Obj x = _35reg1841;
Obj _35reg1842 = primCdr(closureRef(co, 0));
Obj _35reg1843 = primCdr(_35reg1842);
Obj _35reg1844 = primIsCons(_35reg1843);
if (True == _35reg1844) {
Obj _35reg1845 = primCdr(closureRef(co, 0));
Obj _35reg1846 = primCdr(_35reg1845);
Obj _35reg1847 = primCar(_35reg1846);
Obj y = _35reg1847;
Obj _35reg1848 = primCdr(closureRef(co, 0));
Obj _35reg1849 = primCdr(_35reg1848);
Obj _35reg1850 = primCdr(_35reg1849);
Obj _35reg1851 = primEQ(Nil, _35reg1850);
if (True == _35reg1851) {
Obj _35reg1852 = primCons(y, Nil);
Obj _35reg1853 = primCons(x, _35reg1852);
pushCont(co, _35clofun2957, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg1853;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2957(struct Cora* co) {
Obj _35val1854 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val1854;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2943(struct Cora* co) {
Obj _35cc1274 = makeNative(_35clofun2944, 0, 1, closureRef(co, 0));
Obj _35reg1805 = primIsCons(closureRef(co, 0));
if (True == _35reg1805) {
Obj _35reg1806 = primCar(closureRef(co, 0));
Obj _35reg1807 = primEQ(intern("let"), _35reg1806);
if (True == _35reg1807) {
Obj _35reg1808 = primCdr(closureRef(co, 0));
Obj _35reg1809 = primIsCons(_35reg1808);
if (True == _35reg1809) {
Obj _35reg1810 = primCdr(closureRef(co, 0));
Obj _35reg1811 = primCar(_35reg1810);
Obj a = _35reg1811;
Obj _35reg1812 = primCdr(closureRef(co, 0));
Obj _35reg1813 = primCdr(_35reg1812);
Obj _35reg1814 = primIsCons(_35reg1813);
if (True == _35reg1814) {
Obj _35reg1815 = primCdr(closureRef(co, 0));
Obj _35reg1816 = primCdr(_35reg1815);
Obj _35reg1817 = primCar(_35reg1816);
Obj b = _35reg1817;
Obj _35reg1818 = primCdr(closureRef(co, 0));
Obj _35reg1819 = primCdr(_35reg1818);
Obj _35reg1820 = primCdr(_35reg1819);
Obj _35reg1821 = primIsCons(_35reg1820);
if (True == _35reg1821) {
Obj _35reg1822 = primCdr(closureRef(co, 0));
Obj _35reg1823 = primCdr(_35reg1822);
Obj _35reg1824 = primCdr(_35reg1823);
Obj _35reg1825 = primCar(_35reg1824);
Obj c = _35reg1825;
Obj _35reg1826 = primCdr(closureRef(co, 0));
Obj _35reg1827 = primCdr(_35reg1826);
Obj _35reg1828 = primCdr(_35reg1827);
Obj _35reg1829 = primCdr(_35reg1828);
Obj _35reg1830 = primEQ(Nil, _35reg1829);
if (True == _35reg1830) {
pushCont(co, _35clofun2954, 2, c, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = b;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2954(struct Cora* co) {
Obj _35val1831 = co->args[1];
Obj c = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
pushCont(co, _35clofun2955, 2, a, _35val1831);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = c;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2955(struct Cora* co) {
Obj _35val1832 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj _35val1831 = co->stack[co->base + 1];
Obj _35reg1833 = primCons(a, Nil);
pushCont(co, _35clofun2956, 1, _35val1831);
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val1832;
co->args[2] = _35reg1833;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2956(struct Cora* co) {
Obj _35val1834 = co->args[1];
Obj _35val1831 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = _35val1831;
co->args[2] = _35val1834;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2944(struct Cora* co) {
Obj _35cc1275 = makeNative(_35clofun2945, 0, 1, closureRef(co, 0));
Obj _35reg1795 = primIsCons(closureRef(co, 0));
if (True == _35reg1795) {
Obj _35reg1796 = primCar(closureRef(co, 0));
Obj _35reg1797 = primEQ(intern("%closure"), _35reg1796);
if (True == _35reg1797) {
Obj _35reg1798 = primCdr(closureRef(co, 0));
Obj _35reg1799 = primIsCons(_35reg1798);
if (True == _35reg1799) {
Obj _35reg1800 = primCdr(closureRef(co, 0));
Obj _35reg1801 = primCar(_35reg1800);
Obj lam = _35reg1801;
Obj _35reg1802 = primCdr(closureRef(co, 0));
Obj _35reg1803 = primCdr(_35reg1802);
Obj more = _35reg1803;
Obj _35reg1804 = primCons(lam, more);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = _35reg1804;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1275;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1275;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1275;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2945(struct Cora* co) {
Obj _35cc1276 = makeNative(_35clofun2946, 0, 1, closureRef(co, 0));
Obj _35reg1785 = primIsCons(closureRef(co, 0));
if (True == _35reg1785) {
Obj _35reg1786 = primCar(closureRef(co, 0));
Obj _35reg1787 = primEQ(intern("return"), _35reg1786);
if (True == _35reg1787) {
Obj _35reg1788 = primCdr(closureRef(co, 0));
Obj _35reg1789 = primIsCons(_35reg1788);
if (True == _35reg1789) {
Obj _35reg1790 = primCdr(closureRef(co, 0));
Obj _35reg1791 = primCar(_35reg1790);
Obj x = _35reg1791;
Obj _35reg1792 = primCdr(closureRef(co, 0));
Obj _35reg1793 = primCdr(_35reg1792);
Obj _35reg1794 = primEQ(Nil, _35reg1793);
if (True == _35reg1794) {
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1276;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1276;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1276;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1276;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2946(struct Cora* co) {
Obj _35cc1277 = makeNative(_35clofun2947, 0, 1, closureRef(co, 0));
Obj _35reg1765 = primIsCons(closureRef(co, 0));
if (True == _35reg1765) {
Obj _35reg1766 = primCar(closureRef(co, 0));
Obj _35reg1767 = primEQ(intern("call"), _35reg1766);
if (True == _35reg1767) {
Obj _35reg1768 = primCdr(closureRef(co, 0));
Obj _35reg1769 = primIsCons(_35reg1768);
if (True == _35reg1769) {
Obj _35reg1770 = primCdr(closureRef(co, 0));
Obj _35reg1771 = primCar(_35reg1770);
Obj exp = _35reg1771;
Obj _35reg1772 = primCdr(closureRef(co, 0));
Obj _35reg1773 = primCdr(_35reg1772);
Obj _35reg1774 = primIsCons(_35reg1773);
if (True == _35reg1774) {
Obj _35reg1775 = primCdr(closureRef(co, 0));
Obj _35reg1776 = primCdr(_35reg1775);
Obj _35reg1777 = primCar(_35reg1776);
Obj cont = _35reg1777;
Obj _35reg1778 = primCdr(closureRef(co, 0));
Obj _35reg1779 = primCdr(_35reg1778);
Obj _35reg1780 = primCdr(_35reg1779);
Obj _35reg1781 = primEQ(Nil, _35reg1780);
if (True == _35reg1781) {
Obj _35reg1782 = primCons(cont, Nil);
Obj _35reg1783 = primCons(exp, _35reg1782);
pushCont(co, _35clofun2953, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg1783;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2953(struct Cora* co) {
Obj _35val1784 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val1784;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2947(struct Cora* co) {
Obj _35cc1278 = makeNative(_35clofun2948, 0, 1, closureRef(co, 0));
Obj _35reg1755 = primIsCons(closureRef(co, 0));
if (True == _35reg1755) {
Obj _35reg1756 = primCar(closureRef(co, 0));
Obj _35reg1757 = primEQ(intern("tailcall"), _35reg1756);
if (True == _35reg1757) {
Obj _35reg1758 = primCdr(closureRef(co, 0));
Obj _35reg1759 = primIsCons(_35reg1758);
if (True == _35reg1759) {
Obj _35reg1760 = primCdr(closureRef(co, 0));
Obj _35reg1761 = primCar(_35reg1760);
Obj exp = _35reg1761;
Obj _35reg1762 = primCdr(closureRef(co, 0));
Obj _35reg1763 = primCdr(_35reg1762);
Obj _35reg1764 = primEQ(Nil, _35reg1763);
if (True == _35reg1764) {
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1278;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1278;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1278;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1278;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2948(struct Cora* co) {
Obj _35cc1279 = makeNative(_35clofun2949, 0, 1, closureRef(co, 0));
Obj _35reg1737 = primIsCons(closureRef(co, 0));
if (True == _35reg1737) {
Obj _35reg1738 = primCar(closureRef(co, 0));
Obj _35reg1739 = primEQ(intern("continuation"), _35reg1738);
if (True == _35reg1739) {
Obj _35reg1740 = primCdr(closureRef(co, 0));
Obj _35reg1741 = primIsCons(_35reg1740);
if (True == _35reg1741) {
Obj _35reg1742 = primCdr(closureRef(co, 0));
Obj _35reg1743 = primCar(_35reg1742);
Obj arg = _35reg1743;
Obj _35reg1744 = primCdr(closureRef(co, 0));
Obj _35reg1745 = primCdr(_35reg1744);
Obj _35reg1746 = primIsCons(_35reg1745);
if (True == _35reg1746) {
Obj _35reg1747 = primCdr(closureRef(co, 0));
Obj _35reg1748 = primCdr(_35reg1747);
Obj _35reg1749 = primCar(_35reg1748);
Obj body = _35reg1749;
Obj _35reg1750 = primCdr(closureRef(co, 0));
Obj _35reg1751 = primCdr(_35reg1750);
Obj _35reg1752 = primCdr(_35reg1751);
Obj _35reg1753 = primEQ(Nil, _35reg1752);
if (True == _35reg1753) {
pushCont(co, _35clofun2952, 1, arg);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2952(struct Cora* co) {
Obj _35val1754 = co->args[1];
Obj arg = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val1754;
co->args[2] = arg;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2949(struct Cora* co) {
Obj _35cc1280 = makeNative(_35clofun2950, 0, 0);
Obj _35reg1732 = primIsCons(closureRef(co, 0));
if (True == _35reg1732) {
Obj _35reg1733 = primCar(closureRef(co, 0));
Obj f = _35reg1733;
Obj _35reg1734 = primCdr(closureRef(co, 0));
Obj args = _35reg1734;
Obj _35reg1735 = primCons(f, args);
pushCont(co, _35clofun2951, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg1735;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1280;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2951(struct Cora* co) {
Obj _35val1736 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val1736;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2950(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2931(struct Cora* co) {
Obj _35p1261 = co->args[1];
Obj _35cc1262 = makeNative(_35clofun2932, 0, 1, _35p1261);
Obj _35reg1721 = primIsCons(_35p1261);
if (True == _35reg1721) {
Obj _35reg1722 = primCar(_35p1261);
Obj _35reg1723 = primEQ(intern("%const"), _35reg1722);
if (True == _35reg1723) {
Obj _35reg1724 = primCdr(_35p1261);
Obj _35reg1725 = primIsCons(_35reg1724);
if (True == _35reg1725) {
Obj _35reg1726 = primCdr(_35p1261);
Obj _35reg1727 = primCar(_35reg1726);
Obj x = _35reg1727;
Obj _35reg1728 = primCdr(_35p1261);
Obj _35reg1729 = primCdr(_35reg1728);
Obj _35reg1730 = primEQ(Nil, _35reg1729);
if (True == _35reg1730) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1262;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1262;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1262;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1262;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2932(struct Cora* co) {
Obj _35cc1263 = makeNative(_35clofun2933, 0, 1, closureRef(co, 0));
Obj _35reg1711 = primIsCons(closureRef(co, 0));
if (True == _35reg1711) {
Obj _35reg1712 = primCar(closureRef(co, 0));
Obj _35reg1713 = primEQ(intern("%global"), _35reg1712);
if (True == _35reg1713) {
Obj _35reg1714 = primCdr(closureRef(co, 0));
Obj _35reg1715 = primIsCons(_35reg1714);
if (True == _35reg1715) {
Obj _35reg1716 = primCdr(closureRef(co, 0));
Obj _35reg1717 = primCar(_35reg1716);
Obj x = _35reg1717;
Obj _35reg1718 = primCdr(closureRef(co, 0));
Obj _35reg1719 = primCdr(_35reg1718);
Obj _35reg1720 = primEQ(Nil, _35reg1719);
if (True == _35reg1720) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1263;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1263;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1263;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1263;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2933(struct Cora* co) {
Obj _35cc1264 = makeNative(_35clofun2934, 0, 1, closureRef(co, 0));
Obj _35reg1701 = primIsCons(closureRef(co, 0));
if (True == _35reg1701) {
Obj _35reg1702 = primCar(closureRef(co, 0));
Obj _35reg1703 = primEQ(intern("%builtin"), _35reg1702);
if (True == _35reg1703) {
Obj _35reg1704 = primCdr(closureRef(co, 0));
Obj _35reg1705 = primIsCons(_35reg1704);
if (True == _35reg1705) {
Obj _35reg1706 = primCdr(closureRef(co, 0));
Obj _35reg1707 = primCar(_35reg1706);
Obj op = _35reg1707;
Obj _35reg1708 = primCdr(closureRef(co, 0));
Obj _35reg1709 = primCdr(_35reg1708);
Obj _35reg1710 = primEQ(Nil, _35reg1709);
if (True == _35reg1710) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1264;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1264;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1264;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1264;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2934(struct Cora* co) {
Obj _35cc1265 = makeNative(_35clofun2935, 0, 1, closureRef(co, 0));
Obj _35reg1691 = primIsCons(closureRef(co, 0));
if (True == _35reg1691) {
Obj _35reg1692 = primCar(closureRef(co, 0));
Obj _35reg1693 = primEQ(intern("quote"), _35reg1692);
if (True == _35reg1693) {
Obj _35reg1694 = primCdr(closureRef(co, 0));
Obj _35reg1695 = primIsCons(_35reg1694);
if (True == _35reg1695) {
Obj _35reg1696 = primCdr(closureRef(co, 0));
Obj _35reg1697 = primCar(_35reg1696);
Obj x = _35reg1697;
Obj _35reg1698 = primCdr(closureRef(co, 0));
Obj _35reg1699 = primCdr(_35reg1698);
Obj _35reg1700 = primEQ(Nil, _35reg1699);
if (True == _35reg1700) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1265;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1265;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1265;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1265;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2935(struct Cora* co) {
Obj _35cc1266 = makeNative(_35clofun2936, 0, 1, closureRef(co, 0));
Obj _35reg1681 = primIsCons(closureRef(co, 0));
if (True == _35reg1681) {
Obj _35reg1682 = primCar(closureRef(co, 0));
Obj _35reg1683 = primEQ(intern("%closure-ref"), _35reg1682);
if (True == _35reg1683) {
Obj _35reg1684 = primCdr(closureRef(co, 0));
Obj _35reg1685 = primIsCons(_35reg1684);
if (True == _35reg1685) {
Obj _35reg1686 = primCdr(closureRef(co, 0));
Obj _35reg1687 = primCar(_35reg1686);
Obj __ = _35reg1687;
Obj _35reg1688 = primCdr(closureRef(co, 0));
Obj _35reg1689 = primCdr(_35reg1688);
Obj _35reg1690 = primEQ(Nil, _35reg1689);
if (True == _35reg1690) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1266;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1266;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1266;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1266;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2936(struct Cora* co) {
Obj _35cc1267 = makeNative(_35clofun2937, 0, 0);
Obj x = closureRef(co, 0);
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2937(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2925(struct Cora* co) {
Obj _35p1256 = co->args[1];
Obj _35p1257 = co->args[2];
Obj _35cc1258 = makeNative(_35clofun2926, 0, 2, _35p1256, _35p1257);
Obj _35reg1679 = primEQ(Nil, _35p1256);
if (True == _35reg1679) {
Obj __ = _35p1257;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1258;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2926(struct Cora* co) {
Obj _35cc1259 = makeNative(_35clofun2927, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1675 = primIsCons(closureRef(co, 0));
if (True == _35reg1675) {
Obj _35reg1676 = primCar(closureRef(co, 0));
Obj x = _35reg1676;
Obj _35reg1677 = primCdr(closureRef(co, 0));
Obj y = _35reg1677;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun2930, 3, y, s2, _35cc1259);
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1259;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2930(struct Cora* co) {
Obj _35val1678 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj s2 = co->stack[co->base + 1];
Obj _35cc1259 = co->stack[co->base + 2];
if (True == _35val1678) {
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = y;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1259;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2927(struct Cora* co) {
Obj _35cc1260 = makeNative(_35clofun2928, 0, 0);
Obj _35reg1670 = primIsCons(closureRef(co, 0));
if (True == _35reg1670) {
Obj _35reg1671 = primCar(closureRef(co, 0));
Obj x = _35reg1671;
Obj _35reg1672 = primCdr(closureRef(co, 0));
Obj y = _35reg1672;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun2929, 1, x);
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = y;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1260;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2929(struct Cora* co) {
Obj _35val1673 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg1674 = primCons(x, _35val1673);
co->args[1] = _35reg1674;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2928(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2919(struct Cora* co) {
Obj _35p1251 = co->args[1];
Obj _35p1252 = co->args[2];
Obj _35cc1253 = makeNative(_35clofun2920, 0, 2, _35p1251, _35p1252);
Obj _35reg1668 = primEQ(Nil, _35p1251);
if (True == _35reg1668) {
Obj s2 = _35p1252;
co->args[1] = s2;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1253;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2920(struct Cora* co) {
Obj _35cc1254 = makeNative(_35clofun2921, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1664 = primIsCons(closureRef(co, 0));
if (True == _35reg1664) {
Obj _35reg1665 = primCar(closureRef(co, 0));
Obj x = _35reg1665;
Obj _35reg1666 = primCdr(closureRef(co, 0));
Obj y = _35reg1666;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun2924, 3, y, s2, _35cc1254);
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1254;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2924(struct Cora* co) {
Obj _35val1667 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj s2 = co->stack[co->base + 1];
Obj _35cc1254 = co->stack[co->base + 2];
if (True == _35val1667) {
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = y;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1254;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2921(struct Cora* co) {
Obj _35cc1255 = makeNative(_35clofun2922, 0, 0);
Obj _35reg1659 = primIsCons(closureRef(co, 0));
if (True == _35reg1659) {
Obj _35reg1660 = primCar(closureRef(co, 0));
Obj x = _35reg1660;
Obj _35reg1661 = primCdr(closureRef(co, 0));
Obj y = _35reg1661;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun2923, 1, x);
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = y;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1255;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2923(struct Cora* co) {
Obj _35val1662 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg1663 = primCons(x, _35val1662);
co->args[1] = _35reg1663;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2922(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2889(struct Cora* co) {
Obj _35p1240 = co->args[1];
Obj _35p1241 = co->args[2];
Obj _35cc1242 = makeNative(_35clofun2890, 0, 2, _35p1240, _35p1241);
Obj __ = _35p1240;
Obj x = _35p1241;
pushCont(co, _35clofun2916, 2, x, _35cc1242);
co->args[0] = globalRef(intern("number?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2916(struct Cora* co) {
Obj _35val1644 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1242 = co->stack[co->base + 1];
if (True == _35val1644) {
if (True == True) {
Obj _35reg1645 = primCons(x, Nil);
Obj _35reg1646 = primCons(intern("%const"), _35reg1645);
co->args[1] = _35reg1646;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
Obj _35reg1647 = primIsString(x);
if (True == _35reg1647) {
if (True == True) {
Obj _35reg1648 = primCons(x, Nil);
Obj _35reg1649 = primCons(intern("%const"), _35reg1648);
co->args[1] = _35reg1649;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun2917, 2, x, _35cc1242);
co->args[0] = globalRef(intern("boolean?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun2917(struct Cora* co) {
Obj _35val1650 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1242 = co->stack[co->base + 1];
if (True == _35val1650) {
if (True == True) {
Obj _35reg1651 = primCons(x, Nil);
Obj _35reg1652 = primCons(intern("%const"), _35reg1651);
co->args[1] = _35reg1652;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun2918, 2, x, _35cc1242);
co->args[0] = globalRef(intern("null?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2918(struct Cora* co) {
Obj _35val1653 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1242 = co->stack[co->base + 1];
if (True == _35val1653) {
if (True == True) {
Obj _35reg1654 = primCons(x, Nil);
Obj _35reg1655 = primCons(intern("%const"), _35reg1654);
co->args[1] = _35reg1655;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg1656 = primCons(x, Nil);
Obj _35reg1657 = primCons(intern("%const"), _35reg1656);
co->args[1] = _35reg1657;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun2890(struct Cora* co) {
Obj _35cc1243 = makeNative(_35clofun2891, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj __ = closureRef(co, 0);
Obj _35reg1632 = primIsCons(closureRef(co, 1));
if (True == _35reg1632) {
Obj _35reg1633 = primCar(closureRef(co, 1));
Obj _35reg1634 = primEQ(intern("quote"), _35reg1633);
if (True == _35reg1634) {
Obj _35reg1635 = primCdr(closureRef(co, 1));
Obj _35reg1636 = primIsCons(_35reg1635);
if (True == _35reg1636) {
Obj _35reg1637 = primCdr(closureRef(co, 1));
Obj _35reg1638 = primCar(_35reg1637);
Obj x = _35reg1638;
Obj _35reg1639 = primCdr(closureRef(co, 1));
Obj _35reg1640 = primCdr(_35reg1639);
Obj _35reg1641 = primEQ(Nil, _35reg1640);
if (True == _35reg1641) {
Obj _35reg1642 = primCons(x, Nil);
Obj _35reg1643 = primCons(intern("%const"), _35reg1642);
co->args[1] = _35reg1643;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1243;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1243;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1243;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1243;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2891(struct Cora* co) {
Obj _35cc1244 = makeNative(_35clofun2892, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1628 = primIsSymbol(x);
if (True == _35reg1628) {
pushCont(co, _35clofun2915, 1, x);
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = env;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1244;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2915(struct Cora* co) {
Obj _35val1629 = co->args[1];
Obj x = co->stack[co->base + 0];
if (True == _35val1629) {
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg1630 = primCons(x, Nil);
Obj _35reg1631 = primCons(intern("%global"), _35reg1630);
co->args[1] = _35reg1631;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun2892(struct Cora* co) {
Obj _35cc1245 = makeNative(_35clofun2893, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1606 = primIsCons(closureRef(co, 1));
if (True == _35reg1606) {
Obj _35reg1607 = primCar(closureRef(co, 1));
Obj _35reg1608 = primEQ(intern("lambda"), _35reg1607);
if (True == _35reg1608) {
Obj _35reg1609 = primCdr(closureRef(co, 1));
Obj _35reg1610 = primIsCons(_35reg1609);
if (True == _35reg1610) {
Obj _35reg1611 = primCdr(closureRef(co, 1));
Obj _35reg1612 = primCar(_35reg1611);
Obj args = _35reg1612;
Obj _35reg1613 = primCdr(closureRef(co, 1));
Obj _35reg1614 = primCdr(_35reg1613);
Obj _35reg1615 = primIsCons(_35reg1614);
if (True == _35reg1615) {
Obj _35reg1616 = primCdr(closureRef(co, 1));
Obj _35reg1617 = primCdr(_35reg1616);
Obj _35reg1618 = primCar(_35reg1617);
Obj body = _35reg1618;
Obj _35reg1619 = primCdr(closureRef(co, 1));
Obj _35reg1620 = primCdr(_35reg1619);
Obj _35reg1621 = primCdr(_35reg1620);
Obj _35reg1622 = primEQ(Nil, _35reg1621);
if (True == _35reg1622) {
pushCont(co, _35clofun2913, 2, body, args);
co->args[0] = globalRef(intern("append"));
co->args[1] = args;
co->args[2] = env;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2913(struct Cora* co) {
Obj _35val1623 = co->args[1];
Obj body = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
pushCont(co, _35clofun2914, 1, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = _35val1623;
co->args[2] = body;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2914(struct Cora* co) {
Obj _35val1624 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg1625 = primCons(_35val1624, Nil);
Obj _35reg1626 = primCons(args, _35reg1625);
Obj _35reg1627 = primCons(intern("lambda"), _35reg1626);
co->args[1] = _35reg1627;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2893(struct Cora* co) {
Obj _35cc1246 = makeNative(_35clofun2894, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1599 = primIsCons(closureRef(co, 1));
if (True == _35reg1599) {
Obj _35reg1600 = primCar(closureRef(co, 1));
Obj _35reg1601 = primEQ(intern("if"), _35reg1600);
if (True == _35reg1601) {
Obj _35reg1602 = primCdr(closureRef(co, 1));
Obj args = _35reg1602;
pushCont(co, _35clofun2911, 1, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1246;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1246;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2911(struct Cora* co) {
Obj _35val1603 = co->args[1];
Obj args = co->stack[co->base + 0];
pushCont(co, _35clofun2912, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1603;
co->args[2] = args;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2912(struct Cora* co) {
Obj _35val1604 = co->args[1];
Obj _35reg1605 = primCons(intern("if"), _35val1604);
co->args[1] = _35reg1605;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2894(struct Cora* co) {
Obj _35cc1247 = makeNative(_35clofun2895, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1577 = primIsCons(closureRef(co, 1));
if (True == _35reg1577) {
Obj _35reg1578 = primCar(closureRef(co, 1));
Obj _35reg1579 = primEQ(intern("do"), _35reg1578);
if (True == _35reg1579) {
Obj _35reg1580 = primCdr(closureRef(co, 1));
Obj _35reg1581 = primIsCons(_35reg1580);
if (True == _35reg1581) {
Obj _35reg1582 = primCdr(closureRef(co, 1));
Obj _35reg1583 = primCar(_35reg1582);
Obj x = _35reg1583;
Obj _35reg1584 = primCdr(closureRef(co, 1));
Obj _35reg1585 = primCdr(_35reg1584);
Obj _35reg1586 = primIsCons(_35reg1585);
if (True == _35reg1586) {
Obj _35reg1587 = primCdr(closureRef(co, 1));
Obj _35reg1588 = primCdr(_35reg1587);
Obj _35reg1589 = primCar(_35reg1588);
Obj y = _35reg1589;
Obj _35reg1590 = primCdr(closureRef(co, 1));
Obj _35reg1591 = primCdr(_35reg1590);
Obj _35reg1592 = primCdr(_35reg1591);
Obj _35reg1593 = primEQ(Nil, _35reg1592);
if (True == _35reg1593) {
pushCont(co, _35clofun2909, 2, env, y);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2909(struct Cora* co) {
Obj _35val1594 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
pushCont(co, _35clofun2910, 1, _35val1594);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = y;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2910(struct Cora* co) {
Obj _35val1595 = co->args[1];
Obj _35val1594 = co->stack[co->base + 0];
Obj _35reg1596 = primCons(_35val1595, Nil);
Obj _35reg1597 = primCons(_35val1594, _35reg1596);
Obj _35reg1598 = primCons(intern("do"), _35reg1597);
co->args[1] = _35reg1598;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2895(struct Cora* co) {
Obj _35cc1248 = makeNative(_35clofun2896, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1544 = primIsCons(closureRef(co, 1));
if (True == _35reg1544) {
Obj _35reg1545 = primCar(closureRef(co, 1));
Obj _35reg1546 = primEQ(intern("let"), _35reg1545);
if (True == _35reg1546) {
Obj _35reg1547 = primCdr(closureRef(co, 1));
Obj _35reg1548 = primIsCons(_35reg1547);
if (True == _35reg1548) {
Obj _35reg1549 = primCdr(closureRef(co, 1));
Obj _35reg1550 = primCar(_35reg1549);
Obj a = _35reg1550;
Obj _35reg1551 = primCdr(closureRef(co, 1));
Obj _35reg1552 = primCdr(_35reg1551);
Obj _35reg1553 = primIsCons(_35reg1552);
if (True == _35reg1553) {
Obj _35reg1554 = primCdr(closureRef(co, 1));
Obj _35reg1555 = primCdr(_35reg1554);
Obj _35reg1556 = primCar(_35reg1555);
Obj b = _35reg1556;
Obj _35reg1557 = primCdr(closureRef(co, 1));
Obj _35reg1558 = primCdr(_35reg1557);
Obj _35reg1559 = primCdr(_35reg1558);
Obj _35reg1560 = primIsCons(_35reg1559);
if (True == _35reg1560) {
Obj _35reg1561 = primCdr(closureRef(co, 1));
Obj _35reg1562 = primCdr(_35reg1561);
Obj _35reg1563 = primCdr(_35reg1562);
Obj _35reg1564 = primCar(_35reg1563);
Obj c = _35reg1564;
Obj _35reg1565 = primCdr(closureRef(co, 1));
Obj _35reg1566 = primCdr(_35reg1565);
Obj _35reg1567 = primCdr(_35reg1566);
Obj _35reg1568 = primCdr(_35reg1567);
Obj _35reg1569 = primEQ(Nil, _35reg1568);
if (True == _35reg1569) {
pushCont(co, _35clofun2907, 3, env, c, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = b;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2907(struct Cora* co) {
Obj _35val1570 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj a = co->stack[co->base + 2];
Obj _35reg1571 = primCons(a, env);
pushCont(co, _35clofun2908, 2, _35val1570, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = _35reg1571;
co->args[2] = c;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2908(struct Cora* co) {
Obj _35val1572 = co->args[1];
Obj _35val1570 = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj _35reg1573 = primCons(_35val1572, Nil);
Obj _35reg1574 = primCons(_35val1570, _35reg1573);
Obj _35reg1575 = primCons(a, _35reg1574);
Obj _35reg1576 = primCons(intern("let"), _35reg1575);
co->args[1] = _35reg1576;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2896(struct Cora* co) {
Obj _35cc1249 = makeNative(_35clofun2897, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1524 = primIsCons(closureRef(co, 1));
if (True == _35reg1524) {
Obj _35reg1525 = primCar(closureRef(co, 1));
Obj op = _35reg1525;
Obj _35reg1526 = primCdr(closureRef(co, 1));
Obj args = _35reg1526;
pushCont(co, _35clofun2900, 4, op, args, env, _35cc1249);
co->args[0] = globalRef(intern("builtin?"));
co->args[1] = op;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1249;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2900(struct Cora* co) {
Obj _35val1527 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj _35cc1249 = co->stack[co->base + 3];
if (True == _35val1527) {
pushCont(co, _35clofun2901, 3, op, args, env);
co->args[0] = globalRef(intern("cora/lib/toc/include.builtin->args"));
co->args[1] = op;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1249;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2901(struct Cora* co) {
Obj _35val1528 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj required = _35val1528;
pushCont(co, _35clofun2902, 4, required, op, args, env);
co->args[0] = globalRef(intern("length"));
co->args[1] = args;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2902(struct Cora* co) {
Obj _35val1529 = co->args[1];
Obj required = co->stack[co->base + 0];
Obj op = co->stack[co->base + 1];
Obj args = co->stack[co->base + 2];
Obj env = co->stack[co->base + 3];
Obj provided = _35val1529;
Obj _35reg1530 = primEQ(required, provided);
if (True == _35reg1530) {
Obj _35reg1531 = primCons(op, Nil);
Obj _35reg1532 = primCons(intern("%builtin"), _35reg1531);
pushCont(co, _35clofun2903, 2, args, _35reg1532);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg1536 = primGT(required, provided);
if (True == _35reg1536) {
Obj _35reg1537 = primSub(required, provided);
pushCont(co, _35clofun2905, 3, op, args, env);
co->args[0] = globalRef(intern("cora/lib/toc/include.temp-list"));
co->args[1] = _35reg1537;
co->args[2] = Nil;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("primitive call mismatch");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun2905(struct Cora* co) {
Obj _35val1538 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj tmp = _35val1538;
Obj _35reg1539 = primCons(op, args);
pushCont(co, _35clofun2906, 2, tmp, env);
co->args[0] = globalRef(intern("append"));
co->args[1] = _35reg1539;
co->args[2] = tmp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2906(struct Cora* co) {
Obj _35val1540 = co->args[1];
Obj tmp = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj _35reg1541 = primCons(_35val1540, Nil);
Obj _35reg1542 = primCons(tmp, _35reg1541);
Obj _35reg1543 = primCons(intern("lambda"), _35reg1542);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = _35reg1543;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2903(struct Cora* co) {
Obj _35val1533 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg1532 = co->stack[co->base + 1];
pushCont(co, _35clofun2904, 1, _35reg1532);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1533;
co->args[2] = args;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2904(struct Cora* co) {
Obj _35val1534 = co->args[1];
Obj _35reg1532 = co->stack[co->base + 0];
Obj _35reg1535 = primCons(_35reg1532, _35val1534);
co->args[1] = _35reg1535;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2897(struct Cora* co) {
Obj _35cc1250 = makeNative(_35clofun2898, 0, 0);
Obj env = closureRef(co, 0);
Obj ls = closureRef(co, 1);
pushCont(co, _35clofun2899, 1, ls);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2899(struct Cora* co) {
Obj _35val1523 = co->args[1];
Obj ls = co->stack[co->base + 0];
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1523;
co->args[2] = ls;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2898(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2886(struct Cora* co) {
Obj _35p1236 = co->args[1];
Obj _35p1237 = co->args[2];
Obj _35cc1238 = makeNative(_35clofun2887, 0, 2, _35p1236, _35p1237);
Obj _35reg1521 = primEQ(makeNumber(0), _35p1236);
if (True == _35reg1521) {
Obj res = _35p1237;
co->args[1] = res;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1238;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2887(struct Cora* co) {
Obj _35cc1239 = makeNative(_35clofun2888, 0, 0);
Obj n = closureRef(co, 0);
Obj res = closureRef(co, 1);
Obj _35reg1518 = primSub(n, makeNumber(1));
Obj _35reg1519 = primGenSym(intern("tmp"));
Obj _35reg1520 = primCons(_35reg1519, res);
co->args[0] = globalRef(intern("cora/lib/toc/include.temp-list"));
co->args[1] = _35reg1518;
co->args[2] = _35reg1520;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2888(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2883(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun2884, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2884(struct Cora* co) {
Obj _35val1515 = co->args[1];
Obj find = _35val1515;
pushCont(co, _35clofun2885, 1, find);
co->args[0] = globalRef(intern("null?"));
co->args[1] = find;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2885(struct Cora* co) {
Obj _35val1516 = co->args[1];
Obj find = co->stack[co->base + 0];
if (True == _35val1516) {
co->args[1] = makeString1("ERROR");
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = find;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2880(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun2881, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2881(struct Cora* co) {
Obj _35val1512 = co->args[1];
Obj find = _35val1512;
pushCont(co, _35clofun2882, 1, find);
co->args[0] = globalRef(intern("null?"));
co->args[1] = find;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2882(struct Cora* co) {
Obj _35val1513 = co->args[1];
Obj find = co->stack[co->base + 0];
if (True == _35val1513) {
co->args[1] = makeString1("ERROR");
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = globalRef(intern("caddr"));
co->args[1] = find;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2877(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun2878, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2878(struct Cora* co) {
Obj _35val1508 = co->args[1];
pushCont(co, _35clofun2879, 0);
co->args[0] = globalRef(intern("null?"));
co->args[1] = _35val1508;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2879(struct Cora* co) {
Obj _35val1509 = co->args[1];
Obj _35reg1510 = primNot(_35val1509);
co->args[1] = _35reg1510;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2873(struct Cora* co) {
Obj _35p1232 = co->args[1];
Obj _35p1233 = co->args[2];
Obj _35cc1234 = makeNative(_35clofun2874, 0, 2, _35p1232, _35p1233);
Obj x = _35p1232;
Obj _35reg1437 = primEQ(Nil, _35p1233);
if (True == _35reg1437) {
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1234;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2874(struct Cora* co) {
Obj _35cc1235 = makeNative(_35clofun2875, 0, 0);
Obj x = closureRef(co, 0);
Obj _35reg1432 = primIsCons(closureRef(co, 1));
if (True == _35reg1432) {
Obj _35reg1433 = primCar(closureRef(co, 1));
Obj hd = _35reg1433;
Obj _35reg1434 = primCdr(closureRef(co, 1));
Obj tl = _35reg1434;
pushCont(co, _35clofun2876, 2, x, tl);
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = x;
co->args[2] = hd;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1235;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2876(struct Cora* co) {
Obj _35val1435 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj tl = co->stack[co->base + 1];
Obj _35reg1436 = primLT(_35val1435, makeNumber(0));
if (True == _35reg1436) {
co->args[0] = globalRef(intern("cora/lib/toc/include.exist-in-env"));
co->args[1] = x;
co->args[2] = tl;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun2875(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2872(struct Cora* co) {
Obj x = co->args[1];
Obj l = co->args[2];
co->args[0] = globalRef(intern("cora/lib/toc/include.pos-in-list0"));
co->args[1] = makeNumber(0);
co->args[2] = x;
co->args[3] = l;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2868(struct Cora* co) {
Obj _35p1226 = co->args[1];
Obj _35p1227 = co->args[2];
Obj _35p1228 = co->args[3];
Obj _35cc1229 = makeNative(_35clofun2869, 0, 3, _35p1226, _35p1227, _35p1228);
Obj __ = _35p1226;
Obj x = _35p1227;
Obj _35reg1429 = primEQ(Nil, _35p1228);
if (True == _35reg1429) {
co->args[1] = makeNumber(-1);
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1229;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2869(struct Cora* co) {
Obj _35cc1230 = makeNative(_35clofun2870, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj pos = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1425 = primIsCons(closureRef(co, 2));
if (True == _35reg1425) {
Obj _35reg1426 = primCar(closureRef(co, 2));
Obj a = _35reg1426;
Obj _35reg1427 = primCdr(closureRef(co, 2));
Obj b = _35reg1427;
Obj _35reg1428 = primEQ(x, a);
if (True == _35reg1428) {
co->args[1] = pos;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1230;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1230;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2870(struct Cora* co) {
Obj _35cc1231 = makeNative(_35clofun2871, 0, 0);
Obj pos = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1421 = primIsCons(closureRef(co, 2));
if (True == _35reg1421) {
Obj _35reg1422 = primCar(closureRef(co, 2));
Obj a = _35reg1422;
Obj _35reg1423 = primCdr(closureRef(co, 2));
Obj b = _35reg1423;
Obj _35reg1424 = primAdd(pos, makeNumber(1));
co->args[0] = globalRef(intern("cora/lib/toc/include.pos-in-list0"));
co->args[1] = _35reg1424;
co->args[2] = x;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1231;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2871(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2864(struct Cora* co) {
Obj _35p1221 = co->args[1];
Obj _35p1222 = co->args[2];
Obj _35p1223 = co->args[3];
Obj _35cc1224 = makeNative(_35clofun2865, 0, 3, _35p1221, _35p1222, _35p1223);
Obj f = _35p1221;
Obj acc = _35p1222;
Obj _35reg1419 = primEQ(Nil, _35p1223);
if (True == _35reg1419) {
co->args[1] = acc;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1224;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2865(struct Cora* co) {
Obj _35cc1225 = makeNative(_35clofun2866, 0, 0);
Obj f = closureRef(co, 0);
Obj acc = closureRef(co, 1);
Obj _35reg1415 = primIsCons(closureRef(co, 2));
if (True == _35reg1415) {
Obj _35reg1416 = primCar(closureRef(co, 2));
Obj x = _35reg1416;
Obj _35reg1417 = primCdr(closureRef(co, 2));
Obj y = _35reg1417;
pushCont(co, _35clofun2867, 2, f, y);
co->args[0] = f;
co->args[1] = acc;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1225;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2867(struct Cora* co) {
Obj _35val1418 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = f;
co->args[2] = _35val1418;
co->args[3] = y;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2866(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2860(struct Cora* co) {
Obj _35p1216 = co->args[1];
Obj _35p1217 = co->args[2];
Obj _35cc1218 = makeNative(_35clofun2861, 0, 2, _35p1216, _35p1217);
Obj var = _35p1216;
Obj _35reg1413 = primEQ(Nil, _35p1217);
if (True == _35reg1413) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1218;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2861(struct Cora* co) {
Obj _35cc1219 = makeNative(_35clofun2862, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj var = closureRef(co, 0);
Obj _35reg1403 = primIsCons(closureRef(co, 1));
if (True == _35reg1403) {
Obj _35reg1404 = primCar(closureRef(co, 1));
Obj _35reg1405 = primIsCons(_35reg1404);
if (True == _35reg1405) {
Obj _35reg1406 = primCar(closureRef(co, 1));
Obj _35reg1407 = primCar(_35reg1406);
Obj x = _35reg1407;
Obj _35reg1408 = primCar(closureRef(co, 1));
Obj _35reg1409 = primCdr(_35reg1408);
Obj y = _35reg1409;
Obj _35reg1410 = primCdr(closureRef(co, 1));
Obj __ = _35reg1410;
Obj _35reg1411 = primEQ(var, x);
if (True == _35reg1411) {
Obj _35reg1412 = primCons(x, y);
co->args[1] = _35reg1412;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1219;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1219;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1219;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2862(struct Cora* co) {
Obj _35cc1220 = makeNative(_35clofun2863, 0, 0);
Obj var = closureRef(co, 0);
Obj _35reg1400 = primIsCons(closureRef(co, 1));
if (True == _35reg1400) {
Obj _35reg1401 = primCar(closureRef(co, 1));
Obj __ = _35reg1401;
Obj _35reg1402 = primCdr(closureRef(co, 1));
Obj y = _35reg1402;
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = var;
co->args[2] = y;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1220;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2863(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = co->args[0];
} else {
co->pc = coraCall;
}
return;
}

