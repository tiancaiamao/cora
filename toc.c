#include "src/types.h"
#include "runtime.h"

void entry(struct Cora* co);
void _35clofun3173(struct Cora* co);
void _35clofun3213(struct Cora* co);
void _35clofun3214(struct Cora* co);
void _35clofun3219(struct Cora* co);
void _35clofun3222(struct Cora* co);
void _35clofun3225(struct Cora* co);
void _35clofun3226(struct Cora* co);
void _35clofun3223(struct Cora* co);
void _35clofun3224(struct Cora* co);
void _35clofun3220(struct Cora* co);
void _35clofun3221(struct Cora* co);
void _35clofun3217(struct Cora* co);
void _35clofun3218(struct Cora* co);
void _35clofun3215(struct Cora* co);
void _35clofun3216(struct Cora* co);
void _35clofun3212(struct Cora* co);
void _35clofun3211(struct Cora* co);
void _35clofun3210(struct Cora* co);
void _35clofun3209(struct Cora* co);
void _35clofun3208(struct Cora* co);
void _35clofun3207(struct Cora* co);
void _35clofun3206(struct Cora* co);
void _35clofun3205(struct Cora* co);
void _35clofun3204(struct Cora* co);
void _35clofun3203(struct Cora* co);
void _35clofun3202(struct Cora* co);
void _35clofun3201(struct Cora* co);
void _35clofun3200(struct Cora* co);
void _35clofun3199(struct Cora* co);
void _35clofun3198(struct Cora* co);
void _35clofun3197(struct Cora* co);
void _35clofun3191(struct Cora* co);
void _35clofun3192(struct Cora* co);
void _35clofun3193(struct Cora* co);
void _35clofun3194(struct Cora* co);
void _35clofun3195(struct Cora* co);
void _35clofun3196(struct Cora* co);
void _35clofun3183(struct Cora* co);
void _35clofun3184(struct Cora* co);
void _35clofun3185(struct Cora* co);
void _35clofun3188(struct Cora* co);
void _35clofun3189(struct Cora* co);
void _35clofun3190(struct Cora* co);
void _35clofun3186(struct Cora* co);
void _35clofun3187(struct Cora* co);
void _35clofun3179(struct Cora* co);
void _35clofun3180(struct Cora* co);
void _35clofun3182(struct Cora* co);
void _35clofun3181(struct Cora* co);
void _35clofun3174(struct Cora* co);
void _35clofun3175(struct Cora* co);
void _35clofun3176(struct Cora* co);
void _35clofun3177(struct Cora* co);
void _35clofun3178(struct Cora* co);
void _35clofun3170(struct Cora* co);
void _35clofun3171(struct Cora* co);
void _35clofun3172(struct Cora* co);
void _35clofun3167(struct Cora* co);
void _35clofun3168(struct Cora* co);
void _35clofun3169(struct Cora* co);
void _35clofun3165(struct Cora* co);
void _35clofun3166(struct Cora* co);
void _35clofun3164(struct Cora* co);
void _35clofun3163(struct Cora* co);
void _35clofun3162(struct Cora* co);
void _35clofun3161(struct Cora* co);
void _35clofun3154(struct Cora* co);
void _35clofun3156(struct Cora* co);
void _35clofun3157(struct Cora* co);
void _35clofun3158(struct Cora* co);
void _35clofun3159(struct Cora* co);
void _35clofun3160(struct Cora* co);
void _35clofun3155(struct Cora* co);
void _35clofun3146(struct Cora* co);
void _35clofun3147(struct Cora* co);
void _35clofun3149(struct Cora* co);
void _35clofun3150(struct Cora* co);
void _35clofun3151(struct Cora* co);
void _35clofun3152(struct Cora* co);
void _35clofun3153(struct Cora* co);
void _35clofun3148(struct Cora* co);
void _35clofun3142(struct Cora* co);
void _35clofun3143(struct Cora* co);
void _35clofun3144(struct Cora* co);
void _35clofun3145(struct Cora* co);
void _35clofun3141(struct Cora* co);
void _35clofun3135(struct Cora* co);
void _35clofun3136(struct Cora* co);
void _35clofun3138(struct Cora* co);
void _35clofun3139(struct Cora* co);
void _35clofun3140(struct Cora* co);
void _35clofun3137(struct Cora* co);
void _35clofun3124(struct Cora* co);
void _35clofun3126(struct Cora* co);
void _35clofun3127(struct Cora* co);
void _35clofun3128(struct Cora* co);
void _35clofun3129(struct Cora* co);
void _35clofun3130(struct Cora* co);
void _35clofun3131(struct Cora* co);
void _35clofun3134(struct Cora* co);
void _35clofun3132(struct Cora* co);
void _35clofun3133(struct Cora* co);
void _35clofun3125(struct Cora* co);
void _35clofun3116(struct Cora* co);
void _35clofun3117(struct Cora* co);
void _35clofun3119(struct Cora* co);
void _35clofun3120(struct Cora* co);
void _35clofun3121(struct Cora* co);
void _35clofun3122(struct Cora* co);
void _35clofun3123(struct Cora* co);
void _35clofun3118(struct Cora* co);
void _35clofun3036(struct Cora* co);
void _35clofun3037(struct Cora* co);
void _35clofun3113(struct Cora* co);
void _35clofun3114(struct Cora* co);
void _35clofun3115(struct Cora* co);
void _35clofun3038(struct Cora* co);
void _35clofun3111(struct Cora* co);
void _35clofun3112(struct Cora* co);
void _35clofun3039(struct Cora* co);
void _35clofun3109(struct Cora* co);
void _35clofun3110(struct Cora* co);
void _35clofun3040(struct Cora* co);
void _35clofun3103(struct Cora* co);
void _35clofun3106(struct Cora* co);
void _35clofun3107(struct Cora* co);
void _35clofun3108(struct Cora* co);
void _35clofun3104(struct Cora* co);
void _35clofun3105(struct Cora* co);
void _35clofun3100(struct Cora* co);
void _35clofun3101(struct Cora* co);
void _35clofun3102(struct Cora* co);
void _35clofun3041(struct Cora* co);
void _35clofun3090(struct Cora* co);
void _35clofun3096(struct Cora* co);
void _35clofun3097(struct Cora* co);
void _35clofun3098(struct Cora* co);
void _35clofun3099(struct Cora* co);
void _35clofun3091(struct Cora* co);
void _35clofun3092(struct Cora* co);
void _35clofun3093(struct Cora* co);
void _35clofun3094(struct Cora* co);
void _35clofun3095(struct Cora* co);
void _35clofun3042(struct Cora* co);
void _35clofun3086(struct Cora* co);
void _35clofun3087(struct Cora* co);
void _35clofun3088(struct Cora* co);
void _35clofun3089(struct Cora* co);
void _35clofun3043(struct Cora* co);
void _35clofun3080(struct Cora* co);
void _35clofun3081(struct Cora* co);
void _35clofun3082(struct Cora* co);
void _35clofun3083(struct Cora* co);
void _35clofun3084(struct Cora* co);
void _35clofun3085(struct Cora* co);
void _35clofun3044(struct Cora* co);
void _35clofun3070(struct Cora* co);
void _35clofun3071(struct Cora* co);
void _35clofun3072(struct Cora* co);
void _35clofun3073(struct Cora* co);
void _35clofun3074(struct Cora* co);
void _35clofun3075(struct Cora* co);
void _35clofun3076(struct Cora* co);
void _35clofun3077(struct Cora* co);
void _35clofun3078(struct Cora* co);
void _35clofun3079(struct Cora* co);
void _35clofun3045(struct Cora* co);
void _35clofun3068(struct Cora* co);
void _35clofun3069(struct Cora* co);
void _35clofun3046(struct Cora* co);
void _35clofun3065(struct Cora* co);
void _35clofun3066(struct Cora* co);
void _35clofun3067(struct Cora* co);
void _35clofun3047(struct Cora* co);
void _35clofun3048(struct Cora* co);
void _35clofun3064(struct Cora* co);
void _35clofun3049(struct Cora* co);
void _35clofun3051(struct Cora* co);
void _35clofun3052(struct Cora* co);
void _35clofun3053(struct Cora* co);
void _35clofun3054(struct Cora* co);
void _35clofun3055(struct Cora* co);
void _35clofun3056(struct Cora* co);
void _35clofun3057(struct Cora* co);
void _35clofun3058(struct Cora* co);
void _35clofun3059(struct Cora* co);
void _35clofun3060(struct Cora* co);
void _35clofun3061(struct Cora* co);
void _35clofun3062(struct Cora* co);
void _35clofun3063(struct Cora* co);
void _35clofun3050(struct Cora* co);
void _35clofun3034(struct Cora* co);
void _35clofun3035(struct Cora* co);
void _35clofun3029(struct Cora* co);
void _35clofun3033(struct Cora* co);
void _35clofun3030(struct Cora* co);
void _35clofun3032(struct Cora* co);
void _35clofun3031(struct Cora* co);
void _35clofun3019(struct Cora* co);
void _35clofun3027(struct Cora* co);
void _35clofun3028(struct Cora* co);
void _35clofun3025(struct Cora* co);
void _35clofun3026(struct Cora* co);
void _35clofun3023(struct Cora* co);
void _35clofun3024(struct Cora* co);
void _35clofun3020(struct Cora* co);
void _35clofun3021(struct Cora* co);
void _35clofun3022(struct Cora* co);
void _35clofun3001(struct Cora* co);
void _35clofun3018(struct Cora* co);
void _35clofun3002(struct Cora* co);
void _35clofun3003(struct Cora* co);
void _35clofun3017(struct Cora* co);
void _35clofun3004(struct Cora* co);
void _35clofun3012(struct Cora* co);
void _35clofun3013(struct Cora* co);
void _35clofun3014(struct Cora* co);
void _35clofun3015(struct Cora* co);
void _35clofun3016(struct Cora* co);
void _35clofun3005(struct Cora* co);
void _35clofun3009(struct Cora* co);
void _35clofun3010(struct Cora* co);
void _35clofun3011(struct Cora* co);
void _35clofun3006(struct Cora* co);
void _35clofun3008(struct Cora* co);
void _35clofun3007(struct Cora* co);
void _35clofun2991(struct Cora* co);
void _35clofun2995(struct Cora* co);
void _35clofun2996(struct Cora* co);
void _35clofun3000(struct Cora* co);
void _35clofun2997(struct Cora* co);
void _35clofun2999(struct Cora* co);
void _35clofun2998(struct Cora* co);
void _35clofun2992(struct Cora* co);
void _35clofun2994(struct Cora* co);
void _35clofun2993(struct Cora* co);
void _35clofun2973(struct Cora* co);
void _35clofun2990(struct Cora* co);
void _35clofun2974(struct Cora* co);
void _35clofun2989(struct Cora* co);
void _35clofun2975(struct Cora* co);
void _35clofun2986(struct Cora* co);
void _35clofun2987(struct Cora* co);
void _35clofun2988(struct Cora* co);
void _35clofun2976(struct Cora* co);
void _35clofun2984(struct Cora* co);
void _35clofun2985(struct Cora* co);
void _35clofun2977(struct Cora* co);
void _35clofun2982(struct Cora* co);
void _35clofun2983(struct Cora* co);
void _35clofun2978(struct Cora* co);
void _35clofun2981(struct Cora* co);
void _35clofun2979(struct Cora* co);
void _35clofun2980(struct Cora* co);
void _35clofun2972(struct Cora* co);
void _35clofun2957(struct Cora* co);
void _35clofun2971(struct Cora* co);
void _35clofun2958(struct Cora* co);
void _35clofun2970(struct Cora* co);
void _35clofun2959(struct Cora* co);
void _35clofun2966(struct Cora* co);
void _35clofun2967(struct Cora* co);
void _35clofun2968(struct Cora* co);
void _35clofun2969(struct Cora* co);
void _35clofun2960(struct Cora* co);
void _35clofun2964(struct Cora* co);
void _35clofun2965(struct Cora* co);
void _35clofun2961(struct Cora* co);
void _35clofun2963(struct Cora* co);
void _35clofun2962(struct Cora* co);
void _35clofun2934(struct Cora* co);
void _35clofun2956(struct Cora* co);
void _35clofun2935(struct Cora* co);
void _35clofun2936(struct Cora* co);
void _35clofun2955(struct Cora* co);
void _35clofun2937(struct Cora* co);
void _35clofun2954(struct Cora* co);
void _35clofun2938(struct Cora* co);
void _35clofun2953(struct Cora* co);
void _35clofun2939(struct Cora* co);
void _35clofun2950(struct Cora* co);
void _35clofun2951(struct Cora* co);
void _35clofun2952(struct Cora* co);
void _35clofun2940(struct Cora* co);
void _35clofun2941(struct Cora* co);
void _35clofun2942(struct Cora* co);
void _35clofun2949(struct Cora* co);
void _35clofun2943(struct Cora* co);
void _35clofun2944(struct Cora* co);
void _35clofun2948(struct Cora* co);
void _35clofun2945(struct Cora* co);
void _35clofun2947(struct Cora* co);
void _35clofun2946(struct Cora* co);
void _35clofun2927(struct Cora* co);
void _35clofun2928(struct Cora* co);
void _35clofun2929(struct Cora* co);
void _35clofun2930(struct Cora* co);
void _35clofun2931(struct Cora* co);
void _35clofun2932(struct Cora* co);
void _35clofun2933(struct Cora* co);
void _35clofun2921(struct Cora* co);
void _35clofun2922(struct Cora* co);
void _35clofun2926(struct Cora* co);
void _35clofun2923(struct Cora* co);
void _35clofun2925(struct Cora* co);
void _35clofun2924(struct Cora* co);
void _35clofun2915(struct Cora* co);
void _35clofun2916(struct Cora* co);
void _35clofun2920(struct Cora* co);
void _35clofun2917(struct Cora* co);
void _35clofun2919(struct Cora* co);
void _35clofun2918(struct Cora* co);
void _35clofun2885(struct Cora* co);
void _35clofun2912(struct Cora* co);
void _35clofun2913(struct Cora* co);
void _35clofun2914(struct Cora* co);
void _35clofun2886(struct Cora* co);
void _35clofun2887(struct Cora* co);
void _35clofun2911(struct Cora* co);
void _35clofun2888(struct Cora* co);
void _35clofun2909(struct Cora* co);
void _35clofun2910(struct Cora* co);
void _35clofun2889(struct Cora* co);
void _35clofun2907(struct Cora* co);
void _35clofun2908(struct Cora* co);
void _35clofun2890(struct Cora* co);
void _35clofun2905(struct Cora* co);
void _35clofun2906(struct Cora* co);
void _35clofun2891(struct Cora* co);
void _35clofun2903(struct Cora* co);
void _35clofun2904(struct Cora* co);
void _35clofun2892(struct Cora* co);
void _35clofun2896(struct Cora* co);
void _35clofun2897(struct Cora* co);
void _35clofun2898(struct Cora* co);
void _35clofun2901(struct Cora* co);
void _35clofun2902(struct Cora* co);
void _35clofun2899(struct Cora* co);
void _35clofun2900(struct Cora* co);
void _35clofun2893(struct Cora* co);
void _35clofun2895(struct Cora* co);
void _35clofun2894(struct Cora* co);
void _35clofun2882(struct Cora* co);
void _35clofun2883(struct Cora* co);
void _35clofun2884(struct Cora* co);
void _35clofun2879(struct Cora* co);
void _35clofun2880(struct Cora* co);
void _35clofun2881(struct Cora* co);
void _35clofun2876(struct Cora* co);
void _35clofun2877(struct Cora* co);
void _35clofun2878(struct Cora* co);
void _35clofun2873(struct Cora* co);
void _35clofun2874(struct Cora* co);
void _35clofun2875(struct Cora* co);
void _35clofun2869(struct Cora* co);
void _35clofun2870(struct Cora* co);
void _35clofun2872(struct Cora* co);
void _35clofun2871(struct Cora* co);
void _35clofun2868(struct Cora* co);
void _35clofun2864(struct Cora* co);
void _35clofun2865(struct Cora* co);
void _35clofun2866(struct Cora* co);
void _35clofun2867(struct Cora* co);
void _35clofun2860(struct Cora* co);
void _35clofun2861(struct Cora* co);
void _35clofun2863(struct Cora* co);
void _35clofun2862(struct Cora* co);
void _35clofun2856(struct Cora* co);
void _35clofun2857(struct Cora* co);
void _35clofun2858(struct Cora* co);
void _35clofun2859(struct Cora* co);

void entry(struct Cora* co) {
Obj _35reg1412 = primSet(intern("cora/lib/toc/include.assq"), makeNative(_35clofun2856, 2, 0));
Obj _35reg1418 = primSet(intern("cora/lib/toc/include.foldl"), makeNative(_35clofun2860, 3, 0));
Obj _35reg1428 = primSet(intern("cora/lib/toc/include.pos-in-list0"), makeNative(_35clofun2864, 3, 0));
Obj _35reg1429 = primSet(intern("cora/lib/toc/include.index"), makeNative(_35clofun2868, 2, 0));
Obj _35reg1436 = primSet(intern("cora/lib/toc/include.exist-in-env"), makeNative(_35clofun2869, 2, 0));
Obj _35reg1437 = primCons(intern("primSet"), Nil);
Obj _35reg1438 = primCons(makeNumber(2), _35reg1437);
Obj _35reg1439 = primCons(intern("set"), _35reg1438);
Obj _35reg1440 = primCons(intern("primCar"), Nil);
Obj _35reg1441 = primCons(makeNumber(1), _35reg1440);
Obj _35reg1442 = primCons(intern("car"), _35reg1441);
Obj _35reg1443 = primCons(intern("primCdr"), Nil);
Obj _35reg1444 = primCons(makeNumber(1), _35reg1443);
Obj _35reg1445 = primCons(intern("cdr"), _35reg1444);
Obj _35reg1446 = primCons(intern("primCons"), Nil);
Obj _35reg1447 = primCons(makeNumber(2), _35reg1446);
Obj _35reg1448 = primCons(intern("cons"), _35reg1447);
Obj _35reg1449 = primCons(intern("primIsCons"), Nil);
Obj _35reg1450 = primCons(makeNumber(1), _35reg1449);
Obj _35reg1451 = primCons(intern("cons?"), _35reg1450);
Obj _35reg1452 = primCons(intern("primAdd"), Nil);
Obj _35reg1453 = primCons(makeNumber(2), _35reg1452);
Obj _35reg1454 = primCons(intern("+"), _35reg1453);
Obj _35reg1455 = primCons(intern("primSub"), Nil);
Obj _35reg1456 = primCons(makeNumber(2), _35reg1455);
Obj _35reg1457 = primCons(intern("-"), _35reg1456);
Obj _35reg1458 = primCons(intern("primMul"), Nil);
Obj _35reg1459 = primCons(makeNumber(2), _35reg1458);
Obj _35reg1460 = primCons(intern("*"), _35reg1459);
Obj _35reg1461 = primCons(intern("primDiv"), Nil);
Obj _35reg1462 = primCons(makeNumber(2), _35reg1461);
Obj _35reg1463 = primCons(intern("/"), _35reg1462);
Obj _35reg1464 = primCons(intern("primEQ"), Nil);
Obj _35reg1465 = primCons(makeNumber(2), _35reg1464);
Obj _35reg1466 = primCons(intern("="), _35reg1465);
Obj _35reg1467 = primCons(intern("primGT"), Nil);
Obj _35reg1468 = primCons(makeNumber(2), _35reg1467);
Obj _35reg1469 = primCons(intern(">"), _35reg1468);
Obj _35reg1470 = primCons(intern("primLT"), Nil);
Obj _35reg1471 = primCons(makeNumber(2), _35reg1470);
Obj _35reg1472 = primCons(intern("<"), _35reg1471);
Obj _35reg1473 = primCons(intern("primGenSym"), Nil);
Obj _35reg1474 = primCons(makeNumber(1), _35reg1473);
Obj _35reg1475 = primCons(intern("gensym"), _35reg1474);
Obj _35reg1476 = primCons(intern("primIsSymbol"), Nil);
Obj _35reg1477 = primCons(makeNumber(1), _35reg1476);
Obj _35reg1478 = primCons(intern("symbol?"), _35reg1477);
Obj _35reg1479 = primCons(intern("primNot"), Nil);
Obj _35reg1480 = primCons(makeNumber(1), _35reg1479);
Obj _35reg1481 = primCons(intern("not"), _35reg1480);
Obj _35reg1482 = primCons(intern("primIsNumber"), Nil);
Obj _35reg1483 = primCons(makeNumber(1), _35reg1482);
Obj _35reg1484 = primCons(intern("integer?"), _35reg1483);
Obj _35reg1485 = primCons(intern("primIsString"), Nil);
Obj _35reg1486 = primCons(makeNumber(1), _35reg1485);
Obj _35reg1487 = primCons(intern("string?"), _35reg1486);
Obj _35reg1488 = primCons(_35reg1487, Nil);
Obj _35reg1489 = primCons(_35reg1484, _35reg1488);
Obj _35reg1490 = primCons(_35reg1481, _35reg1489);
Obj _35reg1491 = primCons(_35reg1478, _35reg1490);
Obj _35reg1492 = primCons(_35reg1475, _35reg1491);
Obj _35reg1493 = primCons(_35reg1472, _35reg1492);
Obj _35reg1494 = primCons(_35reg1469, _35reg1493);
Obj _35reg1495 = primCons(_35reg1466, _35reg1494);
Obj _35reg1496 = primCons(_35reg1463, _35reg1495);
Obj _35reg1497 = primCons(_35reg1460, _35reg1496);
Obj _35reg1498 = primCons(_35reg1457, _35reg1497);
Obj _35reg1499 = primCons(_35reg1454, _35reg1498);
Obj _35reg1500 = primCons(_35reg1451, _35reg1499);
Obj _35reg1501 = primCons(_35reg1448, _35reg1500);
Obj _35reg1502 = primCons(_35reg1445, _35reg1501);
Obj _35reg1503 = primCons(_35reg1442, _35reg1502);
Obj _35reg1504 = primCons(_35reg1439, _35reg1503);
Obj _35reg1505 = primSet(intern("cora/lib/toc/include.*builtin-prims*"), _35reg1504);
Obj _35reg1509 = primSet(intern("builtin?"), makeNative(_35clofun2873, 1, 0));
Obj _35reg1512 = primSet(intern("cora/lib/toc/include.builtin->name"), makeNative(_35clofun2876, 1, 0));
Obj _35reg1515 = primSet(intern("cora/lib/toc/include.builtin->args"), makeNative(_35clofun2879, 1, 0));
Obj _35reg1520 = primSet(intern("cora/lib/toc/include.temp-list"), makeNative(_35clofun2882, 2, 0));
Obj _35reg1656 = primSet(intern("cora/lib/toc/include.parse"), makeNative(_35clofun2885, 2, 0));
Obj _35reg1667 = primSet(intern("cora/lib/toc/include.union"), makeNative(_35clofun2915, 2, 0));
Obj _35reg1678 = primSet(intern("cora/lib/toc/include.diff"), makeNative(_35clofun2921, 2, 0));
Obj _35reg1729 = primSet(intern("cora/lib/toc/include.convert-protect?"), makeNative(_35clofun2927, 1, 0));
Obj _35reg1904 = primSet(intern("cora/lib/toc/include.free-vars"), makeNative(_35clofun2934, 1, 0));
Obj _35reg1977 = primSet(intern("cora/lib/toc/include.closure-convert"), makeNative(_35clofun2957, 2, 0));
Obj _35reg1980 = primSet(intern("cora/lib/toc/include.id"), makeNative(_35clofun2972, 1, 0));
Obj _35reg2117 = primSet(intern("cora/lib/toc/include.tailify"), makeNative(_35clofun2973, 2, 0));
Obj _35reg2164 = primSet(intern("cora/lib/toc/include.tailify-list"), makeNative(_35clofun2991, 3, 0));
Obj _35reg2243 = primSet(intern("cora/lib/toc/include.explicit-stack"), makeNative(_35clofun3001, 2, 0));
Obj _35reg2350 = primSet(intern("cora/lib/toc/include.collect-lambda"), makeNative(_35clofun3019, 3, 0));
Obj _35reg2357 = primSet(intern("cora/lib/toc/include.collect-lambda-list"), makeNative(_35clofun3029, 4, 0));
Obj _35reg2364 = primSet(intern("cora/lib/toc/include.wrap-var"), makeNative(_35clofun3034, 2, 0));
Obj _35reg2624 = primSet(intern("cora/lib/toc/include.generate-inst"), makeNative(_35clofun3036, 3, 0));
Obj _35reg2635 = primSet(intern("cora/lib/toc/include.generate-call-args"), makeNative(_35clofun3116, 4, 0));
Obj _35reg2654 = primSet(intern("cora/lib/toc/include.generate-cont"), makeNative(_35clofun3124, 2, 0));
Obj _35reg2663 = primSet(intern("cora/lib/toc/include.generate-inst-list-h"), makeNative(_35clofun3135, 4, 0));
Obj _35reg2664 = primSet(intern("cora/lib/toc/include.generate-inst-list"), makeNative(_35clofun3141, 3, 0));
Obj _35reg2668 = primSet(intern("cora/lib/toc/include.code-gen-func-declare"), makeNative(_35clofun3142, 2, 0));
Obj _35reg2679 = primSet(intern("cora/lib/toc/include.generate-call-args-reverse"), makeNative(_35clofun3146, 5, 0));
Obj _35reg2736 = primSet(intern("cora/lib/toc/include.code-gen-toplevel"), makeNative(_35clofun3154, 2, 0));
Obj _35reg2737 = primSet(intern("cora/lib/toc/include.parse-pass"), makeNative(_35clofun3161, 1, 0));
Obj _35reg2738 = primSet(intern("cora/lib/toc/include.closure-convert-pass"), makeNative(_35clofun3162, 1, 0));
Obj _35reg2739 = primSet(intern("cora/lib/toc/include.tailify-pass"), makeNative(_35clofun3163, 1, 0));
Obj _35reg2740 = primSet(intern("cora/lib/toc/include.explicit-stack-pass"), makeNative(_35clofun3164, 1, 0));
Obj _35reg2748 = primSet(intern("cora/lib/toc/include.collect-lambda-pass"), makeNative(_35clofun3165, 1, 0));
Obj _35reg2755 = primSet(intern("cora/lib/toc/include.rewrite-->macro"), makeNative(_35clofun3167, 2, 0));
pushCont(co, _35clofun3173, 0);
co->args[0] = globalRef(intern("cora/init.add-to-*macros*"));
co->args[1] = intern("->");
co->args[2] = makeNative(_35clofun3170, 1, 0);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3173(struct Cora* co) {
Obj _35val2758 = co->args[1];
Obj _35reg2763 = primSet(intern("cora/lib/toc/include.compile"), makeNative(_35clofun3174, 1, 0));
Obj _35reg2769 = primSet(intern("for-each"), makeNative(_35clofun3179, 2, 0));
Obj _35reg2776 = primSet(intern("cora/lib/toc/include.generate-c"), makeNative(_35clofun3183, 2, 0));
Obj _35reg2782 = primSet(intern("cora/lib/toc/include.compile-to-c"), makeNative(_35clofun3191, 3, 0));
Obj _35reg2784 = primSet(intern("set"), makeNative(_35clofun3197, 2, 0));
Obj _35reg2786 = primSet(intern("car"), makeNative(_35clofun3198, 1, 0));
Obj _35reg2788 = primSet(intern("cdr"), makeNative(_35clofun3199, 1, 0));
Obj _35reg2790 = primSet(intern("cons"), makeNative(_35clofun3200, 2, 0));
Obj _35reg2792 = primSet(intern("cons"), makeNative(_35clofun3201, 2, 0));
Obj _35reg2794 = primSet(intern("+"), makeNative(_35clofun3202, 2, 0));
Obj _35reg2796 = primSet(intern("-"), makeNative(_35clofun3203, 2, 0));
Obj _35reg2798 = primSet(intern("*"), makeNative(_35clofun3204, 2, 0));
Obj _35reg2800 = primSet(intern("/"), makeNative(_35clofun3205, 2, 0));
Obj _35reg2802 = primSet(intern("="), makeNative(_35clofun3206, 2, 0));
Obj _35reg2804 = primSet(intern(">"), makeNative(_35clofun3207, 2, 0));
Obj _35reg2806 = primSet(intern("<"), makeNative(_35clofun3208, 2, 0));
Obj _35reg2808 = primSet(intern("gensym"), makeNative(_35clofun3209, 1, 0));
Obj _35reg2810 = primSet(intern("symbol?"), makeNative(_35clofun3210, 1, 0));
Obj _35reg2812 = primSet(intern("not"), makeNative(_35clofun3211, 1, 0));
Obj _35reg2814 = primSet(intern("string?"), makeNative(_35clofun3212, 1, 0));
Obj _35reg2855 = primSet(intern("cora/lib/toc/include.eval0"), makeNative(_35clofun3213, 1, 0));
co->args[1] = _35reg2855;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3213(struct Cora* co) {
Obj exp = co->args[1];
Obj _35reg2815 = primIsSymbol(exp);
if (True == _35reg2815) {
co->args[0] = globalRef(intern("value"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun3214, 1, exp);
co->args[0] = globalRef(intern("number?"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3214(struct Cora* co) {
Obj _35val2816 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val2816) {
if (True == True) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2817 = primIsCons(exp);
if (True == _35reg2817) {
Obj _35reg2818 = primCar(exp);
Obj _35reg2819 = primEQ(_35reg2818, intern("quote"));
if (True == _35reg2819) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2820 = primCar(exp);
pushCont(co, _35clofun3215, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2820;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
} else {
Obj _35reg2824 = primIsString(exp);
if (True == _35reg2824) {
if (True == True) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2825 = primIsCons(exp);
if (True == _35reg2825) {
Obj _35reg2826 = primCar(exp);
Obj _35reg2827 = primEQ(_35reg2826, intern("quote"));
if (True == _35reg2827) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2828 = primCar(exp);
pushCont(co, _35clofun3217, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2828;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
} else {
pushCont(co, _35clofun3219, 1, exp);
co->args[0] = globalRef(intern("boolean?"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun3219(struct Cora* co) {
Obj _35val2832 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val2832) {
if (True == True) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2833 = primIsCons(exp);
if (True == _35reg2833) {
Obj _35reg2834 = primCar(exp);
Obj _35reg2835 = primEQ(_35reg2834, intern("quote"));
if (True == _35reg2835) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2836 = primCar(exp);
pushCont(co, _35clofun3220, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2836;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
} else {
pushCont(co, _35clofun3222, 1, exp);
co->args[0] = globalRef(intern("null?"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3222(struct Cora* co) {
Obj _35val2840 = co->args[1];
Obj exp = co->stack[co->base + 0];
if (True == _35val2840) {
if (True == True) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2841 = primIsCons(exp);
if (True == _35reg2841) {
Obj _35reg2842 = primCar(exp);
Obj _35reg2843 = primEQ(_35reg2842, intern("quote"));
if (True == _35reg2843) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2844 = primCar(exp);
pushCont(co, _35clofun3223, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2844;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
co->args[1] = exp;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2848 = primIsCons(exp);
if (True == _35reg2848) {
Obj _35reg2849 = primCar(exp);
Obj _35reg2850 = primEQ(_35reg2849, intern("quote"));
if (True == _35reg2850) {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2851 = primCar(exp);
pushCont(co, _35clofun3225, 1, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[1] = _35reg2851;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun3225(struct Cora* co) {
Obj _35val2852 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2853 = primCdr(exp);
pushCont(co, _35clofun3226, 1, _35val2852);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2853;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3226(struct Cora* co) {
Obj _35val2854 = co->args[1];
Obj _35val2852 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2852;
co->args[2] = _35val2854;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3223(struct Cora* co) {
Obj _35val2845 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2846 = primCdr(exp);
pushCont(co, _35clofun3224, 1, _35val2845);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2846;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3224(struct Cora* co) {
Obj _35val2847 = co->args[1];
Obj _35val2845 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2845;
co->args[2] = _35val2847;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3220(struct Cora* co) {
Obj _35val2837 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2838 = primCdr(exp);
pushCont(co, _35clofun3221, 1, _35val2837);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2838;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3221(struct Cora* co) {
Obj _35val2839 = co->args[1];
Obj _35val2837 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2837;
co->args[2] = _35val2839;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3217(struct Cora* co) {
Obj _35val2829 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2830 = primCdr(exp);
pushCont(co, _35clofun3218, 1, _35val2829);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2830;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3218(struct Cora* co) {
Obj _35val2831 = co->args[1];
Obj _35val2829 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2829;
co->args[2] = _35val2831;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3215(struct Cora* co) {
Obj _35val2821 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj _35reg2822 = primCdr(exp);
pushCont(co, _35clofun3216, 1, _35val2821);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.eval0"));
co->args[2] = _35reg2822;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3216(struct Cora* co) {
Obj _35val2823 = co->args[1];
Obj _35val2821 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("apply"));
co->args[1] = _35val2821;
co->args[2] = _35val2823;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3212(struct Cora* co) {
Obj _35tmp1397 = co->args[1];
Obj _35reg2813 = primIsString(_35tmp1397);
co->args[1] = _35reg2813;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3211(struct Cora* co) {
Obj _35tmp1396 = co->args[1];
Obj _35reg2811 = primNot(_35tmp1396);
co->args[1] = _35reg2811;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3210(struct Cora* co) {
Obj _35tmp1395 = co->args[1];
Obj _35reg2809 = primIsSymbol(_35tmp1395);
co->args[1] = _35reg2809;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3209(struct Cora* co) {
Obj _35tmp1394 = co->args[1];
Obj _35reg2807 = primGenSym(_35tmp1394);
co->args[1] = _35reg2807;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3208(struct Cora* co) {
Obj _35tmp1393 = co->args[1];
Obj _35tmp1392 = co->args[2];
Obj _35reg2805 = primLT(_35tmp1393, _35tmp1392);
co->args[1] = _35reg2805;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3207(struct Cora* co) {
Obj _35tmp1391 = co->args[1];
Obj _35tmp1390 = co->args[2];
Obj _35reg2803 = primGT(_35tmp1391, _35tmp1390);
co->args[1] = _35reg2803;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3206(struct Cora* co) {
Obj _35tmp1389 = co->args[1];
Obj _35tmp1388 = co->args[2];
Obj _35reg2801 = primEQ(_35tmp1389, _35tmp1388);
co->args[1] = _35reg2801;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3205(struct Cora* co) {
Obj _35tmp1387 = co->args[1];
Obj _35tmp1386 = co->args[2];
Obj _35reg2799 = primDiv(_35tmp1387, _35tmp1386);
co->args[1] = _35reg2799;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3204(struct Cora* co) {
Obj _35tmp1385 = co->args[1];
Obj _35tmp1384 = co->args[2];
Obj _35reg2797 = primMul(_35tmp1385, _35tmp1384);
co->args[1] = _35reg2797;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3203(struct Cora* co) {
Obj _35tmp1383 = co->args[1];
Obj _35tmp1382 = co->args[2];
Obj _35reg2795 = primSub(_35tmp1383, _35tmp1382);
co->args[1] = _35reg2795;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3202(struct Cora* co) {
Obj _35tmp1381 = co->args[1];
Obj _35tmp1380 = co->args[2];
Obj _35reg2793 = primAdd(_35tmp1381, _35tmp1380);
co->args[1] = _35reg2793;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3201(struct Cora* co) {
Obj _35tmp1379 = co->args[1];
Obj _35tmp1378 = co->args[2];
Obj _35reg2791 = primCons(_35tmp1379, _35tmp1378);
co->args[1] = _35reg2791;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3200(struct Cora* co) {
Obj _35tmp1377 = co->args[1];
Obj _35tmp1376 = co->args[2];
Obj _35reg2789 = primCons(_35tmp1377, _35tmp1376);
co->args[1] = _35reg2789;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3199(struct Cora* co) {
Obj _35tmp1375 = co->args[1];
Obj _35reg2787 = primCdr(_35tmp1375);
co->args[1] = _35reg2787;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3198(struct Cora* co) {
Obj _35tmp1374 = co->args[1];
Obj _35reg2785 = primCar(_35tmp1374);
co->args[1] = _35reg2785;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3197(struct Cora* co) {
Obj _35tmp1373 = co->args[1];
Obj _35tmp1372 = co->args[2];
Obj _35reg2783 = primSet(_35tmp1373, _35tmp1372);
co->args[1] = _35reg2783;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3191(struct Cora* co) {
Obj from = co->args[1];
Obj to = co->args[2];
Obj pkg_45str = co->args[3];
pushCont(co, _35clofun3192, 1, to);
co->args[0] = globalRef(intern("read-file-as-sexp"));
co->args[1] = from;
co->args[2] = pkg_45str;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3192(struct Cora* co) {
Obj _35val2777 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj sexp = _35val2777;
pushCont(co, _35clofun3193, 1, to);
co->args[0] = globalRef(intern("macroexpand"));
co->args[1] = sexp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3193(struct Cora* co) {
Obj _35val2778 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj input = _35val2778;
pushCont(co, _35clofun3194, 1, to);
co->args[0] = globalRef(intern("cora/lib/toc/include.compile"));
co->args[1] = input;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3194(struct Cora* co) {
Obj _35val2779 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = _35val2779;
pushCont(co, _35clofun3195, 1, bc);
co->args[0] = globalRef(intern("io.open-output-file"));
co->args[1] = to;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3195(struct Cora* co) {
Obj _35val2780 = co->args[1];
Obj bc = co->stack[co->base + 0];
Obj stream = _35val2780;
pushCont(co, _35clofun3196, 1, stream);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-c"));
co->args[1] = stream;
co->args[2] = bc;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3196(struct Cora* co) {
Obj _35val2781 = co->args[1];
Obj stream = co->stack[co->base + 0];
co->args[0] = globalRef(intern("io.close-output-file"));
co->args[1] = stream;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3183(struct Cora* co) {
Obj to = co->args[1];
Obj bc = co->args[2];
pushCont(co, _35clofun3184, 2, to, bc);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("#include \"types.h\"\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3184(struct Cora* co) {
Obj _35val2770 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3185, 2, to, bc);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("#include \"runtime.h\"\n\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3185(struct Cora* co) {
Obj _35val2771 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3188, 2, to, bc);
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3186, 1, 1, to);
co->args[2] = bc;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3188(struct Cora* co) {
Obj _35val2774 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
pushCont(co, _35clofun3189, 2, to, bc);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = to;
co->args[2] = makeString1("\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3189(struct Cora* co) {
Obj _35val2775 = co->args[1];
Obj to = co->stack[co->base + 0];
Obj bc = co->stack[co->base + 1];
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3190, 1, 1, to);
co->args[2] = bc;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3190(struct Cora* co) {
Obj x = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-toplevel"));
co->args[1] = closureRef(co, 0);
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3186(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg2772 = primCar(x);
pushCont(co, _35clofun3187, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-func-declare"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg2772;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3187(struct Cora* co) {
Obj _35val2773 = co->args[1];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = closureRef(co, 0);
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3179(struct Cora* co) {
Obj _35p1368 = co->args[1];
Obj _35p1369 = co->args[2];
Obj _35cc1370 = makeNative(_35clofun3180, 0, 2, _35p1368, _35p1369);
Obj fn = _35p1368;
Obj _35reg2768 = primEQ(Nil, _35p1369);
if (True == _35reg2768) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1370;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3180(struct Cora* co) {
Obj _35cc1371 = makeNative(_35clofun3181, 0, 0);
Obj fn = closureRef(co, 0);
Obj _35reg2764 = primIsCons(closureRef(co, 1));
if (True == _35reg2764) {
Obj _35reg2765 = primCar(closureRef(co, 1));
Obj x = _35reg2765;
Obj _35reg2766 = primCdr(closureRef(co, 1));
Obj y = _35reg2766;
pushCont(co, _35clofun3182, 2, fn, y);
co->args[0] = fn;
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1371;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3182(struct Cora* co) {
Obj _35val2767 = co->args[1];
Obj fn = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
co->args[0] = globalRef(intern("for-each"));
co->args[1] = fn;
co->args[2] = y;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3181(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3174(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun3175, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse-pass"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3175(struct Cora* co) {
Obj _35val2759 = co->args[1];
pushCont(co, _35clofun3176, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert-pass"));
co->args[1] = _35val2759;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3176(struct Cora* co) {
Obj _35val2760 = co->args[1];
pushCont(co, _35clofun3177, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-pass"));
co->args[1] = _35val2760;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3177(struct Cora* co) {
Obj _35val2761 = co->args[1];
pushCont(co, _35clofun3178, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack-pass"));
co->args[1] = _35val2761;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3178(struct Cora* co) {
Obj _35val2762 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-pass"));
co->args[1] = _35val2762;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3170(struct Cora* co) {
Obj exp = co->args[1];
pushCont(co, _35clofun3171, 1, exp);
co->args[0] = globalRef(intern("cadr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3171(struct Cora* co) {
Obj _35val2756 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj obj = _35val2756;
pushCont(co, _35clofun3172, 1, obj);
co->args[0] = globalRef(intern("cddr"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3172(struct Cora* co) {
Obj _35val2757 = co->args[1];
Obj obj = co->stack[co->base + 0];
Obj fns = _35val2757;
co->args[0] = globalRef(intern("cora/lib/toc/include.rewrite-->macro"));
co->args[1] = obj;
co->args[2] = fns;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3167(struct Cora* co) {
Obj _35p1364 = co->args[1];
Obj _35p1365 = co->args[2];
Obj _35cc1366 = makeNative(_35clofun3168, 0, 2, _35p1364, _35p1365);
Obj obj = _35p1364;
Obj _35reg2754 = primEQ(Nil, _35p1365);
if (True == _35reg2754) {
co->args[1] = obj;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1366;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3168(struct Cora* co) {
Obj _35cc1367 = makeNative(_35clofun3169, 0, 0);
Obj obj = closureRef(co, 0);
Obj _35reg2749 = primIsCons(closureRef(co, 1));
if (True == _35reg2749) {
Obj _35reg2750 = primCar(closureRef(co, 1));
Obj hd = _35reg2750;
Obj _35reg2751 = primCdr(closureRef(co, 1));
Obj more = _35reg2751;
Obj _35reg2752 = primCons(obj, Nil);
Obj _35reg2753 = primCons(hd, _35reg2752);
co->args[0] = globalRef(intern("cora/lib/toc/include.rewrite-->macro"));
co->args[1] = _35reg2753;
co->args[2] = more;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1367;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3169(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3165(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = Nil;
co->args[2] = exp;
co->args[3] = makeNative(_35clofun3166, 2, 0);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3166(struct Cora* co) {
Obj ls = co->args[1];
Obj e1 = co->args[2];
Obj _35reg2741 = primCons(e1, Nil);
Obj _35reg2742 = primCons(Nil, _35reg2741);
Obj _35reg2743 = primCons(Nil, _35reg2742);
Obj _35reg2744 = primCons(intern("lambda"), _35reg2743);
Obj _35reg2745 = primCons(_35reg2744, Nil);
Obj _35reg2746 = primCons(intern("entry"), _35reg2745);
Obj _35reg2747 = primCons(_35reg2746, ls);
co->args[1] = _35reg2747;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3164(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = Nil;
co->args[2] = exp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3163(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = exp;
co->args[2] = globalRef(intern("cora/lib/toc/include.id"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3162(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = Nil;
co->args[2] = exp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3161(struct Cora* co) {
Obj exp = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = Nil;
co->args[2] = exp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3154(struct Cora* co) {
Obj _35p1361 = co->args[1];
Obj _35p1362 = co->args[2];
Obj _35cc1363 = makeNative(_35clofun3155, 0, 0);
Obj w = _35p1361;
Obj _35reg2680 = primIsCons(_35p1362);
if (True == _35reg2680) {
Obj _35reg2681 = primCar(_35p1362);
Obj name = _35reg2681;
Obj _35reg2682 = primCdr(_35p1362);
Obj _35reg2683 = primIsCons(_35reg2682);
if (True == _35reg2683) {
Obj _35reg2684 = primCdr(_35p1362);
Obj _35reg2685 = primCar(_35reg2684);
Obj _35reg2686 = primIsCons(_35reg2685);
if (True == _35reg2686) {
Obj _35reg2687 = primCdr(_35p1362);
Obj _35reg2688 = primCar(_35reg2687);
Obj _35reg2689 = primCar(_35reg2688);
Obj _35reg2690 = primEQ(intern("lambda"), _35reg2689);
if (True == _35reg2690) {
Obj _35reg2691 = primCdr(_35p1362);
Obj _35reg2692 = primCar(_35reg2691);
Obj _35reg2693 = primCdr(_35reg2692);
Obj _35reg2694 = primIsCons(_35reg2693);
if (True == _35reg2694) {
Obj _35reg2695 = primCdr(_35p1362);
Obj _35reg2696 = primCar(_35reg2695);
Obj _35reg2697 = primCdr(_35reg2696);
Obj _35reg2698 = primCar(_35reg2697);
Obj params = _35reg2698;
Obj _35reg2699 = primCdr(_35p1362);
Obj _35reg2700 = primCar(_35reg2699);
Obj _35reg2701 = primCdr(_35reg2700);
Obj _35reg2702 = primCdr(_35reg2701);
Obj _35reg2703 = primIsCons(_35reg2702);
if (True == _35reg2703) {
Obj _35reg2704 = primCdr(_35p1362);
Obj _35reg2705 = primCar(_35reg2704);
Obj _35reg2706 = primCdr(_35reg2705);
Obj _35reg2707 = primCdr(_35reg2706);
Obj _35reg2708 = primCar(_35reg2707);
Obj actives = _35reg2708;
Obj _35reg2709 = primCdr(_35p1362);
Obj _35reg2710 = primCar(_35reg2709);
Obj _35reg2711 = primCdr(_35reg2710);
Obj _35reg2712 = primCdr(_35reg2711);
Obj _35reg2713 = primCdr(_35reg2712);
Obj _35reg2714 = primIsCons(_35reg2713);
if (True == _35reg2714) {
Obj _35reg2715 = primCdr(_35p1362);
Obj _35reg2716 = primCar(_35reg2715);
Obj _35reg2717 = primCdr(_35reg2716);
Obj _35reg2718 = primCdr(_35reg2717);
Obj _35reg2719 = primCdr(_35reg2718);
Obj _35reg2720 = primCar(_35reg2719);
Obj body = _35reg2720;
Obj _35reg2721 = primCdr(_35p1362);
Obj _35reg2722 = primCar(_35reg2721);
Obj _35reg2723 = primCdr(_35reg2722);
Obj _35reg2724 = primCdr(_35reg2723);
Obj _35reg2725 = primCdr(_35reg2724);
Obj _35reg2726 = primCdr(_35reg2725);
Obj _35reg2727 = primEQ(Nil, _35reg2726);
if (True == _35reg2727) {
Obj _35reg2728 = primCdr(_35p1362);
Obj _35reg2729 = primCdr(_35reg2728);
Obj _35reg2730 = primEQ(Nil, _35reg2729);
if (True == _35reg2730) {
pushCont(co, _35clofun3156, 4, actives, params, body, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.code-gen-func-declare"));
co->args[1] = w;
co->args[2] = name;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1363;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3156(struct Cora* co) {
Obj _35val2731 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3157, 4, actives, params, body, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3157(struct Cora* co) {
Obj _35val2732 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3158, 4, actives, params, body, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = Nil;
co->args[2] = w;
co->args[3] = makeString1(" = co->args[");
co->args[4] = makeNumber(1);
co->args[5] = params;
co->nargs = 6;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3158(struct Cora* co) {
Obj _35val2733 = co->args[1];
Obj actives = co->stack[co->base + 0];
Obj params = co->stack[co->base + 1];
Obj body = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3159, 3, params, body, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = Nil;
co->args[2] = w;
co->args[3] = makeString1(" = co->stack[co->base + ");
co->args[4] = makeNumber(0);
co->args[5] = actives;
co->nargs = 6;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3159(struct Cora* co) {
Obj _35val2734 = co->args[1];
Obj params = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3160, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = params;
co->args[2] = w;
co->args[3] = body;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3160(struct Cora* co) {
Obj _35val2735 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("}\n\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3155(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3146(struct Cora* co) {
Obj _35p1354 = co->args[1];
Obj _35p1355 = co->args[2];
Obj _35p1356 = co->args[3];
Obj _35p1357 = co->args[4];
Obj _35p1358 = co->args[5];
Obj _35cc1359 = makeNative(_35clofun3147, 0, 5, _35p1354, _35p1355, _35p1356, _35p1357, _35p1358);
Obj env = _35p1354;
Obj w = _35p1355;
Obj dest_45str = _35p1356;
Obj idx = _35p1357;
Obj _35reg2678 = primEQ(Nil, _35p1358);
if (True == _35reg2678) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1359;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3147(struct Cora* co) {
Obj _35cc1360 = makeNative(_35clofun3148, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj dest_45str = closureRef(co, 2);
Obj idx = closureRef(co, 3);
Obj _35reg2669 = primIsCons(closureRef(co, 4));
if (True == _35reg2669) {
Obj _35reg2670 = primCar(closureRef(co, 4));
Obj a = _35reg2670;
Obj _35reg2671 = primCdr(closureRef(co, 4));
Obj b = _35reg2671;
pushCont(co, _35clofun3149, 6, a, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Obj ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1360;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3149(struct Cora* co) {
Obj _35val2672 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj dest_45str = co->stack[co->base + 4];
Obj b = co->stack[co->base + 5];
pushCont(co, _35clofun3150, 5, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3150(struct Cora* co) {
Obj _35val2673 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3151, 5, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = dest_45str;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3151(struct Cora* co) {
Obj _35val2674 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3152, 5, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = idx;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3152(struct Cora* co) {
Obj _35val2675 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3153, 5, idx, env, w, dest_45str, b);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("];\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3153(struct Cora* co) {
Obj _35val2676 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj dest_45str = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
Obj _35reg2677 = primAdd(idx, makeNumber(1));
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args-reverse"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = dest_45str;
co->args[4] = _35reg2677;
co->args[5] = b;
co->nargs = 6;
if (nativeRequired(co->args[0]) == 5) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3148(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3142(struct Cora* co) {
Obj w = co->args[1];
Obj name = co->args[2];
pushCont(co, _35clofun3143, 2, name, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("void ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3143(struct Cora* co) {
Obj _35val2665 = co->args[1];
Obj name = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3144, 1, w);
co->args[0] = globalRef(intern("c.generate-sym"));
co->args[1] = w;
co->args[2] = name;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3144(struct Cora* co) {
Obj _35val2666 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3145, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("(struct Cora* co");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3145(struct Cora* co) {
Obj _35val2667 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3141(struct Cora* co) {
Obj env = co->args[1];
Obj w = co->args[2];
Obj l = co->args[3];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[3] = w;
co->args[4] = l;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3135(struct Cora* co) {
Obj _35p1348 = co->args[1];
Obj _35p1349 = co->args[2];
Obj _35p1350 = co->args[3];
Obj _35p1351 = co->args[4];
Obj _35cc1352 = makeNative(_35clofun3136, 0, 4, _35p1348, _35p1349, _35p1350, _35p1351);
Obj env = _35p1348;
Obj fn = _35p1349;
Obj w = _35p1350;
Obj _35reg2662 = primEQ(Nil, _35p1351);
if (True == _35reg2662) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1352;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3136(struct Cora* co) {
Obj _35cc1353 = makeNative(_35clofun3137, 0, 0);
Obj env = closureRef(co, 0);
Obj fn = closureRef(co, 1);
Obj w = closureRef(co, 2);
Obj _35reg2655 = primIsCons(closureRef(co, 3));
if (True == _35reg2655) {
Obj _35reg2656 = primCar(closureRef(co, 3));
Obj a = _35reg2656;
Obj _35reg2657 = primCdr(closureRef(co, 3));
Obj b = _35reg2657;
pushCont(co, _35clofun3138, 4, env, fn, w, b);
co->args[0] = fn;
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1353;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3138(struct Cora* co) {
Obj _35val2658 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
pushCont(co, _35clofun3139, 4, env, fn, w, b);
co->args[0] = globalRef(intern("null?"));
co->args[1] = b;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3139(struct Cora* co) {
Obj _35val2659 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
Obj _35reg2660 = primNot(_35val2659);
if (True == _35reg2660) {
pushCont(co, _35clofun3140, 4, env, fn, w, b);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = fn;
co->args[3] = w;
co->args[4] = b;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3140(struct Cora* co) {
Obj _35val2661 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj fn = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list-h"));
co->args[1] = env;
co->args[2] = fn;
co->args[3] = w;
co->args[4] = b;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3137(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3124(struct Cora* co) {
Obj _35p1345 = co->args[1];
Obj _35p1346 = co->args[2];
Obj _35cc1347 = makeNative(_35clofun3125, 0, 0);
Obj w = _35p1345;
Obj _35reg2636 = primIsCons(_35p1346);
if (True == _35reg2636) {
Obj _35reg2637 = primCar(_35p1346);
Obj _35reg2638 = primEQ(intern("%continuation"), _35reg2637);
if (True == _35reg2638) {
Obj _35reg2639 = primCdr(_35p1346);
Obj _35reg2640 = primIsCons(_35reg2639);
if (True == _35reg2640) {
Obj _35reg2641 = primCdr(_35p1346);
Obj _35reg2642 = primCar(_35reg2641);
Obj label = _35reg2642;
Obj _35reg2643 = primCdr(_35p1346);
Obj _35reg2644 = primCdr(_35reg2643);
Obj stacks = _35reg2644;
pushCont(co, _35clofun3126, 3, label, stacks, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("pushCont(co, ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1347;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1347;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1347;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3126(struct Cora* co) {
Obj _35val2645 = co->args[1];
Obj label = co->stack[co->base + 0];
Obj stacks = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3127, 2, stacks, w);
co->args[0] = globalRef(intern("c.generate-sym"));
co->args[1] = w;
co->args[2] = label;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3127(struct Cora* co) {
Obj _35val2646 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3128, 2, stacks, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3128(struct Cora* co) {
Obj _35val2647 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3129, 2, stacks, w);
co->args[0] = globalRef(intern("length"));
co->args[1] = stacks;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3129(struct Cora* co) {
Obj _35val2648 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3130, 2, stacks, w);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = _35val2648;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3130(struct Cora* co) {
Obj _35val2649 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3131, 2, stacks, w);
co->args[0] = globalRef(intern("null?"));
co->args[1] = stacks;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3131(struct Cora* co) {
Obj _35val2650 = co->args[1];
Obj stacks = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj _35reg2651 = primNot(_35val2650);
if (True == _35reg2651) {
pushCont(co, _35clofun3134, 1, w);
co->args[0] = globalRef(intern("for-each"));
co->args[1] = makeNative(_35clofun3132, 1, 1, w);
co->args[2] = stacks;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(");\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3134(struct Cora* co) {
Obj _35val2653 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(");\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3132(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun3133, 1, x);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = closureRef(co, 0);
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3133(struct Cora* co) {
Obj _35val2652 = co->args[1];
Obj x = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = Nil;
co->args[2] = closureRef(co, 0);
co->args[3] = x;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3125(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3116(struct Cora* co) {
Obj _35p1339 = co->args[1];
Obj _35p1340 = co->args[2];
Obj _35p1341 = co->args[3];
Obj _35p1342 = co->args[4];
Obj _35cc1343 = makeNative(_35clofun3117, 0, 4, _35p1339, _35p1340, _35p1341, _35p1342);
Obj env = _35p1339;
Obj w = _35p1340;
Obj idx = _35p1341;
Obj _35reg2634 = primEQ(Nil, _35p1342);
if (True == _35reg2634) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1343;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3117(struct Cora* co) {
Obj _35cc1344 = makeNative(_35clofun3118, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj idx = closureRef(co, 2);
Obj _35reg2625 = primIsCons(closureRef(co, 3));
if (True == _35reg2625) {
Obj _35reg2626 = primCar(closureRef(co, 3));
Obj a = _35reg2626;
Obj _35reg2627 = primCdr(closureRef(co, 3));
Obj b = _35reg2627;
pushCont(co, _35clofun3119, 5, a, idx, env, w, b);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->args[");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1344;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3119(struct Cora* co) {
Obj _35val2628 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3120, 5, a, idx, env, w, b);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = idx;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3120(struct Cora* co) {
Obj _35val2629 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3121, 5, a, idx, env, w, b);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("] = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3121(struct Cora* co) {
Obj _35val2630 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj idx = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj b = co->stack[co->base + 4];
pushCont(co, _35clofun3122, 4, idx, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3122(struct Cora* co) {
Obj _35val2631 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
pushCont(co, _35clofun3123, 4, idx, env, w, b);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3123(struct Cora* co) {
Obj _35val2632 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj b = co->stack[co->base + 3];
Obj _35reg2633 = primAdd(idx, makeNumber(1));
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = _35reg2633;
co->args[4] = b;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3118(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3036(struct Cora* co) {
Obj _35p1322 = co->args[1];
Obj _35p1323 = co->args[2];
Obj _35p1324 = co->args[3];
Obj _35cc1325 = makeNative(_35clofun3037, 0, 3, _35p1322, _35p1323, _35p1324);
Obj env = _35p1322;
Obj w = _35p1323;
Obj x = _35p1324;
Obj _35reg2623 = primIsSymbol(x);
if (True == _35reg2623) {
co->args[0] = globalRef(intern("c.generate-sym"));
co->args[1] = w;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1325;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3037(struct Cora* co) {
Obj _35cc1326 = makeNative(_35clofun3038, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2610 = primIsCons(closureRef(co, 2));
if (True == _35reg2610) {
Obj _35reg2611 = primCar(closureRef(co, 2));
Obj _35reg2612 = primEQ(intern("%global"), _35reg2611);
if (True == _35reg2612) {
Obj _35reg2613 = primCdr(closureRef(co, 2));
Obj _35reg2614 = primIsCons(_35reg2613);
if (True == _35reg2614) {
Obj _35reg2615 = primCdr(closureRef(co, 2));
Obj _35reg2616 = primCar(_35reg2615);
Obj x = _35reg2616;
Obj _35reg2617 = primCdr(closureRef(co, 2));
Obj _35reg2618 = primCdr(_35reg2617);
Obj _35reg2619 = primEQ(Nil, _35reg2618);
if (True == _35reg2619) {
pushCont(co, _35clofun3113, 2, x, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("globalRef(intern(\"");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1326;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1326;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1326;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1326;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3113(struct Cora* co) {
Obj _35val2620 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3114, 1, w);
co->args[0] = globalRef(intern("symbol->string"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3114(struct Cora* co) {
Obj _35val2621 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3115, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = _35val2621;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3115(struct Cora* co) {
Obj _35val2622 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\"))");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3038(struct Cora* co) {
Obj _35cc1327 = makeNative(_35clofun3039, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2598 = primIsCons(closureRef(co, 2));
if (True == _35reg2598) {
Obj _35reg2599 = primCar(closureRef(co, 2));
Obj _35reg2600 = primEQ(intern("%closure-ref"), _35reg2599);
if (True == _35reg2600) {
Obj _35reg2601 = primCdr(closureRef(co, 2));
Obj _35reg2602 = primIsCons(_35reg2601);
if (True == _35reg2602) {
Obj _35reg2603 = primCdr(closureRef(co, 2));
Obj _35reg2604 = primCar(_35reg2603);
Obj idx = _35reg2604;
Obj _35reg2605 = primCdr(closureRef(co, 2));
Obj _35reg2606 = primCdr(_35reg2605);
Obj _35reg2607 = primEQ(Nil, _35reg2606);
if (True == _35reg2607) {
pushCont(co, _35clofun3111, 2, idx, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("closureRef(co, ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1327;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1327;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1327;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1327;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3111(struct Cora* co) {
Obj _35val2608 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3112, 1, w);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = idx;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3112(struct Cora* co) {
Obj _35val2609 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3039(struct Cora* co) {
Obj _35cc1328 = makeNative(_35clofun3040, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2586 = primIsCons(closureRef(co, 2));
if (True == _35reg2586) {
Obj _35reg2587 = primCar(closureRef(co, 2));
Obj _35reg2588 = primEQ(intern("%stack-ref"), _35reg2587);
if (True == _35reg2588) {
Obj _35reg2589 = primCdr(closureRef(co, 2));
Obj _35reg2590 = primIsCons(_35reg2589);
if (True == _35reg2590) {
Obj _35reg2591 = primCdr(closureRef(co, 2));
Obj _35reg2592 = primCar(_35reg2591);
Obj idx = _35reg2592;
Obj _35reg2593 = primCdr(closureRef(co, 2));
Obj _35reg2594 = primCdr(_35reg2593);
Obj _35reg2595 = primEQ(Nil, _35reg2594);
if (True == _35reg2595) {
pushCont(co, _35clofun3109, 2, idx, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("stackRef(co, ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1328;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1328;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1328;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1328;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3109(struct Cora* co) {
Obj _35val2596 = co->args[1];
Obj idx = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3110, 1, w);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = idx;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3110(struct Cora* co) {
Obj _35val2597 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3040(struct Cora* co) {
Obj _35cc1329 = makeNative(_35clofun3041, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2562 = primIsCons(closureRef(co, 2));
if (True == _35reg2562) {
Obj _35reg2563 = primCar(closureRef(co, 2));
Obj _35reg2564 = primEQ(intern("%const"), _35reg2563);
if (True == _35reg2564) {
Obj _35reg2565 = primCdr(closureRef(co, 2));
Obj _35reg2566 = primIsCons(_35reg2565);
if (True == _35reg2566) {
Obj _35reg2567 = primCdr(closureRef(co, 2));
Obj _35reg2568 = primCar(_35reg2567);
Obj x = _35reg2568;
Obj _35reg2569 = primCdr(closureRef(co, 2));
Obj _35reg2570 = primCdr(_35reg2569);
Obj _35reg2571 = primEQ(Nil, _35reg2570);
if (True == _35reg2571) {
Obj _35reg2572 = primIsSymbol(x);
if (True == _35reg2572) {
pushCont(co, _35clofun3100, 2, x, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("intern(\"");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun3103, 2, x, w);
co->args[0] = globalRef(intern("number?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1329;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1329;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1329;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1329;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3103(struct Cora* co) {
Obj _35val2576 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
if (True == _35val2576) {
pushCont(co, _35clofun3104, 2, x, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeNumber(");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2579 = primIsString(x);
if (True == _35reg2579) {
pushCont(co, _35clofun3106, 2, x, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeString1(\"");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2583 = primEQ(x, Nil);
if (True == _35reg2583) {
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Nil");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2584 = primEQ(x, True);
if (True == _35reg2584) {
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("True");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2585 = primEQ(x, False);
if (True == _35reg2585) {
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("False");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no cond match");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}
}
}
}

void _35clofun3106(struct Cora* co) {
Obj _35val2580 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3107, 1, w);
co->args[0] = globalRef(intern("c.escape-str"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3107(struct Cora* co) {
Obj _35val2581 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3108, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = _35val2581;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3108(struct Cora* co) {
Obj _35val2582 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3104(struct Cora* co) {
Obj _35val2577 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3105, 1, w);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3105(struct Cora* co) {
Obj _35val2578 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3100(struct Cora* co) {
Obj _35val2573 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3101, 1, w);
co->args[0] = globalRef(intern("symbol->string"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3101(struct Cora* co) {
Obj _35val2574 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3102, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = _35val2574;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3102(struct Cora* co) {
Obj _35val2575 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3041(struct Cora* co) {
Obj _35cc1330 = makeNative(_35clofun3042, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2523 = primIsCons(closureRef(co, 2));
if (True == _35reg2523) {
Obj _35reg2524 = primCar(closureRef(co, 2));
Obj _35reg2525 = primEQ(intern("let"), _35reg2524);
if (True == _35reg2525) {
Obj _35reg2526 = primCdr(closureRef(co, 2));
Obj _35reg2527 = primIsCons(_35reg2526);
if (True == _35reg2527) {
Obj _35reg2528 = primCdr(closureRef(co, 2));
Obj _35reg2529 = primCar(_35reg2528);
Obj a = _35reg2529;
Obj _35reg2530 = primCdr(closureRef(co, 2));
Obj _35reg2531 = primCdr(_35reg2530);
Obj _35reg2532 = primIsCons(_35reg2531);
if (True == _35reg2532) {
Obj _35reg2533 = primCdr(closureRef(co, 2));
Obj _35reg2534 = primCdr(_35reg2533);
Obj _35reg2535 = primCar(_35reg2534);
Obj b = _35reg2535;
Obj _35reg2536 = primCdr(closureRef(co, 2));
Obj _35reg2537 = primCdr(_35reg2536);
Obj _35reg2538 = primCdr(_35reg2537);
Obj _35reg2539 = primIsCons(_35reg2538);
if (True == _35reg2539) {
Obj _35reg2540 = primCdr(closureRef(co, 2));
Obj _35reg2541 = primCdr(_35reg2540);
Obj _35reg2542 = primCdr(_35reg2541);
Obj _35reg2543 = primCar(_35reg2542);
Obj c = _35reg2543;
Obj _35reg2544 = primCdr(closureRef(co, 2));
Obj _35reg2545 = primCdr(_35reg2544);
Obj _35reg2546 = primCdr(_35reg2545);
Obj _35reg2547 = primCdr(_35reg2546);
Obj _35reg2548 = primEQ(Nil, _35reg2547);
if (True == _35reg2548) {
pushCont(co, _35clofun3090, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = a;
co->args[2] = env;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1330;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3090(struct Cora* co) {
Obj _35val2549 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
Obj idx = _35val2549;
Obj _35reg2550 = primLT(idx, makeNumber(0));
if (True == _35reg2550) {
pushCont(co, _35clofun3091, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("Obj ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
pushCont(co, _35clofun3096, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("c.generate-sym"));
co->args[1] = w;
co->args[2] = a;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3096(struct Cora* co) {
Obj _35val2557 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3097, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3097(struct Cora* co) {
Obj _35val2558 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3098, 4, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3098(struct Cora* co) {
Obj _35val2559 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
pushCont(co, _35clofun3099, 4, a, env, w, c);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3099(struct Cora* co) {
Obj _35val2560 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj _35reg2561 = primCons(a, env);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = _35reg2561;
co->args[2] = w;
co->args[3] = c;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3091(struct Cora* co) {
Obj _35val2551 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3092, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("c.generate-sym"));
co->args[1] = w;
co->args[2] = a;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3092(struct Cora* co) {
Obj _35val2552 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3093, 5, b, a, env, w, c);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(" = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3093(struct Cora* co) {
Obj _35val2553 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
Obj c = co->stack[co->base + 4];
pushCont(co, _35clofun3094, 4, a, env, w, c);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3094(struct Cora* co) {
Obj _35val2554 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
pushCont(co, _35clofun3095, 4, a, env, w, c);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3095(struct Cora* co) {
Obj _35val2555 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj _35reg2556 = primCons(a, env);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = _35reg2556;
co->args[2] = w;
co->args[3] = c;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3042(struct Cora* co) {
Obj _35cc1331 = makeNative(_35clofun3043, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2502 = primIsCons(closureRef(co, 2));
if (True == _35reg2502) {
Obj _35reg2503 = primCar(closureRef(co, 2));
Obj _35reg2504 = primIsCons(_35reg2503);
if (True == _35reg2504) {
Obj _35reg2505 = primCar(closureRef(co, 2));
Obj _35reg2506 = primCar(_35reg2505);
Obj _35reg2507 = primEQ(intern("%builtin"), _35reg2506);
if (True == _35reg2507) {
Obj _35reg2508 = primCar(closureRef(co, 2));
Obj _35reg2509 = primCdr(_35reg2508);
Obj _35reg2510 = primIsCons(_35reg2509);
if (True == _35reg2510) {
Obj _35reg2511 = primCar(closureRef(co, 2));
Obj _35reg2512 = primCdr(_35reg2511);
Obj _35reg2513 = primCar(_35reg2512);
Obj f = _35reg2513;
Obj _35reg2514 = primCar(closureRef(co, 2));
Obj _35reg2515 = primCdr(_35reg2514);
Obj _35reg2516 = primCdr(_35reg2515);
Obj _35reg2517 = primEQ(Nil, _35reg2516);
if (True == _35reg2517) {
Obj _35reg2518 = primCdr(closureRef(co, 2));
Obj args = _35reg2518;
pushCont(co, _35clofun3086, 3, env, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.builtin->name"));
co->args[1] = f;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1331;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3086(struct Cora* co) {
Obj _35val2519 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3087, 3, env, args, w);
co->args[0] = globalRef(intern("c.generate-sym"));
co->args[1] = w;
co->args[2] = _35val2519;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3087(struct Cora* co) {
Obj _35val2520 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3088, 3, env, args, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("(");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3088(struct Cora* co) {
Obj _35val2521 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3089, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = args;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3089(struct Cora* co) {
Obj _35val2522 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3043(struct Cora* co) {
Obj _35cc1332 = makeNative(_35clofun3044, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2470 = primIsCons(closureRef(co, 2));
if (True == _35reg2470) {
Obj _35reg2471 = primCar(closureRef(co, 2));
Obj _35reg2472 = primEQ(intern("if"), _35reg2471);
if (True == _35reg2472) {
Obj _35reg2473 = primCdr(closureRef(co, 2));
Obj _35reg2474 = primIsCons(_35reg2473);
if (True == _35reg2474) {
Obj _35reg2475 = primCdr(closureRef(co, 2));
Obj _35reg2476 = primCar(_35reg2475);
Obj a = _35reg2476;
Obj _35reg2477 = primCdr(closureRef(co, 2));
Obj _35reg2478 = primCdr(_35reg2477);
Obj _35reg2479 = primIsCons(_35reg2478);
if (True == _35reg2479) {
Obj _35reg2480 = primCdr(closureRef(co, 2));
Obj _35reg2481 = primCdr(_35reg2480);
Obj _35reg2482 = primCar(_35reg2481);
Obj b = _35reg2482;
Obj _35reg2483 = primCdr(closureRef(co, 2));
Obj _35reg2484 = primCdr(_35reg2483);
Obj _35reg2485 = primCdr(_35reg2484);
Obj _35reg2486 = primIsCons(_35reg2485);
if (True == _35reg2486) {
Obj _35reg2487 = primCdr(closureRef(co, 2));
Obj _35reg2488 = primCdr(_35reg2487);
Obj _35reg2489 = primCdr(_35reg2488);
Obj _35reg2490 = primCar(_35reg2489);
Obj c = _35reg2490;
Obj _35reg2491 = primCdr(closureRef(co, 2));
Obj _35reg2492 = primCdr(_35reg2491);
Obj _35reg2493 = primCdr(_35reg2492);
Obj _35reg2494 = primCdr(_35reg2493);
Obj _35reg2495 = primEQ(Nil, _35reg2494);
if (True == _35reg2495) {
pushCont(co, _35clofun3080, 5, a, b, env, c, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("if (True == ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1332;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3080(struct Cora* co) {
Obj _35val2496 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj b = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj c = co->stack[co->base + 3];
Obj w = co->stack[co->base + 4];
pushCont(co, _35clofun3081, 4, b, env, c, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3081(struct Cora* co) {
Obj _35val2497 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj c = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3082, 4, b, env, c, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(") {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3082(struct Cora* co) {
Obj _35val2498 = co->args[1];
Obj b = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj c = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3083, 3, env, c, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3083(struct Cora* co) {
Obj _35val2499 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3084, 3, env, c, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("} else {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3084(struct Cora* co) {
Obj _35val2500 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3085, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = c;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3085(struct Cora* co) {
Obj _35val2501 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("}\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3044(struct Cora* co) {
Obj _35cc1333 = makeNative(_35clofun3045, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2443 = primIsCons(closureRef(co, 2));
if (True == _35reg2443) {
Obj _35reg2444 = primCar(closureRef(co, 2));
Obj _35reg2445 = primEQ(intern("%closure"), _35reg2444);
if (True == _35reg2445) {
Obj _35reg2446 = primCdr(closureRef(co, 2));
Obj _35reg2447 = primIsCons(_35reg2446);
if (True == _35reg2447) {
Obj _35reg2448 = primCdr(closureRef(co, 2));
Obj _35reg2449 = primCar(_35reg2448);
Obj label = _35reg2449;
Obj _35reg2450 = primCdr(closureRef(co, 2));
Obj _35reg2451 = primCdr(_35reg2450);
Obj _35reg2452 = primIsCons(_35reg2451);
if (True == _35reg2452) {
Obj _35reg2453 = primCdr(closureRef(co, 2));
Obj _35reg2454 = primCdr(_35reg2453);
Obj _35reg2455 = primCar(_35reg2454);
Obj nargs = _35reg2455;
Obj _35reg2456 = primCdr(closureRef(co, 2));
Obj _35reg2457 = primCdr(_35reg2456);
Obj _35reg2458 = primCdr(_35reg2457);
Obj frees = _35reg2458;
pushCont(co, _35clofun3070, 5, label, nargs, env, frees, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("makeNative(");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1333;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1333;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1333;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1333;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3070(struct Cora* co) {
Obj _35val2459 = co->args[1];
Obj label = co->stack[co->base + 0];
Obj nargs = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj frees = co->stack[co->base + 3];
Obj w = co->stack[co->base + 4];
pushCont(co, _35clofun3071, 4, nargs, env, frees, w);
co->args[0] = globalRef(intern("c.generate-sym"));
co->args[1] = w;
co->args[2] = label;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3071(struct Cora* co) {
Obj _35val2460 = co->args[1];
Obj nargs = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj frees = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3072, 4, nargs, env, frees, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3072(struct Cora* co) {
Obj _35val2461 = co->args[1];
Obj nargs = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj frees = co->stack[co->base + 2];
Obj w = co->stack[co->base + 3];
pushCont(co, _35clofun3073, 3, env, frees, w);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = nargs;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3073(struct Cora* co) {
Obj _35val2462 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3074, 3, env, frees, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3074(struct Cora* co) {
Obj _35val2463 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3075, 3, env, frees, w);
co->args[0] = globalRef(intern("length"));
co->args[1] = frees;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3075(struct Cora* co) {
Obj _35val2464 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3076, 3, env, frees, w);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = _35val2464;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3076(struct Cora* co) {
Obj _35val2465 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3077, 3, env, frees, w);
co->args[0] = globalRef(intern("null?"));
co->args[1] = frees;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3077(struct Cora* co) {
Obj _35val2466 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj _35reg2467 = primNot(_35val2466);
if (True == _35reg2467) {
pushCont(co, _35clofun3078, 3, env, frees, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(", ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Nil;
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3078(struct Cora* co) {
Obj _35val2468 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3079, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst-list"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = frees;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3079(struct Cora* co) {
Obj _35val2469 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(")");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3045(struct Cora* co) {
Obj _35cc1334 = makeNative(_35clofun3046, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2424 = primIsCons(closureRef(co, 2));
if (True == _35reg2424) {
Obj _35reg2425 = primCar(closureRef(co, 2));
Obj _35reg2426 = primEQ(intern("do"), _35reg2425);
if (True == _35reg2426) {
Obj _35reg2427 = primCdr(closureRef(co, 2));
Obj _35reg2428 = primIsCons(_35reg2427);
if (True == _35reg2428) {
Obj _35reg2429 = primCdr(closureRef(co, 2));
Obj _35reg2430 = primCar(_35reg2429);
Obj a = _35reg2430;
Obj _35reg2431 = primCdr(closureRef(co, 2));
Obj _35reg2432 = primCdr(_35reg2431);
Obj _35reg2433 = primIsCons(_35reg2432);
if (True == _35reg2433) {
Obj _35reg2434 = primCdr(closureRef(co, 2));
Obj _35reg2435 = primCdr(_35reg2434);
Obj _35reg2436 = primCar(_35reg2435);
Obj b = _35reg2436;
Obj _35reg2437 = primCdr(closureRef(co, 2));
Obj _35reg2438 = primCdr(_35reg2437);
Obj _35reg2439 = primCdr(_35reg2438);
Obj _35reg2440 = primEQ(Nil, _35reg2439);
if (True == _35reg2440) {
pushCont(co, _35clofun3068, 3, env, w, b);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = a;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1334;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3068(struct Cora* co) {
Obj _35val2441 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj b = co->stack[co->base + 2];
pushCont(co, _35clofun3069, 3, env, w, b);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3069(struct Cora* co) {
Obj _35val2442 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj b = co->stack[co->base + 2];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3046(struct Cora* co) {
Obj _35cc1335 = makeNative(_35clofun3047, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2411 = primIsCons(closureRef(co, 2));
if (True == _35reg2411) {
Obj _35reg2412 = primCar(closureRef(co, 2));
Obj _35reg2413 = primEQ(intern("return"), _35reg2412);
if (True == _35reg2413) {
Obj _35reg2414 = primCdr(closureRef(co, 2));
Obj _35reg2415 = primIsCons(_35reg2414);
if (True == _35reg2415) {
Obj _35reg2416 = primCdr(closureRef(co, 2));
Obj _35reg2417 = primCar(_35reg2416);
Obj x = _35reg2417;
Obj _35reg2418 = primCdr(closureRef(co, 2));
Obj _35reg2419 = primCdr(_35reg2418);
Obj _35reg2420 = primEQ(Nil, _35reg2419);
if (True == _35reg2420) {
pushCont(co, _35clofun3065, 3, env, x, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->args[1] = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1335;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1335;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1335;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1335;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3065(struct Cora* co) {
Obj _35val2421 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj x = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3066, 1, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = x;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3066(struct Cora* co) {
Obj _35val2422 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3067, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\npopStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3067(struct Cora* co) {
Obj _35val2423 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("\nreturn;\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3047(struct Cora* co) {
Obj _35cc1336 = makeNative(_35clofun3048, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2401 = primIsCons(closureRef(co, 2));
if (True == _35reg2401) {
Obj _35reg2402 = primCar(closureRef(co, 2));
Obj _35reg2403 = primEQ(intern("tailcall"), _35reg2402);
if (True == _35reg2403) {
Obj _35reg2404 = primCdr(closureRef(co, 2));
Obj _35reg2405 = primIsCons(_35reg2404);
if (True == _35reg2405) {
Obj _35reg2406 = primCdr(closureRef(co, 2));
Obj _35reg2407 = primCar(_35reg2406);
Obj exp = _35reg2407;
Obj _35reg2408 = primCdr(closureRef(co, 2));
Obj _35reg2409 = primCdr(_35reg2408);
Obj _35reg2410 = primEQ(Nil, _35reg2409);
if (True == _35reg2410) {
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = exp;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1336;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1336;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1336;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1336;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3048(struct Cora* co) {
Obj _35cc1337 = makeNative(_35clofun3049, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2383 = primIsCons(closureRef(co, 2));
if (True == _35reg2383) {
Obj _35reg2384 = primCar(closureRef(co, 2));
Obj _35reg2385 = primEQ(intern("call"), _35reg2384);
if (True == _35reg2385) {
Obj _35reg2386 = primCdr(closureRef(co, 2));
Obj _35reg2387 = primIsCons(_35reg2386);
if (True == _35reg2387) {
Obj _35reg2388 = primCdr(closureRef(co, 2));
Obj _35reg2389 = primCar(_35reg2388);
Obj exp = _35reg2389;
Obj _35reg2390 = primCdr(closureRef(co, 2));
Obj _35reg2391 = primCdr(_35reg2390);
Obj _35reg2392 = primIsCons(_35reg2391);
if (True == _35reg2392) {
Obj _35reg2393 = primCdr(closureRef(co, 2));
Obj _35reg2394 = primCdr(_35reg2393);
Obj _35reg2395 = primCar(_35reg2394);
Obj cont = _35reg2395;
Obj _35reg2396 = primCdr(closureRef(co, 2));
Obj _35reg2397 = primCdr(_35reg2396);
Obj _35reg2398 = primCdr(_35reg2397);
Obj _35reg2399 = primEQ(Nil, _35reg2398);
if (True == _35reg2399) {
pushCont(co, _35clofun3064, 3, env, w, exp);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-cont"));
co->args[1] = w;
co->args[2] = cont;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1337;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3064(struct Cora* co) {
Obj _35val2400 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
Obj exp = co->stack[co->base + 2];
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-inst"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = exp;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3049(struct Cora* co) {
Obj _35cc1338 = makeNative(_35clofun3050, 0, 0);
Obj env = closureRef(co, 0);
Obj w = closureRef(co, 1);
Obj _35reg2365 = primIsCons(closureRef(co, 2));
if (True == _35reg2365) {
Obj _35reg2366 = primCar(closureRef(co, 2));
Obj f = _35reg2366;
Obj _35reg2367 = primCdr(closureRef(co, 2));
Obj args = _35reg2367;
Obj _35reg2368 = primCons(f, args);
pushCont(co, _35clofun3051, 3, f, args, w);
co->args[0] = globalRef(intern("cora/lib/toc/include.generate-call-args"));
co->args[1] = env;
co->args[2] = w;
co->args[3] = makeNumber(0);
co->args[4] = _35reg2368;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1338;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3051(struct Cora* co) {
Obj _35val2369 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
pushCont(co, _35clofun3052, 3, f, args, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->nargs = ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3052(struct Cora* co) {
Obj _35val2370 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj w = co->stack[co->base + 2];
Obj _35reg2371 = primCons(f, args);
pushCont(co, _35clofun3053, 2, args, w);
co->args[0] = globalRef(intern("length"));
co->args[1] = _35reg2371;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3053(struct Cora* co) {
Obj _35val2372 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3054, 2, args, w);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = _35val2372;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3054(struct Cora* co) {
Obj _35val2373 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3055, 2, args, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(";\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3055(struct Cora* co) {
Obj _35val2374 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3056, 2, args, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("if (nativeRequired(co->args[0]) == ");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3056(struct Cora* co) {
Obj _35val2375 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj w = co->stack[co->base + 1];
pushCont(co, _35clofun3057, 1, w);
co->args[0] = globalRef(intern("length"));
co->args[1] = args;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3057(struct Cora* co) {
Obj _35val2376 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3058, 1, w);
co->args[0] = globalRef(intern("c.generate-num"));
co->args[1] = w;
co->args[2] = _35val2376;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3058(struct Cora* co) {
Obj _35val2377 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3059, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1(") {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3059(struct Cora* co) {
Obj _35val2378 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3060, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->pc = nativeFuncPtr(co->args[0]);\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3060(struct Cora* co) {
Obj _35val2379 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3061, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->frees = nativeData(co->args[0]);\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3061(struct Cora* co) {
Obj _35val2380 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3062, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("} else {\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3062(struct Cora* co) {
Obj _35val2381 = co->args[1];
Obj w = co->stack[co->base + 0];
pushCont(co, _35clofun3063, 1, w);
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("co->pc = coraCall;\n}\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3063(struct Cora* co) {
Obj _35val2382 = co->args[1];
Obj w = co->stack[co->base + 0];
co->args[0] = globalRef(intern("c.generate-str"));
co->args[1] = w;
co->args[2] = makeString1("return;\n");
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3050(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3034(struct Cora* co) {
Obj x = co->args[1];
Obj k = co->args[2];
Obj _35reg2358 = primGenSym(intern("reg"));
Obj tmp = _35reg2358;
pushCont(co, _35clofun3035, 2, x, tmp);
co->args[0] = k;
co->args[1] = tmp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3035(struct Cora* co) {
Obj _35val2359 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj tmp = co->stack[co->base + 1];
Obj _35reg2360 = primCons(_35val2359, Nil);
Obj _35reg2361 = primCons(x, _35reg2360);
Obj _35reg2362 = primCons(tmp, _35reg2361);
Obj _35reg2363 = primCons(intern("let"), _35reg2362);
co->args[1] = _35reg2363;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3029(struct Cora* co) {
Obj _35p1316 = co->args[1];
Obj _35p1317 = co->args[2];
Obj _35p1318 = co->args[3];
Obj _35p1319 = co->args[4];
Obj _35cc1320 = makeNative(_35clofun3030, 0, 4, _35p1316, _35p1317, _35p1318, _35p1319);
Obj res = _35p1316;
Obj init = _35p1317;
Obj _35reg2355 = primEQ(Nil, _35p1318);
if (True == _35reg2355) {
Obj k = _35p1319;
pushCont(co, _35clofun3033, 2, k, init);
co->args[0] = globalRef(intern("reverse"));
co->args[1] = res;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1320;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3033(struct Cora* co) {
Obj _35val2356 = co->args[1];
Obj k = co->stack[co->base + 0];
Obj init = co->stack[co->base + 1];
co->args[0] = k;
co->args[1] = init;
co->args[2] = _35val2356;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3030(struct Cora* co) {
Obj _35cc1321 = makeNative(_35clofun3031, 0, 0);
Obj res = closureRef(co, 0);
Obj init = closureRef(co, 1);
Obj _35reg2351 = primIsCons(closureRef(co, 2));
if (True == _35reg2351) {
Obj _35reg2352 = primCar(closureRef(co, 2));
Obj x = _35reg2352;
Obj _35reg2353 = primCdr(closureRef(co, 2));
Obj y = _35reg2353;
Obj k = closureRef(co, 3);
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = init;
co->args[2] = x;
co->args[3] = makeNative(_35clofun3032, 2, 3, res, y, k);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1321;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3032(struct Cora* co) {
Obj init1 = co->args[1];
Obj x1 = co->args[2];
Obj _35reg2354 = primCons(x1, closureRef(co, 0));
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-list"));
co->args[1] = _35reg2354;
co->args[2] = init1;
co->args[3] = closureRef(co, 1);
co->args[4] = closureRef(co, 2);
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3031(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3019(struct Cora* co) {
Obj _35p1310 = co->args[1];
Obj _35p1311 = co->args[2];
Obj _35p1312 = co->args[3];
Obj _35cc1313 = makeNative(_35clofun3020, 0, 3, _35p1310, _35p1311, _35p1312);
Obj res = _35p1310;
Obj _35reg2245 = primIsCons(_35p1311);
if (True == _35reg2245) {
Obj _35reg2246 = primCar(_35p1311);
Obj clo_45or_45cont = _35reg2246;
Obj _35reg2247 = primCdr(_35p1311);
Obj _35reg2248 = primIsCons(_35reg2247);
if (True == _35reg2248) {
Obj _35reg2249 = primCdr(_35p1311);
Obj _35reg2250 = primCar(_35reg2249);
Obj _35reg2251 = primIsCons(_35reg2250);
if (True == _35reg2251) {
Obj _35reg2252 = primCdr(_35p1311);
Obj _35reg2253 = primCar(_35reg2252);
Obj _35reg2254 = primCar(_35reg2253);
Obj _35reg2255 = primEQ(intern("lambda"), _35reg2254);
if (True == _35reg2255) {
Obj _35reg2256 = primCdr(_35p1311);
Obj _35reg2257 = primCar(_35reg2256);
Obj _35reg2258 = primCdr(_35reg2257);
Obj _35reg2259 = primIsCons(_35reg2258);
if (True == _35reg2259) {
Obj _35reg2260 = primCdr(_35p1311);
Obj _35reg2261 = primCar(_35reg2260);
Obj _35reg2262 = primCdr(_35reg2261);
Obj _35reg2263 = primCar(_35reg2262);
Obj params = _35reg2263;
Obj _35reg2264 = primCdr(_35p1311);
Obj _35reg2265 = primCar(_35reg2264);
Obj _35reg2266 = primCdr(_35reg2265);
Obj _35reg2267 = primCdr(_35reg2266);
Obj _35reg2268 = primIsCons(_35reg2267);
if (True == _35reg2268) {
Obj _35reg2269 = primCdr(_35p1311);
Obj _35reg2270 = primCar(_35reg2269);
Obj _35reg2271 = primCdr(_35reg2270);
Obj _35reg2272 = primCdr(_35reg2271);
Obj _35reg2273 = primCar(_35reg2272);
Obj body = _35reg2273;
Obj _35reg2274 = primCdr(_35p1311);
Obj _35reg2275 = primCar(_35reg2274);
Obj _35reg2276 = primCdr(_35reg2275);
Obj _35reg2277 = primCdr(_35reg2276);
Obj _35reg2278 = primCdr(_35reg2277);
Obj _35reg2279 = primEQ(Nil, _35reg2278);
if (True == _35reg2279) {
Obj _35reg2280 = primCdr(_35p1311);
Obj _35reg2281 = primCdr(_35reg2280);
Obj fvs = _35reg2281;
Obj k = _35p1312;
Obj _35reg2282 = primEQ(clo_45or_45cont, intern("%closure"));
if (True == _35reg2282) {
if (True == True) {
Obj _35reg2283 = primGenSym(intern("clofun"));
Obj name = _35reg2283;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3023, 2, 5, k, params, clo_45or_45cont, name, fvs);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
Obj _35reg2305 = primEQ(clo_45or_45cont, intern("%continuation"));
if (True == _35reg2305) {
if (True == True) {
Obj _35reg2306 = primGenSym(intern("clofun"));
Obj name = _35reg2306;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3025, 2, 5, k, params, clo_45or_45cont, name, fvs);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg2328 = primGenSym(intern("clofun"));
Obj name = _35reg2328;
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda"));
co->args[1] = res;
co->args[2] = body;
co->args[3] = makeNative(_35clofun3027, 2, 5, k, params, clo_45or_45cont, name, fvs);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1313;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3027(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2329 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2329) {
Obj _35reg2330 = primCons(body1, Nil);
Obj _35reg2331 = primCons(Nil, _35reg2330);
Obj _35reg2332 = primCons(closureRef(co, 1), _35reg2331);
Obj _35reg2333 = primCons(intern("lambda"), _35reg2332);
Obj _35reg2334 = primCons(_35reg2333, Nil);
Obj _35reg2335 = primCons(closureRef(co, 3), _35reg2334);
Obj _35reg2336 = primCons(_35reg2335, res1);
pushCont(co, _35clofun3028, 1, _35reg2336);
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2341 = primCons(body1, Nil);
Obj _35reg2342 = primCons(closureRef(co, 4), _35reg2341);
Obj _35reg2343 = primCons(closureRef(co, 1), _35reg2342);
Obj _35reg2344 = primCons(intern("lambda"), _35reg2343);
Obj _35reg2345 = primCons(_35reg2344, Nil);
Obj _35reg2346 = primCons(closureRef(co, 3), _35reg2345);
Obj _35reg2347 = primCons(_35reg2346, res1);
Obj _35reg2348 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2349 = primCons(closureRef(co, 2), _35reg2348);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2347;
co->args[2] = _35reg2349;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3028(struct Cora* co) {
Obj _35val2337 = co->args[1];
Obj _35reg2336 = co->stack[co->base + 0];
Obj _35reg2338 = primCons(_35val2337, closureRef(co, 4));
Obj _35reg2339 = primCons(closureRef(co, 3), _35reg2338);
Obj _35reg2340 = primCons(closureRef(co, 2), _35reg2339);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2336;
co->args[2] = _35reg2340;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3025(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2307 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2307) {
Obj _35reg2308 = primCons(body1, Nil);
Obj _35reg2309 = primCons(Nil, _35reg2308);
Obj _35reg2310 = primCons(closureRef(co, 1), _35reg2309);
Obj _35reg2311 = primCons(intern("lambda"), _35reg2310);
Obj _35reg2312 = primCons(_35reg2311, Nil);
Obj _35reg2313 = primCons(closureRef(co, 3), _35reg2312);
Obj _35reg2314 = primCons(_35reg2313, res1);
pushCont(co, _35clofun3026, 1, _35reg2314);
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2319 = primCons(body1, Nil);
Obj _35reg2320 = primCons(closureRef(co, 4), _35reg2319);
Obj _35reg2321 = primCons(closureRef(co, 1), _35reg2320);
Obj _35reg2322 = primCons(intern("lambda"), _35reg2321);
Obj _35reg2323 = primCons(_35reg2322, Nil);
Obj _35reg2324 = primCons(closureRef(co, 3), _35reg2323);
Obj _35reg2325 = primCons(_35reg2324, res1);
Obj _35reg2326 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2327 = primCons(closureRef(co, 2), _35reg2326);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2325;
co->args[2] = _35reg2327;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3026(struct Cora* co) {
Obj _35val2315 = co->args[1];
Obj _35reg2314 = co->stack[co->base + 0];
Obj _35reg2316 = primCons(_35val2315, closureRef(co, 4));
Obj _35reg2317 = primCons(closureRef(co, 3), _35reg2316);
Obj _35reg2318 = primCons(closureRef(co, 2), _35reg2317);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2314;
co->args[2] = _35reg2318;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3023(struct Cora* co) {
Obj res1 = co->args[1];
Obj body1 = co->args[2];
Obj _35reg2284 = primEQ(closureRef(co, 2), intern("%closure"));
if (True == _35reg2284) {
Obj _35reg2285 = primCons(body1, Nil);
Obj _35reg2286 = primCons(Nil, _35reg2285);
Obj _35reg2287 = primCons(closureRef(co, 1), _35reg2286);
Obj _35reg2288 = primCons(intern("lambda"), _35reg2287);
Obj _35reg2289 = primCons(_35reg2288, Nil);
Obj _35reg2290 = primCons(closureRef(co, 3), _35reg2289);
Obj _35reg2291 = primCons(_35reg2290, res1);
pushCont(co, _35clofun3024, 1, _35reg2291);
co->args[0] = globalRef(intern("length"));
co->args[1] = closureRef(co, 1);
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2296 = primCons(body1, Nil);
Obj _35reg2297 = primCons(closureRef(co, 4), _35reg2296);
Obj _35reg2298 = primCons(closureRef(co, 1), _35reg2297);
Obj _35reg2299 = primCons(intern("lambda"), _35reg2298);
Obj _35reg2300 = primCons(_35reg2299, Nil);
Obj _35reg2301 = primCons(closureRef(co, 3), _35reg2300);
Obj _35reg2302 = primCons(_35reg2301, res1);
Obj _35reg2303 = primCons(closureRef(co, 3), closureRef(co, 4));
Obj _35reg2304 = primCons(closureRef(co, 2), _35reg2303);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2302;
co->args[2] = _35reg2304;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3024(struct Cora* co) {
Obj _35val2292 = co->args[1];
Obj _35reg2291 = co->stack[co->base + 0];
Obj _35reg2293 = primCons(_35val2292, closureRef(co, 4));
Obj _35reg2294 = primCons(closureRef(co, 3), _35reg2293);
Obj _35reg2295 = primCons(closureRef(co, 2), _35reg2294);
co->args[0] = closureRef(co, 0);
co->args[1] = _35reg2291;
co->args[2] = _35reg2295;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3020(struct Cora* co) {
Obj _35cc1314 = makeNative(_35clofun3021, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj res = closureRef(co, 0);
Obj f_45args = closureRef(co, 1);
Obj k = closureRef(co, 2);
Obj _35reg2244 = primIsCons(f_45args);
if (True == _35reg2244) {
co->args[0] = globalRef(intern("cora/lib/toc/include.collect-lambda-list"));
co->args[1] = Nil;
co->args[2] = res;
co->args[3] = f_45args;
co->args[4] = k;
co->nargs = 5;
if (nativeRequired(co->args[0]) == 4) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1314;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3021(struct Cora* co) {
Obj _35cc1315 = makeNative(_35clofun3022, 0, 0);
Obj res = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj k = closureRef(co, 2);
co->args[0] = k;
co->args[1] = res;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3022(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3001(struct Cora* co) {
Obj _35p1302 = co->args[1];
Obj _35p1303 = co->args[2];
Obj _35cc1304 = makeNative(_35clofun3002, 0, 2, _35p1302, _35p1303);
Obj __ = _35p1302;
Obj x = _35p1303;
pushCont(co, _35clofun3018, 2, x, _35cc1304);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3018(struct Cora* co) {
Obj _35val2242 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1304 = co->stack[co->base + 1];
if (True == _35val2242) {
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1304;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3002(struct Cora* co) {
Obj _35cc1305 = makeNative(_35clofun3003, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj var = closureRef(co, 1);
Obj _35reg2241 = primIsSymbol(var);
if (True == _35reg2241) {
co->args[1] = var;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1305;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3003(struct Cora* co) {
Obj _35cc1306 = makeNative(_35clofun3004, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2220 = primIsCons(closureRef(co, 1));
if (True == _35reg2220) {
Obj _35reg2221 = primCar(closureRef(co, 1));
Obj _35reg2222 = primEQ(intern("lambda"), _35reg2221);
if (True == _35reg2222) {
Obj _35reg2223 = primCdr(closureRef(co, 1));
Obj _35reg2224 = primIsCons(_35reg2223);
if (True == _35reg2224) {
Obj _35reg2225 = primCdr(closureRef(co, 1));
Obj _35reg2226 = primCar(_35reg2225);
Obj args = _35reg2226;
Obj _35reg2227 = primCdr(closureRef(co, 1));
Obj _35reg2228 = primCdr(_35reg2227);
Obj _35reg2229 = primIsCons(_35reg2228);
if (True == _35reg2229) {
Obj _35reg2230 = primCdr(closureRef(co, 1));
Obj _35reg2231 = primCdr(_35reg2230);
Obj _35reg2232 = primCar(_35reg2231);
Obj body = _35reg2232;
Obj _35reg2233 = primCdr(closureRef(co, 1));
Obj _35reg2234 = primCdr(_35reg2233);
Obj _35reg2235 = primCdr(_35reg2234);
Obj _35reg2236 = primEQ(Nil, _35reg2235);
if (True == _35reg2236) {
pushCont(co, _35clofun3017, 1, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->args[2] = body;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1306;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3017(struct Cora* co) {
Obj _35val2237 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg2238 = primCons(_35val2237, Nil);
Obj _35reg2239 = primCons(args, _35reg2238);
Obj _35reg2240 = primCons(intern("lambda"), _35reg2239);
co->args[1] = _35reg2240;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3004(struct Cora* co) {
Obj _35cc1307 = makeNative(_35clofun3005, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2193 = primIsCons(closureRef(co, 1));
if (True == _35reg2193) {
Obj _35reg2194 = primCar(closureRef(co, 1));
Obj _35reg2195 = primEQ(intern("continuation"), _35reg2194);
if (True == _35reg2195) {
Obj _35reg2196 = primCdr(closureRef(co, 1));
Obj _35reg2197 = primIsCons(_35reg2196);
if (True == _35reg2197) {
Obj _35reg2198 = primCdr(closureRef(co, 1));
Obj _35reg2199 = primCar(_35reg2198);
Obj val = _35reg2199;
Obj _35reg2200 = primCdr(closureRef(co, 1));
Obj _35reg2201 = primCdr(_35reg2200);
Obj _35reg2202 = primIsCons(_35reg2201);
if (True == _35reg2202) {
Obj _35reg2203 = primCdr(closureRef(co, 1));
Obj _35reg2204 = primCdr(_35reg2203);
Obj _35reg2205 = primCar(_35reg2204);
Obj body = _35reg2205;
Obj _35reg2206 = primCdr(closureRef(co, 1));
Obj _35reg2207 = primCdr(_35reg2206);
Obj _35reg2208 = primCdr(_35reg2207);
Obj _35reg2209 = primEQ(Nil, _35reg2208);
if (True == _35reg2209) {
pushCont(co, _35clofun3012, 3, fvs, body, val);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1307;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3012(struct Cora* co) {
Obj _35val2210 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
pushCont(co, _35clofun3013, 3, fvs, body, val);
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val2210;
co->args[2] = val;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3013(struct Cora* co) {
Obj _35val2211 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
Obj fvs1 = _35val2211;
pushCont(co, _35clofun3014, 3, fvs1, body, val);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3014(struct Cora* co) {
Obj _35val2212 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
pushCont(co, _35clofun3015, 3, fvs1, body, val);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2212;
co->args[2] = fvs1;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3015(struct Cora* co) {
Obj _35val2213 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj body = co->stack[co->base + 1];
Obj val = co->stack[co->base + 2];
Obj fvs2 = _35val2213;
pushCont(co, _35clofun3016, 2, val, fvs2);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs1;
co->args[2] = body;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3016(struct Cora* co) {
Obj _35val2214 = co->args[1];
Obj val = co->stack[co->base + 0];
Obj fvs2 = co->stack[co->base + 1];
Obj _35reg2215 = primCons(_35val2214, Nil);
Obj _35reg2216 = primCons(val, _35reg2215);
Obj _35reg2217 = primCons(intern("lambda"), _35reg2216);
Obj _35reg2218 = primCons(_35reg2217, fvs2);
Obj _35reg2219 = primCons(intern("%continuation"), _35reg2218);
co->args[1] = _35reg2219;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3005(struct Cora* co) {
Obj _35cc1308 = makeNative(_35clofun3006, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg2170 = primIsCons(closureRef(co, 1));
if (True == _35reg2170) {
Obj _35reg2171 = primCar(closureRef(co, 1));
Obj _35reg2172 = primEQ(intern("call"), _35reg2171);
if (True == _35reg2172) {
Obj _35reg2173 = primCdr(closureRef(co, 1));
Obj _35reg2174 = primIsCons(_35reg2173);
if (True == _35reg2174) {
Obj _35reg2175 = primCdr(closureRef(co, 1));
Obj _35reg2176 = primCar(_35reg2175);
Obj exp = _35reg2176;
Obj _35reg2177 = primCdr(closureRef(co, 1));
Obj _35reg2178 = primCdr(_35reg2177);
Obj _35reg2179 = primIsCons(_35reg2178);
if (True == _35reg2179) {
Obj _35reg2180 = primCdr(closureRef(co, 1));
Obj _35reg2181 = primCdr(_35reg2180);
Obj _35reg2182 = primCar(_35reg2181);
Obj cont = _35reg2182;
Obj _35reg2183 = primCdr(closureRef(co, 1));
Obj _35reg2184 = primCdr(_35reg2183);
Obj _35reg2185 = primCdr(_35reg2184);
Obj _35reg2186 = primEQ(Nil, _35reg2185);
if (True == _35reg2186) {
pushCont(co, _35clofun3009, 3, exp, fvs, cont);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1308;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3009(struct Cora* co) {
Obj _35val2187 = co->args[1];
Obj exp = co->stack[co->base + 0];
Obj fvs = co->stack[co->base + 1];
Obj cont = co->stack[co->base + 2];
pushCont(co, _35clofun3010, 2, fvs, cont);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2187;
co->args[2] = exp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3010(struct Cora* co) {
Obj _35val2188 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj cont = co->stack[co->base + 1];
pushCont(co, _35clofun3011, 1, _35val2188);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->args[2] = cont;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3011(struct Cora* co) {
Obj _35val2189 = co->args[1];
Obj _35val2188 = co->stack[co->base + 0];
Obj _35reg2190 = primCons(_35val2189, Nil);
Obj _35reg2191 = primCons(_35val2188, _35reg2190);
Obj _35reg2192 = primCons(intern("call"), _35reg2191);
co->args[1] = _35reg2192;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun3006(struct Cora* co) {
Obj _35cc1309 = makeNative(_35clofun3007, 0, 0);
Obj fvs = closureRef(co, 0);
Obj _35reg2165 = primIsCons(closureRef(co, 1));
if (True == _35reg2165) {
Obj _35reg2166 = primCar(closureRef(co, 1));
Obj f = _35reg2166;
Obj _35reg2167 = primCdr(closureRef(co, 1));
Obj args = _35reg2167;
pushCont(co, _35clofun3008, 2, f, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.explicit-stack"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1309;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun3008(struct Cora* co) {
Obj _35val2168 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj _35reg2169 = primCons(f, args);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val2168;
co->args[2] = _35reg2169;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun3007(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2991(struct Cora* co) {
Obj _35p1297 = co->args[1];
Obj _35p1298 = co->args[2];
Obj _35p1299 = co->args[3];
Obj _35cc1300 = makeNative(_35clofun2992, 0, 3, _35p1297, _35p1298, _35p1299);
Obj _35reg2122 = primEQ(Nil, _35p1297);
if (True == _35reg2122) {
Obj ls = _35p1298;
Obj next = _35p1299;
pushCont(co, _35clofun2995, 1, next);
co->args[0] = globalRef(intern("reverse"));
co->args[1] = ls;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1300;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2995(struct Cora* co) {
Obj _35val2123 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = _35val2123;
Obj _35reg2124 = primCar(exp);
pushCont(co, _35clofun2996, 2, next, exp);
co->args[0] = globalRef(intern("pair?"));
co->args[1] = _35reg2124;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2996(struct Cora* co) {
Obj _35val2125 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
if (True == _35val2125) {
pushCont(co, _35clofun2997, 2, next, exp);
co->args[0] = globalRef(intern("caar"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
if (True == False) {
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2152 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2152) {
Obj _35reg2153 = primCons(exp, Nil);
Obj _35reg2154 = primCons(intern("tailcall"), _35reg2153);
co->args[1] = _35reg2154;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2155 = primGenSym(intern("val"));
Obj val = _35reg2155;
Obj _35reg2156 = primCons(val, Nil);
pushCont(co, _35clofun3000, 2, _35reg2156, exp);
co->args[0] = next;
co->args[1] = val;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun3000(struct Cora* co) {
Obj _35val2157 = co->args[1];
Obj _35reg2156 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2158 = primCons(_35val2157, Nil);
Obj _35reg2159 = primCons(_35reg2156, _35reg2158);
Obj _35reg2160 = primCons(intern("continuation"), _35reg2159);
Obj _35reg2161 = primCons(_35reg2160, Nil);
Obj _35reg2162 = primCons(exp, _35reg2161);
Obj _35reg2163 = primCons(intern("call"), _35reg2162);
co->args[1] = _35reg2163;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2997(struct Cora* co) {
Obj _35val2126 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2127 = primEQ(_35val2126, intern("%builtin"));
if (True == _35reg2127) {
if (True == True) {
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2128 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2128) {
Obj _35reg2129 = primCons(exp, Nil);
Obj _35reg2130 = primCons(intern("tailcall"), _35reg2129);
co->args[1] = _35reg2130;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2131 = primGenSym(intern("val"));
Obj val = _35reg2131;
Obj _35reg2132 = primCons(val, Nil);
pushCont(co, _35clofun2998, 2, _35reg2132, exp);
co->args[0] = next;
co->args[1] = val;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
} else {
if (True == False) {
co->args[0] = globalRef(intern("cora/lib/toc/include.wrap-var"));
co->args[1] = exp;
co->args[2] = next;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg2140 = primEQ(next, globalRef(intern("cora/lib/toc/include.id")));
if (True == _35reg2140) {
Obj _35reg2141 = primCons(exp, Nil);
Obj _35reg2142 = primCons(intern("tailcall"), _35reg2141);
co->args[1] = _35reg2142;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg2143 = primGenSym(intern("val"));
Obj val = _35reg2143;
Obj _35reg2144 = primCons(val, Nil);
pushCont(co, _35clofun2999, 2, _35reg2144, exp);
co->args[0] = next;
co->args[1] = val;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}
}

void _35clofun2999(struct Cora* co) {
Obj _35val2145 = co->args[1];
Obj _35reg2144 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2146 = primCons(_35val2145, Nil);
Obj _35reg2147 = primCons(_35reg2144, _35reg2146);
Obj _35reg2148 = primCons(intern("continuation"), _35reg2147);
Obj _35reg2149 = primCons(_35reg2148, Nil);
Obj _35reg2150 = primCons(exp, _35reg2149);
Obj _35reg2151 = primCons(intern("call"), _35reg2150);
co->args[1] = _35reg2151;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2998(struct Cora* co) {
Obj _35val2133 = co->args[1];
Obj _35reg2132 = co->stack[co->base + 0];
Obj exp = co->stack[co->base + 1];
Obj _35reg2134 = primCons(_35val2133, Nil);
Obj _35reg2135 = primCons(_35reg2132, _35reg2134);
Obj _35reg2136 = primCons(intern("continuation"), _35reg2135);
Obj _35reg2137 = primCons(_35reg2136, Nil);
Obj _35reg2138 = primCons(exp, _35reg2137);
Obj _35reg2139 = primCons(intern("call"), _35reg2138);
co->args[1] = _35reg2139;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2992(struct Cora* co) {
Obj _35cc1301 = makeNative(_35clofun2993, 0, 0);
Obj _35reg2118 = primIsCons(closureRef(co, 0));
if (True == _35reg2118) {
Obj _35reg2119 = primCar(closureRef(co, 0));
Obj hd = _35reg2119;
Obj _35reg2120 = primCdr(closureRef(co, 0));
Obj tl = _35reg2120;
Obj ls = closureRef(co, 1);
Obj next = closureRef(co, 2);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = hd;
co->args[2] = makeNative(_35clofun2994, 1, 3, tl, ls, next);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1301;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2994(struct Cora* co) {
Obj hd1 = co->args[1];
Obj _35reg2121 = primCons(hd1, closureRef(co, 1));
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-list"));
co->args[1] = closureRef(co, 0);
co->args[2] = _35reg2121;
co->args[3] = closureRef(co, 2);
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2993(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2973(struct Cora* co) {
Obj _35p1288 = co->args[1];
Obj _35p1289 = co->args[2];
Obj _35cc1290 = makeNative(_35clofun2974, 0, 2, _35p1288, _35p1289);
Obj x = _35p1288;
Obj next = _35p1289;
Obj _35reg2115 = primIsSymbol(x);
if (True == _35reg2115) {
if (True == True) {
co->args[0] = next;
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1290;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun2990, 3, next, x, _35cc1290);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2990(struct Cora* co) {
Obj _35val2116 = co->args[1];
Obj next = co->stack[co->base + 0];
Obj x = co->stack[co->base + 1];
Obj _35cc1290 = co->stack[co->base + 2];
if (True == _35val2116) {
if (True == True) {
co->args[0] = next;
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1290;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
co->args[0] = next;
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1290;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun2974(struct Cora* co) {
Obj _35cc1291 = makeNative(_35clofun2975, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj x = closureRef(co, 0);
Obj __ = closureRef(co, 1);
pushCont(co, _35clofun2989, 2, x, _35cc1291);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2989(struct Cora* co) {
Obj _35val2114 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1291 = co->stack[co->base + 1];
if (True == _35val2114) {
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1291;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2975(struct Cora* co) {
Obj _35cc1292 = makeNative(_35clofun2976, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2082 = primIsCons(closureRef(co, 0));
if (True == _35reg2082) {
Obj _35reg2083 = primCar(closureRef(co, 0));
Obj _35reg2084 = primEQ(intern("if"), _35reg2083);
if (True == _35reg2084) {
Obj _35reg2085 = primCdr(closureRef(co, 0));
Obj _35reg2086 = primIsCons(_35reg2085);
if (True == _35reg2086) {
Obj _35reg2087 = primCdr(closureRef(co, 0));
Obj _35reg2088 = primCar(_35reg2087);
Obj a = _35reg2088;
Obj _35reg2089 = primCdr(closureRef(co, 0));
Obj _35reg2090 = primCdr(_35reg2089);
Obj _35reg2091 = primIsCons(_35reg2090);
if (True == _35reg2091) {
Obj _35reg2092 = primCdr(closureRef(co, 0));
Obj _35reg2093 = primCdr(_35reg2092);
Obj _35reg2094 = primCar(_35reg2093);
Obj b = _35reg2094;
Obj _35reg2095 = primCdr(closureRef(co, 0));
Obj _35reg2096 = primCdr(_35reg2095);
Obj _35reg2097 = primCdr(_35reg2096);
Obj _35reg2098 = primIsCons(_35reg2097);
if (True == _35reg2098) {
Obj _35reg2099 = primCdr(closureRef(co, 0));
Obj _35reg2100 = primCdr(_35reg2099);
Obj _35reg2101 = primCdr(_35reg2100);
Obj _35reg2102 = primCar(_35reg2101);
Obj c = _35reg2102;
Obj _35reg2103 = primCdr(closureRef(co, 0));
Obj _35reg2104 = primCdr(_35reg2103);
Obj _35reg2105 = primCdr(_35reg2104);
Obj _35reg2106 = primCdr(_35reg2105);
Obj _35reg2107 = primEQ(Nil, _35reg2106);
if (True == _35reg2107) {
Obj next = closureRef(co, 1);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = a;
co->args[2] = makeNative(_35clofun2986, 1, 3, b, c, next);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1292;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2986(struct Cora* co) {
Obj ra = co->args[1];
pushCont(co, _35clofun2987, 1, ra);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 2);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2987(struct Cora* co) {
Obj _35val2108 = co->args[1];
Obj ra = co->stack[co->base + 0];
pushCont(co, _35clofun2988, 2, _35val2108, ra);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 1);
co->args[2] = closureRef(co, 2);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2988(struct Cora* co) {
Obj _35val2109 = co->args[1];
Obj _35val2108 = co->stack[co->base + 0];
Obj ra = co->stack[co->base + 1];
Obj _35reg2110 = primCons(_35val2109, Nil);
Obj _35reg2111 = primCons(_35val2108, _35reg2110);
Obj _35reg2112 = primCons(ra, _35reg2111);
Obj _35reg2113 = primCons(intern("if"), _35reg2112);
co->args[1] = _35reg2113;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2976(struct Cora* co) {
Obj _35cc1293 = makeNative(_35clofun2977, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2060 = primIsCons(closureRef(co, 0));
if (True == _35reg2060) {
Obj _35reg2061 = primCar(closureRef(co, 0));
Obj _35reg2062 = primEQ(intern("do"), _35reg2061);
if (True == _35reg2062) {
Obj _35reg2063 = primCdr(closureRef(co, 0));
Obj _35reg2064 = primIsCons(_35reg2063);
if (True == _35reg2064) {
Obj _35reg2065 = primCdr(closureRef(co, 0));
Obj _35reg2066 = primCar(_35reg2065);
Obj a = _35reg2066;
Obj _35reg2067 = primCdr(closureRef(co, 0));
Obj _35reg2068 = primCdr(_35reg2067);
Obj _35reg2069 = primIsCons(_35reg2068);
if (True == _35reg2069) {
Obj _35reg2070 = primCdr(closureRef(co, 0));
Obj _35reg2071 = primCdr(_35reg2070);
Obj _35reg2072 = primCar(_35reg2071);
Obj b = _35reg2072;
Obj _35reg2073 = primCdr(closureRef(co, 0));
Obj _35reg2074 = primCdr(_35reg2073);
Obj _35reg2075 = primCdr(_35reg2074);
Obj _35reg2076 = primEQ(Nil, _35reg2075);
if (True == _35reg2076) {
Obj next = closureRef(co, 1);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = a;
co->args[2] = makeNative(_35clofun2984, 1, 2, b, next);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1293;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2984(struct Cora* co) {
Obj ra = co->args[1];
Obj _35reg2077 = primIsSymbol(ra);
if (True == _35reg2077) {
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 1);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
pushCont(co, _35clofun2985, 1, ra);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 0);
co->args[2] = closureRef(co, 1);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2985(struct Cora* co) {
Obj _35val2078 = co->args[1];
Obj ra = co->stack[co->base + 0];
Obj _35reg2079 = primCons(_35val2078, Nil);
Obj _35reg2080 = primCons(ra, _35reg2079);
Obj _35reg2081 = primCons(intern("do"), _35reg2080);
co->args[1] = _35reg2081;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2977(struct Cora* co) {
Obj _35cc1294 = makeNative(_35clofun2978, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg2029 = primIsCons(closureRef(co, 0));
if (True == _35reg2029) {
Obj _35reg2030 = primCar(closureRef(co, 0));
Obj _35reg2031 = primEQ(intern("let"), _35reg2030);
if (True == _35reg2031) {
Obj _35reg2032 = primCdr(closureRef(co, 0));
Obj _35reg2033 = primIsCons(_35reg2032);
if (True == _35reg2033) {
Obj _35reg2034 = primCdr(closureRef(co, 0));
Obj _35reg2035 = primCar(_35reg2034);
Obj a = _35reg2035;
Obj _35reg2036 = primCdr(closureRef(co, 0));
Obj _35reg2037 = primCdr(_35reg2036);
Obj _35reg2038 = primIsCons(_35reg2037);
if (True == _35reg2038) {
Obj _35reg2039 = primCdr(closureRef(co, 0));
Obj _35reg2040 = primCdr(_35reg2039);
Obj _35reg2041 = primCar(_35reg2040);
Obj b = _35reg2041;
Obj _35reg2042 = primCdr(closureRef(co, 0));
Obj _35reg2043 = primCdr(_35reg2042);
Obj _35reg2044 = primCdr(_35reg2043);
Obj _35reg2045 = primIsCons(_35reg2044);
if (True == _35reg2045) {
Obj _35reg2046 = primCdr(closureRef(co, 0));
Obj _35reg2047 = primCdr(_35reg2046);
Obj _35reg2048 = primCdr(_35reg2047);
Obj _35reg2049 = primCar(_35reg2048);
Obj c = _35reg2049;
Obj _35reg2050 = primCdr(closureRef(co, 0));
Obj _35reg2051 = primCdr(_35reg2050);
Obj _35reg2052 = primCdr(_35reg2051);
Obj _35reg2053 = primCdr(_35reg2052);
Obj _35reg2054 = primEQ(Nil, _35reg2053);
if (True == _35reg2054) {
Obj next = closureRef(co, 1);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = b;
co->args[2] = makeNative(_35clofun2982, 1, 3, a, c, next);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1294;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2982(struct Cora* co) {
Obj rb = co->args[1];
pushCont(co, _35clofun2983, 1, rb);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = closureRef(co, 1);
co->args[2] = closureRef(co, 2);
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2983(struct Cora* co) {
Obj _35val2055 = co->args[1];
Obj rb = co->stack[co->base + 0];
Obj _35reg2056 = primCons(_35val2055, Nil);
Obj _35reg2057 = primCons(rb, _35reg2056);
Obj _35reg2058 = primCons(closureRef(co, 0), _35reg2057);
Obj _35reg2059 = primCons(intern("let"), _35reg2058);
co->args[1] = _35reg2059;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2978(struct Cora* co) {
Obj _35cc1295 = makeNative(_35clofun2979, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1985 = primIsCons(closureRef(co, 0));
if (True == _35reg1985) {
Obj _35reg1986 = primCar(closureRef(co, 0));
Obj _35reg1987 = primEQ(intern("%closure"), _35reg1986);
if (True == _35reg1987) {
Obj _35reg1988 = primCdr(closureRef(co, 0));
Obj _35reg1989 = primIsCons(_35reg1988);
if (True == _35reg1989) {
Obj _35reg1990 = primCdr(closureRef(co, 0));
Obj _35reg1991 = primCar(_35reg1990);
Obj _35reg1992 = primIsCons(_35reg1991);
if (True == _35reg1992) {
Obj _35reg1993 = primCdr(closureRef(co, 0));
Obj _35reg1994 = primCar(_35reg1993);
Obj _35reg1995 = primCar(_35reg1994);
Obj _35reg1996 = primEQ(intern("lambda"), _35reg1995);
if (True == _35reg1996) {
Obj _35reg1997 = primCdr(closureRef(co, 0));
Obj _35reg1998 = primCar(_35reg1997);
Obj _35reg1999 = primCdr(_35reg1998);
Obj _35reg2000 = primIsCons(_35reg1999);
if (True == _35reg2000) {
Obj _35reg2001 = primCdr(closureRef(co, 0));
Obj _35reg2002 = primCar(_35reg2001);
Obj _35reg2003 = primCdr(_35reg2002);
Obj _35reg2004 = primCar(_35reg2003);
Obj args = _35reg2004;
Obj _35reg2005 = primCdr(closureRef(co, 0));
Obj _35reg2006 = primCar(_35reg2005);
Obj _35reg2007 = primCdr(_35reg2006);
Obj _35reg2008 = primCdr(_35reg2007);
Obj _35reg2009 = primIsCons(_35reg2008);
if (True == _35reg2009) {
Obj _35reg2010 = primCdr(closureRef(co, 0));
Obj _35reg2011 = primCar(_35reg2010);
Obj _35reg2012 = primCdr(_35reg2011);
Obj _35reg2013 = primCdr(_35reg2012);
Obj _35reg2014 = primCar(_35reg2013);
Obj body = _35reg2014;
Obj _35reg2015 = primCdr(closureRef(co, 0));
Obj _35reg2016 = primCar(_35reg2015);
Obj _35reg2017 = primCdr(_35reg2016);
Obj _35reg2018 = primCdr(_35reg2017);
Obj _35reg2019 = primCdr(_35reg2018);
Obj _35reg2020 = primEQ(Nil, _35reg2019);
if (True == _35reg2020) {
Obj _35reg2021 = primCdr(closureRef(co, 0));
Obj _35reg2022 = primCdr(_35reg2021);
Obj frees = _35reg2022;
Obj next = closureRef(co, 1);
pushCont(co, _35clofun2981, 3, args, frees, next);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify"));
co->args[1] = body;
co->args[2] = globalRef(intern("cora/lib/toc/include.id"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1295;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2981(struct Cora* co) {
Obj _35val2023 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj frees = co->stack[co->base + 1];
Obj next = co->stack[co->base + 2];
Obj _35reg2024 = primCons(_35val2023, Nil);
Obj _35reg2025 = primCons(args, _35reg2024);
Obj _35reg2026 = primCons(intern("lambda"), _35reg2025);
Obj _35reg2027 = primCons(_35reg2026, frees);
Obj _35reg2028 = primCons(intern("%closure"), _35reg2027);
co->args[0] = next;
co->args[1] = _35reg2028;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2979(struct Cora* co) {
Obj _35cc1296 = makeNative(_35clofun2980, 0, 0);
Obj _35reg1981 = primIsCons(closureRef(co, 0));
if (True == _35reg1981) {
Obj _35reg1982 = primCar(closureRef(co, 0));
Obj f = _35reg1982;
Obj _35reg1983 = primCdr(closureRef(co, 0));
Obj args = _35reg1983;
Obj next = closureRef(co, 1);
Obj _35reg1984 = primCons(f, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.tailify-list"));
co->args[1] = _35reg1984;
co->args[2] = Nil;
co->args[3] = next;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1296;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2980(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2972(struct Cora* co) {
Obj x = co->args[1];
Obj _35reg1978 = primCons(x, Nil);
Obj _35reg1979 = primCons(intern("return"), _35reg1978);
co->args[1] = _35reg1979;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2957(struct Cora* co) {
Obj _35p1281 = co->args[1];
Obj _35p1282 = co->args[2];
Obj _35cc1283 = makeNative(_35clofun2958, 0, 2, _35p1281, _35p1282);
Obj __ = _35p1281;
Obj x = _35p1282;
pushCont(co, _35clofun2971, 2, x, _35cc1283);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2971(struct Cora* co) {
Obj _35val1976 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1283 = co->stack[co->base + 1];
if (True == _35val1976) {
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1283;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2958(struct Cora* co) {
Obj _35cc1284 = makeNative(_35clofun2959, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj var = closureRef(co, 1);
Obj _35reg1971 = primIsSymbol(var);
if (True == _35reg1971) {
pushCont(co, _35clofun2970, 1, var);
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = var;
co->args[2] = fvs;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1284;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2970(struct Cora* co) {
Obj _35val1972 = co->args[1];
Obj var = co->stack[co->base + 0];
Obj pos = _35val1972;
Obj _35reg1973 = primEQ(makeNumber(-1), pos);
if (True == _35reg1973) {
co->args[1] = var;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg1974 = primCons(pos, Nil);
Obj _35reg1975 = primCons(intern("%closure-ref"), _35reg1974);
co->args[1] = _35reg1975;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun2959(struct Cora* co) {
Obj _35cc1285 = makeNative(_35clofun2960, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg1942 = primIsCons(closureRef(co, 1));
if (True == _35reg1942) {
Obj _35reg1943 = primCar(closureRef(co, 1));
Obj _35reg1944 = primEQ(intern("lambda"), _35reg1943);
if (True == _35reg1944) {
Obj _35reg1945 = primCdr(closureRef(co, 1));
Obj _35reg1946 = primIsCons(_35reg1945);
if (True == _35reg1946) {
Obj _35reg1947 = primCdr(closureRef(co, 1));
Obj _35reg1948 = primCar(_35reg1947);
Obj args = _35reg1948;
Obj _35reg1949 = primCdr(closureRef(co, 1));
Obj _35reg1950 = primCdr(_35reg1949);
Obj _35reg1951 = primIsCons(_35reg1950);
if (True == _35reg1951) {
Obj _35reg1952 = primCdr(closureRef(co, 1));
Obj _35reg1953 = primCdr(_35reg1952);
Obj _35reg1954 = primCar(_35reg1953);
Obj body = _35reg1954;
Obj _35reg1955 = primCdr(closureRef(co, 1));
Obj _35reg1956 = primCdr(_35reg1955);
Obj _35reg1957 = primCdr(_35reg1956);
Obj _35reg1958 = primEQ(Nil, _35reg1957);
if (True == _35reg1958) {
Obj _35reg1959 = primCons(body, Nil);
Obj _35reg1960 = primCons(args, _35reg1959);
Obj _35reg1961 = primCons(intern("lambda"), _35reg1960);
pushCont(co, _35clofun2966, 3, body, args, fvs);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = _35reg1961;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1285;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2966(struct Cora* co) {
Obj _35val1962 = co->args[1];
Obj body = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj fvs = co->stack[co->base + 2];
Obj fvs1 = _35val1962;
pushCont(co, _35clofun2967, 3, args, fvs, fvs1);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs1;
co->args[2] = body;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2967(struct Cora* co) {
Obj _35val1963 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj fvs = co->stack[co->base + 1];
Obj fvs1 = co->stack[co->base + 2];
Obj _35reg1964 = primCons(_35val1963, Nil);
Obj _35reg1965 = primCons(args, _35reg1964);
Obj _35reg1966 = primCons(intern("lambda"), _35reg1965);
pushCont(co, _35clofun2968, 2, fvs1, _35reg1966);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2968(struct Cora* co) {
Obj _35val1967 = co->args[1];
Obj fvs1 = co->stack[co->base + 0];
Obj _35reg1966 = co->stack[co->base + 1];
pushCont(co, _35clofun2969, 1, _35reg1966);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1967;
co->args[2] = fvs1;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2969(struct Cora* co) {
Obj _35val1968 = co->args[1];
Obj _35reg1966 = co->stack[co->base + 0];
Obj _35reg1969 = primCons(_35reg1966, _35val1968);
Obj _35reg1970 = primCons(intern("%closure"), _35reg1969);
co->args[1] = _35reg1970;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2960(struct Cora* co) {
Obj _35cc1286 = makeNative(_35clofun2961, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj fvs = closureRef(co, 0);
Obj _35reg1910 = primIsCons(closureRef(co, 1));
if (True == _35reg1910) {
Obj _35reg1911 = primCar(closureRef(co, 1));
Obj _35reg1912 = primEQ(intern("let"), _35reg1911);
if (True == _35reg1912) {
Obj _35reg1913 = primCdr(closureRef(co, 1));
Obj _35reg1914 = primIsCons(_35reg1913);
if (True == _35reg1914) {
Obj _35reg1915 = primCdr(closureRef(co, 1));
Obj _35reg1916 = primCar(_35reg1915);
Obj a = _35reg1916;
Obj _35reg1917 = primCdr(closureRef(co, 1));
Obj _35reg1918 = primCdr(_35reg1917);
Obj _35reg1919 = primIsCons(_35reg1918);
if (True == _35reg1919) {
Obj _35reg1920 = primCdr(closureRef(co, 1));
Obj _35reg1921 = primCdr(_35reg1920);
Obj _35reg1922 = primCar(_35reg1921);
Obj b = _35reg1922;
Obj _35reg1923 = primCdr(closureRef(co, 1));
Obj _35reg1924 = primCdr(_35reg1923);
Obj _35reg1925 = primCdr(_35reg1924);
Obj _35reg1926 = primIsCons(_35reg1925);
if (True == _35reg1926) {
Obj _35reg1927 = primCdr(closureRef(co, 1));
Obj _35reg1928 = primCdr(_35reg1927);
Obj _35reg1929 = primCdr(_35reg1928);
Obj _35reg1930 = primCar(_35reg1929);
Obj c = _35reg1930;
Obj _35reg1931 = primCdr(closureRef(co, 1));
Obj _35reg1932 = primCdr(_35reg1931);
Obj _35reg1933 = primCdr(_35reg1932);
Obj _35reg1934 = primCdr(_35reg1933);
Obj _35reg1935 = primEQ(Nil, _35reg1934);
if (True == _35reg1935) {
pushCont(co, _35clofun2964, 3, fvs, c, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->args[2] = b;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1286;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2964(struct Cora* co) {
Obj _35val1936 = co->args[1];
Obj fvs = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj a = co->stack[co->base + 2];
pushCont(co, _35clofun2965, 2, _35val1936, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->args[2] = c;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2965(struct Cora* co) {
Obj _35val1937 = co->args[1];
Obj _35val1936 = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj _35reg1938 = primCons(_35val1937, Nil);
Obj _35reg1939 = primCons(_35val1936, _35reg1938);
Obj _35reg1940 = primCons(a, _35reg1939);
Obj _35reg1941 = primCons(intern("let"), _35reg1940);
co->args[1] = _35reg1941;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2961(struct Cora* co) {
Obj _35cc1287 = makeNative(_35clofun2962, 0, 0);
Obj fvs = closureRef(co, 0);
Obj _35reg1905 = primIsCons(closureRef(co, 1));
if (True == _35reg1905) {
Obj _35reg1906 = primCar(closureRef(co, 1));
Obj f = _35reg1906;
Obj _35reg1907 = primCdr(closureRef(co, 1));
Obj args = _35reg1907;
pushCont(co, _35clofun2963, 2, f, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.closure-convert"));
co->args[1] = fvs;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1287;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2963(struct Cora* co) {
Obj _35val1908 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj _35reg1909 = primCons(f, args);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1908;
co->args[2] = _35reg1909;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2962(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2934(struct Cora* co) {
Obj _35p1268 = co->args[1];
Obj _35cc1269 = makeNative(_35clofun2935, 0, 1, _35p1268);
Obj x = _35p1268;
pushCont(co, _35clofun2956, 1, _35cc1269);
co->args[0] = globalRef(intern("cora/lib/toc/include.convert-protect?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2956(struct Cora* co) {
Obj _35val1903 = co->args[1];
Obj _35cc1269 = co->stack[co->base + 0];
if (True == _35val1903) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1269;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2935(struct Cora* co) {
Obj _35cc1270 = makeNative(_35clofun2936, 0, 1, closureRef(co, 0));
Obj x = closureRef(co, 0);
Obj _35reg1901 = primIsSymbol(x);
if (True == _35reg1901) {
Obj _35reg1902 = primCons(x, Nil);
co->args[1] = _35reg1902;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1270;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2936(struct Cora* co) {
Obj _35cc1271 = makeNative(_35clofun2937, 0, 1, closureRef(co, 0));
Obj _35reg1883 = primIsCons(closureRef(co, 0));
if (True == _35reg1883) {
Obj _35reg1884 = primCar(closureRef(co, 0));
Obj _35reg1885 = primEQ(intern("lambda"), _35reg1884);
if (True == _35reg1885) {
Obj _35reg1886 = primCdr(closureRef(co, 0));
Obj _35reg1887 = primIsCons(_35reg1886);
if (True == _35reg1887) {
Obj _35reg1888 = primCdr(closureRef(co, 0));
Obj _35reg1889 = primCar(_35reg1888);
Obj args = _35reg1889;
Obj _35reg1890 = primCdr(closureRef(co, 0));
Obj _35reg1891 = primCdr(_35reg1890);
Obj _35reg1892 = primIsCons(_35reg1891);
if (True == _35reg1892) {
Obj _35reg1893 = primCdr(closureRef(co, 0));
Obj _35reg1894 = primCdr(_35reg1893);
Obj _35reg1895 = primCar(_35reg1894);
Obj body = _35reg1895;
Obj _35reg1896 = primCdr(closureRef(co, 0));
Obj _35reg1897 = primCdr(_35reg1896);
Obj _35reg1898 = primCdr(_35reg1897);
Obj _35reg1899 = primEQ(Nil, _35reg1898);
if (True == _35reg1899) {
pushCont(co, _35clofun2955, 1, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1271;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2955(struct Cora* co) {
Obj _35val1900 = co->args[1];
Obj args = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val1900;
co->args[2] = args;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2937(struct Cora* co) {
Obj _35cc1272 = makeNative(_35clofun2938, 0, 1, closureRef(co, 0));
Obj _35reg1853 = primIsCons(closureRef(co, 0));
if (True == _35reg1853) {
Obj _35reg1854 = primCar(closureRef(co, 0));
Obj _35reg1855 = primEQ(intern("if"), _35reg1854);
if (True == _35reg1855) {
Obj _35reg1856 = primCdr(closureRef(co, 0));
Obj _35reg1857 = primIsCons(_35reg1856);
if (True == _35reg1857) {
Obj _35reg1858 = primCdr(closureRef(co, 0));
Obj _35reg1859 = primCar(_35reg1858);
Obj x = _35reg1859;
Obj _35reg1860 = primCdr(closureRef(co, 0));
Obj _35reg1861 = primCdr(_35reg1860);
Obj _35reg1862 = primIsCons(_35reg1861);
if (True == _35reg1862) {
Obj _35reg1863 = primCdr(closureRef(co, 0));
Obj _35reg1864 = primCdr(_35reg1863);
Obj _35reg1865 = primCar(_35reg1864);
Obj y = _35reg1865;
Obj _35reg1866 = primCdr(closureRef(co, 0));
Obj _35reg1867 = primCdr(_35reg1866);
Obj _35reg1868 = primCdr(_35reg1867);
Obj _35reg1869 = primIsCons(_35reg1868);
if (True == _35reg1869) {
Obj _35reg1870 = primCdr(closureRef(co, 0));
Obj _35reg1871 = primCdr(_35reg1870);
Obj _35reg1872 = primCdr(_35reg1871);
Obj _35reg1873 = primCar(_35reg1872);
Obj z = _35reg1873;
Obj _35reg1874 = primCdr(closureRef(co, 0));
Obj _35reg1875 = primCdr(_35reg1874);
Obj _35reg1876 = primCdr(_35reg1875);
Obj _35reg1877 = primCdr(_35reg1876);
Obj _35reg1878 = primEQ(Nil, _35reg1877);
if (True == _35reg1878) {
Obj _35reg1879 = primCons(z, Nil);
Obj _35reg1880 = primCons(y, _35reg1879);
Obj _35reg1881 = primCons(x, _35reg1880);
pushCont(co, _35clofun2954, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg1881;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1272;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2954(struct Cora* co) {
Obj _35val1882 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val1882;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2938(struct Cora* co) {
Obj _35cc1273 = makeNative(_35clofun2939, 0, 1, closureRef(co, 0));
Obj _35reg1833 = primIsCons(closureRef(co, 0));
if (True == _35reg1833) {
Obj _35reg1834 = primCar(closureRef(co, 0));
Obj _35reg1835 = primEQ(intern("do"), _35reg1834);
if (True == _35reg1835) {
Obj _35reg1836 = primCdr(closureRef(co, 0));
Obj _35reg1837 = primIsCons(_35reg1836);
if (True == _35reg1837) {
Obj _35reg1838 = primCdr(closureRef(co, 0));
Obj _35reg1839 = primCar(_35reg1838);
Obj x = _35reg1839;
Obj _35reg1840 = primCdr(closureRef(co, 0));
Obj _35reg1841 = primCdr(_35reg1840);
Obj _35reg1842 = primIsCons(_35reg1841);
if (True == _35reg1842) {
Obj _35reg1843 = primCdr(closureRef(co, 0));
Obj _35reg1844 = primCdr(_35reg1843);
Obj _35reg1845 = primCar(_35reg1844);
Obj y = _35reg1845;
Obj _35reg1846 = primCdr(closureRef(co, 0));
Obj _35reg1847 = primCdr(_35reg1846);
Obj _35reg1848 = primCdr(_35reg1847);
Obj _35reg1849 = primEQ(Nil, _35reg1848);
if (True == _35reg1849) {
Obj _35reg1850 = primCons(y, Nil);
Obj _35reg1851 = primCons(x, _35reg1850);
pushCont(co, _35clofun2953, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg1851;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1273;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2953(struct Cora* co) {
Obj _35val1852 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val1852;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2939(struct Cora* co) {
Obj _35cc1274 = makeNative(_35clofun2940, 0, 1, closureRef(co, 0));
Obj _35reg1803 = primIsCons(closureRef(co, 0));
if (True == _35reg1803) {
Obj _35reg1804 = primCar(closureRef(co, 0));
Obj _35reg1805 = primEQ(intern("let"), _35reg1804);
if (True == _35reg1805) {
Obj _35reg1806 = primCdr(closureRef(co, 0));
Obj _35reg1807 = primIsCons(_35reg1806);
if (True == _35reg1807) {
Obj _35reg1808 = primCdr(closureRef(co, 0));
Obj _35reg1809 = primCar(_35reg1808);
Obj a = _35reg1809;
Obj _35reg1810 = primCdr(closureRef(co, 0));
Obj _35reg1811 = primCdr(_35reg1810);
Obj _35reg1812 = primIsCons(_35reg1811);
if (True == _35reg1812) {
Obj _35reg1813 = primCdr(closureRef(co, 0));
Obj _35reg1814 = primCdr(_35reg1813);
Obj _35reg1815 = primCar(_35reg1814);
Obj b = _35reg1815;
Obj _35reg1816 = primCdr(closureRef(co, 0));
Obj _35reg1817 = primCdr(_35reg1816);
Obj _35reg1818 = primCdr(_35reg1817);
Obj _35reg1819 = primIsCons(_35reg1818);
if (True == _35reg1819) {
Obj _35reg1820 = primCdr(closureRef(co, 0));
Obj _35reg1821 = primCdr(_35reg1820);
Obj _35reg1822 = primCdr(_35reg1821);
Obj _35reg1823 = primCar(_35reg1822);
Obj c = _35reg1823;
Obj _35reg1824 = primCdr(closureRef(co, 0));
Obj _35reg1825 = primCdr(_35reg1824);
Obj _35reg1826 = primCdr(_35reg1825);
Obj _35reg1827 = primCdr(_35reg1826);
Obj _35reg1828 = primEQ(Nil, _35reg1827);
if (True == _35reg1828) {
pushCont(co, _35clofun2950, 2, c, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = b;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1274;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2950(struct Cora* co) {
Obj _35val1829 = co->args[1];
Obj c = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
pushCont(co, _35clofun2951, 2, a, _35val1829);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = c;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2951(struct Cora* co) {
Obj _35val1830 = co->args[1];
Obj a = co->stack[co->base + 0];
Obj _35val1829 = co->stack[co->base + 1];
Obj _35reg1831 = primCons(a, Nil);
pushCont(co, _35clofun2952, 1, _35val1829);
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val1830;
co->args[2] = _35reg1831;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2952(struct Cora* co) {
Obj _35val1832 = co->args[1];
Obj _35val1829 = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = _35val1829;
co->args[2] = _35val1832;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2940(struct Cora* co) {
Obj _35cc1275 = makeNative(_35clofun2941, 0, 1, closureRef(co, 0));
Obj _35reg1793 = primIsCons(closureRef(co, 0));
if (True == _35reg1793) {
Obj _35reg1794 = primCar(closureRef(co, 0));
Obj _35reg1795 = primEQ(intern("%closure"), _35reg1794);
if (True == _35reg1795) {
Obj _35reg1796 = primCdr(closureRef(co, 0));
Obj _35reg1797 = primIsCons(_35reg1796);
if (True == _35reg1797) {
Obj _35reg1798 = primCdr(closureRef(co, 0));
Obj _35reg1799 = primCar(_35reg1798);
Obj lam = _35reg1799;
Obj _35reg1800 = primCdr(closureRef(co, 0));
Obj _35reg1801 = primCdr(_35reg1800);
Obj more = _35reg1801;
Obj _35reg1802 = primCons(lam, more);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = _35reg1802;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1275;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1275;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1275;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2941(struct Cora* co) {
Obj _35cc1276 = makeNative(_35clofun2942, 0, 1, closureRef(co, 0));
Obj _35reg1783 = primIsCons(closureRef(co, 0));
if (True == _35reg1783) {
Obj _35reg1784 = primCar(closureRef(co, 0));
Obj _35reg1785 = primEQ(intern("return"), _35reg1784);
if (True == _35reg1785) {
Obj _35reg1786 = primCdr(closureRef(co, 0));
Obj _35reg1787 = primIsCons(_35reg1786);
if (True == _35reg1787) {
Obj _35reg1788 = primCdr(closureRef(co, 0));
Obj _35reg1789 = primCar(_35reg1788);
Obj x = _35reg1789;
Obj _35reg1790 = primCdr(closureRef(co, 0));
Obj _35reg1791 = primCdr(_35reg1790);
Obj _35reg1792 = primEQ(Nil, _35reg1791);
if (True == _35reg1792) {
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1276;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1276;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1276;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1276;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2942(struct Cora* co) {
Obj _35cc1277 = makeNative(_35clofun2943, 0, 1, closureRef(co, 0));
Obj _35reg1763 = primIsCons(closureRef(co, 0));
if (True == _35reg1763) {
Obj _35reg1764 = primCar(closureRef(co, 0));
Obj _35reg1765 = primEQ(intern("call"), _35reg1764);
if (True == _35reg1765) {
Obj _35reg1766 = primCdr(closureRef(co, 0));
Obj _35reg1767 = primIsCons(_35reg1766);
if (True == _35reg1767) {
Obj _35reg1768 = primCdr(closureRef(co, 0));
Obj _35reg1769 = primCar(_35reg1768);
Obj exp = _35reg1769;
Obj _35reg1770 = primCdr(closureRef(co, 0));
Obj _35reg1771 = primCdr(_35reg1770);
Obj _35reg1772 = primIsCons(_35reg1771);
if (True == _35reg1772) {
Obj _35reg1773 = primCdr(closureRef(co, 0));
Obj _35reg1774 = primCdr(_35reg1773);
Obj _35reg1775 = primCar(_35reg1774);
Obj cont = _35reg1775;
Obj _35reg1776 = primCdr(closureRef(co, 0));
Obj _35reg1777 = primCdr(_35reg1776);
Obj _35reg1778 = primCdr(_35reg1777);
Obj _35reg1779 = primEQ(Nil, _35reg1778);
if (True == _35reg1779) {
Obj _35reg1780 = primCons(cont, Nil);
Obj _35reg1781 = primCons(exp, _35reg1780);
pushCont(co, _35clofun2949, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg1781;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1277;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2949(struct Cora* co) {
Obj _35val1782 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val1782;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2943(struct Cora* co) {
Obj _35cc1278 = makeNative(_35clofun2944, 0, 1, closureRef(co, 0));
Obj _35reg1753 = primIsCons(closureRef(co, 0));
if (True == _35reg1753) {
Obj _35reg1754 = primCar(closureRef(co, 0));
Obj _35reg1755 = primEQ(intern("tailcall"), _35reg1754);
if (True == _35reg1755) {
Obj _35reg1756 = primCdr(closureRef(co, 0));
Obj _35reg1757 = primIsCons(_35reg1756);
if (True == _35reg1757) {
Obj _35reg1758 = primCdr(closureRef(co, 0));
Obj _35reg1759 = primCar(_35reg1758);
Obj exp = _35reg1759;
Obj _35reg1760 = primCdr(closureRef(co, 0));
Obj _35reg1761 = primCdr(_35reg1760);
Obj _35reg1762 = primEQ(Nil, _35reg1761);
if (True == _35reg1762) {
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = exp;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1278;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1278;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1278;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1278;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2944(struct Cora* co) {
Obj _35cc1279 = makeNative(_35clofun2945, 0, 1, closureRef(co, 0));
Obj _35reg1735 = primIsCons(closureRef(co, 0));
if (True == _35reg1735) {
Obj _35reg1736 = primCar(closureRef(co, 0));
Obj _35reg1737 = primEQ(intern("continuation"), _35reg1736);
if (True == _35reg1737) {
Obj _35reg1738 = primCdr(closureRef(co, 0));
Obj _35reg1739 = primIsCons(_35reg1738);
if (True == _35reg1739) {
Obj _35reg1740 = primCdr(closureRef(co, 0));
Obj _35reg1741 = primCar(_35reg1740);
Obj arg = _35reg1741;
Obj _35reg1742 = primCdr(closureRef(co, 0));
Obj _35reg1743 = primCdr(_35reg1742);
Obj _35reg1744 = primIsCons(_35reg1743);
if (True == _35reg1744) {
Obj _35reg1745 = primCdr(closureRef(co, 0));
Obj _35reg1746 = primCdr(_35reg1745);
Obj _35reg1747 = primCar(_35reg1746);
Obj body = _35reg1747;
Obj _35reg1748 = primCdr(closureRef(co, 0));
Obj _35reg1749 = primCdr(_35reg1748);
Obj _35reg1750 = primCdr(_35reg1749);
Obj _35reg1751 = primEQ(Nil, _35reg1750);
if (True == _35reg1751) {
pushCont(co, _35clofun2948, 1, arg);
co->args[0] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[1] = body;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1279;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2948(struct Cora* co) {
Obj _35val1752 = co->args[1];
Obj arg = co->stack[co->base + 0];
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = _35val1752;
co->args[2] = arg;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2945(struct Cora* co) {
Obj _35cc1280 = makeNative(_35clofun2946, 0, 0);
Obj _35reg1730 = primIsCons(closureRef(co, 0));
if (True == _35reg1730) {
Obj _35reg1731 = primCar(closureRef(co, 0));
Obj f = _35reg1731;
Obj _35reg1732 = primCdr(closureRef(co, 0));
Obj args = _35reg1732;
Obj _35reg1733 = primCons(f, args);
pushCont(co, _35clofun2947, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = globalRef(intern("cora/lib/toc/include.free-vars"));
co->args[2] = _35reg1733;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1280;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2947(struct Cora* co) {
Obj _35val1734 = co->args[1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = globalRef(intern("cora/lib/toc/include.union"));
co->args[2] = Nil;
co->args[3] = _35val1734;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2946(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2927(struct Cora* co) {
Obj _35p1261 = co->args[1];
Obj _35cc1262 = makeNative(_35clofun2928, 0, 1, _35p1261);
Obj _35reg1719 = primIsCons(_35p1261);
if (True == _35reg1719) {
Obj _35reg1720 = primCar(_35p1261);
Obj _35reg1721 = primEQ(intern("%const"), _35reg1720);
if (True == _35reg1721) {
Obj _35reg1722 = primCdr(_35p1261);
Obj _35reg1723 = primIsCons(_35reg1722);
if (True == _35reg1723) {
Obj _35reg1724 = primCdr(_35p1261);
Obj _35reg1725 = primCar(_35reg1724);
Obj x = _35reg1725;
Obj _35reg1726 = primCdr(_35p1261);
Obj _35reg1727 = primCdr(_35reg1726);
Obj _35reg1728 = primEQ(Nil, _35reg1727);
if (True == _35reg1728) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1262;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1262;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1262;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1262;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2928(struct Cora* co) {
Obj _35cc1263 = makeNative(_35clofun2929, 0, 1, closureRef(co, 0));
Obj _35reg1709 = primIsCons(closureRef(co, 0));
if (True == _35reg1709) {
Obj _35reg1710 = primCar(closureRef(co, 0));
Obj _35reg1711 = primEQ(intern("%global"), _35reg1710);
if (True == _35reg1711) {
Obj _35reg1712 = primCdr(closureRef(co, 0));
Obj _35reg1713 = primIsCons(_35reg1712);
if (True == _35reg1713) {
Obj _35reg1714 = primCdr(closureRef(co, 0));
Obj _35reg1715 = primCar(_35reg1714);
Obj x = _35reg1715;
Obj _35reg1716 = primCdr(closureRef(co, 0));
Obj _35reg1717 = primCdr(_35reg1716);
Obj _35reg1718 = primEQ(Nil, _35reg1717);
if (True == _35reg1718) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1263;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1263;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1263;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1263;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2929(struct Cora* co) {
Obj _35cc1264 = makeNative(_35clofun2930, 0, 1, closureRef(co, 0));
Obj _35reg1699 = primIsCons(closureRef(co, 0));
if (True == _35reg1699) {
Obj _35reg1700 = primCar(closureRef(co, 0));
Obj _35reg1701 = primEQ(intern("%builtin"), _35reg1700);
if (True == _35reg1701) {
Obj _35reg1702 = primCdr(closureRef(co, 0));
Obj _35reg1703 = primIsCons(_35reg1702);
if (True == _35reg1703) {
Obj _35reg1704 = primCdr(closureRef(co, 0));
Obj _35reg1705 = primCar(_35reg1704);
Obj op = _35reg1705;
Obj _35reg1706 = primCdr(closureRef(co, 0));
Obj _35reg1707 = primCdr(_35reg1706);
Obj _35reg1708 = primEQ(Nil, _35reg1707);
if (True == _35reg1708) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1264;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1264;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1264;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1264;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2930(struct Cora* co) {
Obj _35cc1265 = makeNative(_35clofun2931, 0, 1, closureRef(co, 0));
Obj _35reg1689 = primIsCons(closureRef(co, 0));
if (True == _35reg1689) {
Obj _35reg1690 = primCar(closureRef(co, 0));
Obj _35reg1691 = primEQ(intern("quote"), _35reg1690);
if (True == _35reg1691) {
Obj _35reg1692 = primCdr(closureRef(co, 0));
Obj _35reg1693 = primIsCons(_35reg1692);
if (True == _35reg1693) {
Obj _35reg1694 = primCdr(closureRef(co, 0));
Obj _35reg1695 = primCar(_35reg1694);
Obj x = _35reg1695;
Obj _35reg1696 = primCdr(closureRef(co, 0));
Obj _35reg1697 = primCdr(_35reg1696);
Obj _35reg1698 = primEQ(Nil, _35reg1697);
if (True == _35reg1698) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1265;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1265;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1265;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1265;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2931(struct Cora* co) {
Obj _35cc1266 = makeNative(_35clofun2932, 0, 1, closureRef(co, 0));
Obj _35reg1679 = primIsCons(closureRef(co, 0));
if (True == _35reg1679) {
Obj _35reg1680 = primCar(closureRef(co, 0));
Obj _35reg1681 = primEQ(intern("%closure-ref"), _35reg1680);
if (True == _35reg1681) {
Obj _35reg1682 = primCdr(closureRef(co, 0));
Obj _35reg1683 = primIsCons(_35reg1682);
if (True == _35reg1683) {
Obj _35reg1684 = primCdr(closureRef(co, 0));
Obj _35reg1685 = primCar(_35reg1684);
Obj __ = _35reg1685;
Obj _35reg1686 = primCdr(closureRef(co, 0));
Obj _35reg1687 = primCdr(_35reg1686);
Obj _35reg1688 = primEQ(Nil, _35reg1687);
if (True == _35reg1688) {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1266;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1266;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1266;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1266;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2932(struct Cora* co) {
Obj _35cc1267 = makeNative(_35clofun2933, 0, 0);
Obj x = closureRef(co, 0);
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2933(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2921(struct Cora* co) {
Obj _35p1256 = co->args[1];
Obj _35p1257 = co->args[2];
Obj _35cc1258 = makeNative(_35clofun2922, 0, 2, _35p1256, _35p1257);
Obj _35reg1677 = primEQ(Nil, _35p1256);
if (True == _35reg1677) {
Obj __ = _35p1257;
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1258;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2922(struct Cora* co) {
Obj _35cc1259 = makeNative(_35clofun2923, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1673 = primIsCons(closureRef(co, 0));
if (True == _35reg1673) {
Obj _35reg1674 = primCar(closureRef(co, 0));
Obj x = _35reg1674;
Obj _35reg1675 = primCdr(closureRef(co, 0));
Obj y = _35reg1675;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun2926, 3, y, s2, _35cc1259);
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1259;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2926(struct Cora* co) {
Obj _35val1676 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj s2 = co->stack[co->base + 1];
Obj _35cc1259 = co->stack[co->base + 2];
if (True == _35val1676) {
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = y;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1259;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2923(struct Cora* co) {
Obj _35cc1260 = makeNative(_35clofun2924, 0, 0);
Obj _35reg1668 = primIsCons(closureRef(co, 0));
if (True == _35reg1668) {
Obj _35reg1669 = primCar(closureRef(co, 0));
Obj x = _35reg1669;
Obj _35reg1670 = primCdr(closureRef(co, 0));
Obj y = _35reg1670;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun2925, 1, x);
co->args[0] = globalRef(intern("cora/lib/toc/include.diff"));
co->args[1] = y;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1260;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2925(struct Cora* co) {
Obj _35val1671 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg1672 = primCons(x, _35val1671);
co->args[1] = _35reg1672;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2924(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2915(struct Cora* co) {
Obj _35p1251 = co->args[1];
Obj _35p1252 = co->args[2];
Obj _35cc1253 = makeNative(_35clofun2916, 0, 2, _35p1251, _35p1252);
Obj _35reg1666 = primEQ(Nil, _35p1251);
if (True == _35reg1666) {
Obj s2 = _35p1252;
co->args[1] = s2;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1253;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2916(struct Cora* co) {
Obj _35cc1254 = makeNative(_35clofun2917, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj _35reg1662 = primIsCons(closureRef(co, 0));
if (True == _35reg1662) {
Obj _35reg1663 = primCar(closureRef(co, 0));
Obj x = _35reg1663;
Obj _35reg1664 = primCdr(closureRef(co, 0));
Obj y = _35reg1664;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun2920, 3, y, s2, _35cc1254);
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1254;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2920(struct Cora* co) {
Obj _35val1665 = co->args[1];
Obj y = co->stack[co->base + 0];
Obj s2 = co->stack[co->base + 1];
Obj _35cc1254 = co->stack[co->base + 2];
if (True == _35val1665) {
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = y;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1254;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2917(struct Cora* co) {
Obj _35cc1255 = makeNative(_35clofun2918, 0, 0);
Obj _35reg1657 = primIsCons(closureRef(co, 0));
if (True == _35reg1657) {
Obj _35reg1658 = primCar(closureRef(co, 0));
Obj x = _35reg1658;
Obj _35reg1659 = primCdr(closureRef(co, 0));
Obj y = _35reg1659;
Obj s2 = closureRef(co, 1);
pushCont(co, _35clofun2919, 1, x);
co->args[0] = globalRef(intern("cora/lib/toc/include.union"));
co->args[1] = y;
co->args[2] = s2;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1255;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2919(struct Cora* co) {
Obj _35val1660 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35reg1661 = primCons(x, _35val1660);
co->args[1] = _35reg1661;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2918(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2885(struct Cora* co) {
Obj _35p1240 = co->args[1];
Obj _35p1241 = co->args[2];
Obj _35cc1242 = makeNative(_35clofun2886, 0, 2, _35p1240, _35p1241);
Obj __ = _35p1240;
Obj x = _35p1241;
pushCont(co, _35clofun2912, 2, x, _35cc1242);
co->args[0] = globalRef(intern("number?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2912(struct Cora* co) {
Obj _35val1642 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1242 = co->stack[co->base + 1];
if (True == _35val1642) {
if (True == True) {
Obj _35reg1643 = primCons(x, Nil);
Obj _35reg1644 = primCons(intern("%const"), _35reg1643);
co->args[1] = _35reg1644;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
Obj _35reg1645 = primIsString(x);
if (True == _35reg1645) {
if (True == True) {
Obj _35reg1646 = primCons(x, Nil);
Obj _35reg1647 = primCons(intern("%const"), _35reg1646);
co->args[1] = _35reg1647;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun2913, 2, x, _35cc1242);
co->args[0] = globalRef(intern("boolean?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun2913(struct Cora* co) {
Obj _35val1648 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1242 = co->stack[co->base + 1];
if (True == _35val1648) {
if (True == True) {
Obj _35reg1649 = primCons(x, Nil);
Obj _35reg1650 = primCons(intern("%const"), _35reg1649);
co->args[1] = _35reg1650;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
pushCont(co, _35clofun2914, 2, x, _35cc1242);
co->args[0] = globalRef(intern("null?"));
co->args[1] = x;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2914(struct Cora* co) {
Obj _35val1651 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj _35cc1242 = co->stack[co->base + 1];
if (True == _35val1651) {
if (True == True) {
Obj _35reg1652 = primCons(x, Nil);
Obj _35reg1653 = primCons(intern("%const"), _35reg1652);
co->args[1] = _35reg1653;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
if (True == False) {
Obj _35reg1654 = primCons(x, Nil);
Obj _35reg1655 = primCons(intern("%const"), _35reg1654);
co->args[1] = _35reg1655;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1242;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun2886(struct Cora* co) {
Obj _35cc1243 = makeNative(_35clofun2887, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj __ = closureRef(co, 0);
Obj _35reg1630 = primIsCons(closureRef(co, 1));
if (True == _35reg1630) {
Obj _35reg1631 = primCar(closureRef(co, 1));
Obj _35reg1632 = primEQ(intern("quote"), _35reg1631);
if (True == _35reg1632) {
Obj _35reg1633 = primCdr(closureRef(co, 1));
Obj _35reg1634 = primIsCons(_35reg1633);
if (True == _35reg1634) {
Obj _35reg1635 = primCdr(closureRef(co, 1));
Obj _35reg1636 = primCar(_35reg1635);
Obj x = _35reg1636;
Obj _35reg1637 = primCdr(closureRef(co, 1));
Obj _35reg1638 = primCdr(_35reg1637);
Obj _35reg1639 = primEQ(Nil, _35reg1638);
if (True == _35reg1639) {
Obj _35reg1640 = primCons(x, Nil);
Obj _35reg1641 = primCons(intern("%const"), _35reg1640);
co->args[1] = _35reg1641;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1243;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1243;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1243;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1243;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2887(struct Cora* co) {
Obj _35cc1244 = makeNative(_35clofun2888, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1626 = primIsSymbol(x);
if (True == _35reg1626) {
pushCont(co, _35clofun2911, 1, x);
co->args[0] = globalRef(intern("elem?"));
co->args[1] = x;
co->args[2] = env;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1244;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2911(struct Cora* co) {
Obj _35val1627 = co->args[1];
Obj x = co->stack[co->base + 0];
if (True == _35val1627) {
co->args[1] = x;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
Obj _35reg1628 = primCons(x, Nil);
Obj _35reg1629 = primCons(intern("%global"), _35reg1628);
co->args[1] = _35reg1629;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun2888(struct Cora* co) {
Obj _35cc1245 = makeNative(_35clofun2889, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1604 = primIsCons(closureRef(co, 1));
if (True == _35reg1604) {
Obj _35reg1605 = primCar(closureRef(co, 1));
Obj _35reg1606 = primEQ(intern("lambda"), _35reg1605);
if (True == _35reg1606) {
Obj _35reg1607 = primCdr(closureRef(co, 1));
Obj _35reg1608 = primIsCons(_35reg1607);
if (True == _35reg1608) {
Obj _35reg1609 = primCdr(closureRef(co, 1));
Obj _35reg1610 = primCar(_35reg1609);
Obj args = _35reg1610;
Obj _35reg1611 = primCdr(closureRef(co, 1));
Obj _35reg1612 = primCdr(_35reg1611);
Obj _35reg1613 = primIsCons(_35reg1612);
if (True == _35reg1613) {
Obj _35reg1614 = primCdr(closureRef(co, 1));
Obj _35reg1615 = primCdr(_35reg1614);
Obj _35reg1616 = primCar(_35reg1615);
Obj body = _35reg1616;
Obj _35reg1617 = primCdr(closureRef(co, 1));
Obj _35reg1618 = primCdr(_35reg1617);
Obj _35reg1619 = primCdr(_35reg1618);
Obj _35reg1620 = primEQ(Nil, _35reg1619);
if (True == _35reg1620) {
pushCont(co, _35clofun2909, 2, body, args);
co->args[0] = globalRef(intern("append"));
co->args[1] = args;
co->args[2] = env;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1245;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2909(struct Cora* co) {
Obj _35val1621 = co->args[1];
Obj body = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
pushCont(co, _35clofun2910, 1, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = _35val1621;
co->args[2] = body;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2910(struct Cora* co) {
Obj _35val1622 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg1623 = primCons(_35val1622, Nil);
Obj _35reg1624 = primCons(args, _35reg1623);
Obj _35reg1625 = primCons(intern("lambda"), _35reg1624);
co->args[1] = _35reg1625;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2889(struct Cora* co) {
Obj _35cc1246 = makeNative(_35clofun2890, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1597 = primIsCons(closureRef(co, 1));
if (True == _35reg1597) {
Obj _35reg1598 = primCar(closureRef(co, 1));
Obj _35reg1599 = primEQ(intern("if"), _35reg1598);
if (True == _35reg1599) {
Obj _35reg1600 = primCdr(closureRef(co, 1));
Obj args = _35reg1600;
pushCont(co, _35clofun2907, 1, args);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1246;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1246;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2907(struct Cora* co) {
Obj _35val1601 = co->args[1];
Obj args = co->stack[co->base + 0];
pushCont(co, _35clofun2908, 0);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1601;
co->args[2] = args;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2908(struct Cora* co) {
Obj _35val1602 = co->args[1];
Obj _35reg1603 = primCons(intern("if"), _35val1602);
co->args[1] = _35reg1603;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2890(struct Cora* co) {
Obj _35cc1247 = makeNative(_35clofun2891, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1575 = primIsCons(closureRef(co, 1));
if (True == _35reg1575) {
Obj _35reg1576 = primCar(closureRef(co, 1));
Obj _35reg1577 = primEQ(intern("do"), _35reg1576);
if (True == _35reg1577) {
Obj _35reg1578 = primCdr(closureRef(co, 1));
Obj _35reg1579 = primIsCons(_35reg1578);
if (True == _35reg1579) {
Obj _35reg1580 = primCdr(closureRef(co, 1));
Obj _35reg1581 = primCar(_35reg1580);
Obj x = _35reg1581;
Obj _35reg1582 = primCdr(closureRef(co, 1));
Obj _35reg1583 = primCdr(_35reg1582);
Obj _35reg1584 = primIsCons(_35reg1583);
if (True == _35reg1584) {
Obj _35reg1585 = primCdr(closureRef(co, 1));
Obj _35reg1586 = primCdr(_35reg1585);
Obj _35reg1587 = primCar(_35reg1586);
Obj y = _35reg1587;
Obj _35reg1588 = primCdr(closureRef(co, 1));
Obj _35reg1589 = primCdr(_35reg1588);
Obj _35reg1590 = primCdr(_35reg1589);
Obj _35reg1591 = primEQ(Nil, _35reg1590);
if (True == _35reg1591) {
pushCont(co, _35clofun2905, 2, env, y);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1247;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2905(struct Cora* co) {
Obj _35val1592 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
pushCont(co, _35clofun2906, 1, _35val1592);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = y;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2906(struct Cora* co) {
Obj _35val1593 = co->args[1];
Obj _35val1592 = co->stack[co->base + 0];
Obj _35reg1594 = primCons(_35val1593, Nil);
Obj _35reg1595 = primCons(_35val1592, _35reg1594);
Obj _35reg1596 = primCons(intern("do"), _35reg1595);
co->args[1] = _35reg1596;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2891(struct Cora* co) {
Obj _35cc1248 = makeNative(_35clofun2892, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1542 = primIsCons(closureRef(co, 1));
if (True == _35reg1542) {
Obj _35reg1543 = primCar(closureRef(co, 1));
Obj _35reg1544 = primEQ(intern("let"), _35reg1543);
if (True == _35reg1544) {
Obj _35reg1545 = primCdr(closureRef(co, 1));
Obj _35reg1546 = primIsCons(_35reg1545);
if (True == _35reg1546) {
Obj _35reg1547 = primCdr(closureRef(co, 1));
Obj _35reg1548 = primCar(_35reg1547);
Obj a = _35reg1548;
Obj _35reg1549 = primCdr(closureRef(co, 1));
Obj _35reg1550 = primCdr(_35reg1549);
Obj _35reg1551 = primIsCons(_35reg1550);
if (True == _35reg1551) {
Obj _35reg1552 = primCdr(closureRef(co, 1));
Obj _35reg1553 = primCdr(_35reg1552);
Obj _35reg1554 = primCar(_35reg1553);
Obj b = _35reg1554;
Obj _35reg1555 = primCdr(closureRef(co, 1));
Obj _35reg1556 = primCdr(_35reg1555);
Obj _35reg1557 = primCdr(_35reg1556);
Obj _35reg1558 = primIsCons(_35reg1557);
if (True == _35reg1558) {
Obj _35reg1559 = primCdr(closureRef(co, 1));
Obj _35reg1560 = primCdr(_35reg1559);
Obj _35reg1561 = primCdr(_35reg1560);
Obj _35reg1562 = primCar(_35reg1561);
Obj c = _35reg1562;
Obj _35reg1563 = primCdr(closureRef(co, 1));
Obj _35reg1564 = primCdr(_35reg1563);
Obj _35reg1565 = primCdr(_35reg1564);
Obj _35reg1566 = primCdr(_35reg1565);
Obj _35reg1567 = primEQ(Nil, _35reg1566);
if (True == _35reg1567) {
pushCont(co, _35clofun2903, 3, env, c, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = b;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1248;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2903(struct Cora* co) {
Obj _35val1568 = co->args[1];
Obj env = co->stack[co->base + 0];
Obj c = co->stack[co->base + 1];
Obj a = co->stack[co->base + 2];
Obj _35reg1569 = primCons(a, env);
pushCont(co, _35clofun2904, 2, _35val1568, a);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = _35reg1569;
co->args[2] = c;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2904(struct Cora* co) {
Obj _35val1570 = co->args[1];
Obj _35val1568 = co->stack[co->base + 0];
Obj a = co->stack[co->base + 1];
Obj _35reg1571 = primCons(_35val1570, Nil);
Obj _35reg1572 = primCons(_35val1568, _35reg1571);
Obj _35reg1573 = primCons(a, _35reg1572);
Obj _35reg1574 = primCons(intern("let"), _35reg1573);
co->args[1] = _35reg1574;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2892(struct Cora* co) {
Obj _35cc1249 = makeNative(_35clofun2893, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj env = closureRef(co, 0);
Obj _35reg1522 = primIsCons(closureRef(co, 1));
if (True == _35reg1522) {
Obj _35reg1523 = primCar(closureRef(co, 1));
Obj op = _35reg1523;
Obj _35reg1524 = primCdr(closureRef(co, 1));
Obj args = _35reg1524;
pushCont(co, _35clofun2896, 4, op, args, env, _35cc1249);
co->args[0] = globalRef(intern("builtin?"));
co->args[1] = op;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1249;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2896(struct Cora* co) {
Obj _35val1525 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj _35cc1249 = co->stack[co->base + 3];
if (True == _35val1525) {
pushCont(co, _35clofun2897, 3, op, args, env);
co->args[0] = globalRef(intern("cora/lib/toc/include.builtin->args"));
co->args[1] = op;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1249;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2897(struct Cora* co) {
Obj _35val1526 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj required = _35val1526;
pushCont(co, _35clofun2898, 4, required, op, args, env);
co->args[0] = globalRef(intern("length"));
co->args[1] = args;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2898(struct Cora* co) {
Obj _35val1527 = co->args[1];
Obj required = co->stack[co->base + 0];
Obj op = co->stack[co->base + 1];
Obj args = co->stack[co->base + 2];
Obj env = co->stack[co->base + 3];
Obj provided = _35val1527;
Obj _35reg1528 = primEQ(required, provided);
if (True == _35reg1528) {
Obj _35reg1529 = primCons(op, Nil);
Obj _35reg1530 = primCons(intern("%builtin"), _35reg1529);
pushCont(co, _35clofun2899, 2, args, _35reg1530);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
Obj _35reg1534 = primGT(required, provided);
if (True == _35reg1534) {
Obj _35reg1535 = primSub(required, provided);
pushCont(co, _35clofun2901, 3, op, args, env);
co->args[0] = globalRef(intern("cora/lib/toc/include.temp-list"));
co->args[1] = _35reg1535;
co->args[2] = Nil;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("primitive call mismatch");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}
}

void _35clofun2901(struct Cora* co) {
Obj _35val1536 = co->args[1];
Obj op = co->stack[co->base + 0];
Obj args = co->stack[co->base + 1];
Obj env = co->stack[co->base + 2];
Obj tmp = _35val1536;
Obj _35reg1537 = primCons(op, args);
pushCont(co, _35clofun2902, 2, tmp, env);
co->args[0] = globalRef(intern("append"));
co->args[1] = _35reg1537;
co->args[2] = tmp;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2902(struct Cora* co) {
Obj _35val1538 = co->args[1];
Obj tmp = co->stack[co->base + 0];
Obj env = co->stack[co->base + 1];
Obj _35reg1539 = primCons(_35val1538, Nil);
Obj _35reg1540 = primCons(tmp, _35reg1539);
Obj _35reg1541 = primCons(intern("lambda"), _35reg1540);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->args[2] = _35reg1541;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2899(struct Cora* co) {
Obj _35val1531 = co->args[1];
Obj args = co->stack[co->base + 0];
Obj _35reg1530 = co->stack[co->base + 1];
pushCont(co, _35clofun2900, 1, _35reg1530);
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1531;
co->args[2] = args;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2900(struct Cora* co) {
Obj _35val1532 = co->args[1];
Obj _35reg1530 = co->stack[co->base + 0];
Obj _35reg1533 = primCons(_35reg1530, _35val1532);
co->args[1] = _35reg1533;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2893(struct Cora* co) {
Obj _35cc1250 = makeNative(_35clofun2894, 0, 0);
Obj env = closureRef(co, 0);
Obj ls = closureRef(co, 1);
pushCont(co, _35clofun2895, 1, ls);
co->args[0] = globalRef(intern("cora/lib/toc/include.parse"));
co->args[1] = env;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2895(struct Cora* co) {
Obj _35val1521 = co->args[1];
Obj ls = co->stack[co->base + 0];
co->args[0] = globalRef(intern("map"));
co->args[1] = _35val1521;
co->args[2] = ls;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2894(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2882(struct Cora* co) {
Obj _35p1236 = co->args[1];
Obj _35p1237 = co->args[2];
Obj _35cc1238 = makeNative(_35clofun2883, 0, 2, _35p1236, _35p1237);
Obj _35reg1519 = primEQ(makeNumber(0), _35p1236);
if (True == _35reg1519) {
Obj res = _35p1237;
co->args[1] = res;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1238;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2883(struct Cora* co) {
Obj _35cc1239 = makeNative(_35clofun2884, 0, 0);
Obj n = closureRef(co, 0);
Obj res = closureRef(co, 1);
Obj _35reg1516 = primSub(n, makeNumber(1));
Obj _35reg1517 = primGenSym(intern("tmp"));
Obj _35reg1518 = primCons(_35reg1517, res);
co->args[0] = globalRef(intern("cora/lib/toc/include.temp-list"));
co->args[1] = _35reg1516;
co->args[2] = _35reg1518;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2884(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2879(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun2880, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2880(struct Cora* co) {
Obj _35val1513 = co->args[1];
Obj find = _35val1513;
pushCont(co, _35clofun2881, 1, find);
co->args[0] = globalRef(intern("null?"));
co->args[1] = find;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2881(struct Cora* co) {
Obj _35val1514 = co->args[1];
Obj find = co->stack[co->base + 0];
if (True == _35val1514) {
co->args[1] = makeString1("ERROR");
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = globalRef(intern("cadr"));
co->args[1] = find;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2876(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun2877, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2877(struct Cora* co) {
Obj _35val1510 = co->args[1];
Obj find = _35val1510;
pushCont(co, _35clofun2878, 1, find);
co->args[0] = globalRef(intern("null?"));
co->args[1] = find;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2878(struct Cora* co) {
Obj _35val1511 = co->args[1];
Obj find = co->stack[co->base + 0];
if (True == _35val1511) {
co->args[1] = makeString1("ERROR");
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = globalRef(intern("caddr"));
co->args[1] = find;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2873(struct Cora* co) {
Obj x = co->args[1];
pushCont(co, _35clofun2874, 0);
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = x;
co->args[2] = globalRef(intern("cora/lib/toc/include.*builtin-prims*"));
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2874(struct Cora* co) {
Obj _35val1506 = co->args[1];
pushCont(co, _35clofun2875, 0);
co->args[0] = globalRef(intern("null?"));
co->args[1] = _35val1506;
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2875(struct Cora* co) {
Obj _35val1507 = co->args[1];
Obj _35reg1508 = primNot(_35val1507);
co->args[1] = _35reg1508;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}

void _35clofun2869(struct Cora* co) {
Obj _35p1232 = co->args[1];
Obj _35p1233 = co->args[2];
Obj _35cc1234 = makeNative(_35clofun2870, 0, 2, _35p1232, _35p1233);
Obj x = _35p1232;
Obj _35reg1435 = primEQ(Nil, _35p1233);
if (True == _35reg1435) {
co->args[1] = False;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1234;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2870(struct Cora* co) {
Obj _35cc1235 = makeNative(_35clofun2871, 0, 0);
Obj x = closureRef(co, 0);
Obj _35reg1430 = primIsCons(closureRef(co, 1));
if (True == _35reg1430) {
Obj _35reg1431 = primCar(closureRef(co, 1));
Obj hd = _35reg1431;
Obj _35reg1432 = primCdr(closureRef(co, 1));
Obj tl = _35reg1432;
pushCont(co, _35clofun2872, 2, x, tl);
co->args[0] = globalRef(intern("cora/lib/toc/include.index"));
co->args[1] = x;
co->args[2] = hd;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1235;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2872(struct Cora* co) {
Obj _35val1433 = co->args[1];
Obj x = co->stack[co->base + 0];
Obj tl = co->stack[co->base + 1];
Obj _35reg1434 = primLT(_35val1433, makeNumber(0));
if (True == _35reg1434) {
co->args[0] = globalRef(intern("cora/lib/toc/include.exist-in-env"));
co->args[1] = x;
co->args[2] = tl;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[1] = True;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
}
}

void _35clofun2871(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2868(struct Cora* co) {
Obj x = co->args[1];
Obj l = co->args[2];
co->args[0] = globalRef(intern("cora/lib/toc/include.pos-in-list0"));
co->args[1] = makeNumber(0);
co->args[2] = x;
co->args[3] = l;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2864(struct Cora* co) {
Obj _35p1226 = co->args[1];
Obj _35p1227 = co->args[2];
Obj _35p1228 = co->args[3];
Obj _35cc1229 = makeNative(_35clofun2865, 0, 3, _35p1226, _35p1227, _35p1228);
Obj __ = _35p1226;
Obj x = _35p1227;
Obj _35reg1427 = primEQ(Nil, _35p1228);
if (True == _35reg1427) {
co->args[1] = makeNumber(-1);
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1229;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2865(struct Cora* co) {
Obj _35cc1230 = makeNative(_35clofun2866, 0, 3, closureRef(co, 0), closureRef(co, 1), closureRef(co, 2));
Obj pos = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1423 = primIsCons(closureRef(co, 2));
if (True == _35reg1423) {
Obj _35reg1424 = primCar(closureRef(co, 2));
Obj a = _35reg1424;
Obj _35reg1425 = primCdr(closureRef(co, 2));
Obj b = _35reg1425;
Obj _35reg1426 = primEQ(x, a);
if (True == _35reg1426) {
co->args[1] = pos;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1230;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1230;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2866(struct Cora* co) {
Obj _35cc1231 = makeNative(_35clofun2867, 0, 0);
Obj pos = closureRef(co, 0);
Obj x = closureRef(co, 1);
Obj _35reg1419 = primIsCons(closureRef(co, 2));
if (True == _35reg1419) {
Obj _35reg1420 = primCar(closureRef(co, 2));
Obj a = _35reg1420;
Obj _35reg1421 = primCdr(closureRef(co, 2));
Obj b = _35reg1421;
Obj _35reg1422 = primAdd(pos, makeNumber(1));
co->args[0] = globalRef(intern("cora/lib/toc/include.pos-in-list0"));
co->args[1] = _35reg1422;
co->args[2] = x;
co->args[3] = b;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1231;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2867(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2860(struct Cora* co) {
Obj _35p1221 = co->args[1];
Obj _35p1222 = co->args[2];
Obj _35p1223 = co->args[3];
Obj _35cc1224 = makeNative(_35clofun2861, 0, 3, _35p1221, _35p1222, _35p1223);
Obj f = _35p1221;
Obj acc = _35p1222;
Obj _35reg1417 = primEQ(Nil, _35p1223);
if (True == _35reg1417) {
co->args[1] = acc;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1224;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2861(struct Cora* co) {
Obj _35cc1225 = makeNative(_35clofun2862, 0, 0);
Obj f = closureRef(co, 0);
Obj acc = closureRef(co, 1);
Obj _35reg1413 = primIsCons(closureRef(co, 2));
if (True == _35reg1413) {
Obj _35reg1414 = primCar(closureRef(co, 2));
Obj x = _35reg1414;
Obj _35reg1415 = primCdr(closureRef(co, 2));
Obj y = _35reg1415;
pushCont(co, _35clofun2863, 2, f, y);
co->args[0] = f;
co->args[1] = acc;
co->args[2] = x;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1225;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2863(struct Cora* co) {
Obj _35val1416 = co->args[1];
Obj f = co->stack[co->base + 0];
Obj y = co->stack[co->base + 1];
co->args[0] = globalRef(intern("cora/lib/toc/include.foldl"));
co->args[1] = f;
co->args[2] = _35val1416;
co->args[3] = y;
co->nargs = 4;
if (nativeRequired(co->args[0]) == 3) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2862(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

void _35clofun2856(struct Cora* co) {
Obj _35p1216 = co->args[1];
Obj _35p1217 = co->args[2];
Obj _35cc1218 = makeNative(_35clofun2857, 0, 2, _35p1216, _35p1217);
Obj var = _35p1216;
Obj _35reg1411 = primEQ(Nil, _35p1217);
if (True == _35reg1411) {
co->args[1] = Nil;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1218;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2857(struct Cora* co) {
Obj _35cc1219 = makeNative(_35clofun2858, 0, 2, closureRef(co, 0), closureRef(co, 1));
Obj var = closureRef(co, 0);
Obj _35reg1401 = primIsCons(closureRef(co, 1));
if (True == _35reg1401) {
Obj _35reg1402 = primCar(closureRef(co, 1));
Obj _35reg1403 = primIsCons(_35reg1402);
if (True == _35reg1403) {
Obj _35reg1404 = primCar(closureRef(co, 1));
Obj _35reg1405 = primCar(_35reg1404);
Obj x = _35reg1405;
Obj _35reg1406 = primCar(closureRef(co, 1));
Obj _35reg1407 = primCdr(_35reg1406);
Obj y = _35reg1407;
Obj _35reg1408 = primCdr(closureRef(co, 1));
Obj __ = _35reg1408;
Obj _35reg1409 = primEQ(var, x);
if (True == _35reg1409) {
Obj _35reg1410 = primCons(x, y);
co->args[1] = _35reg1410;
popStack(&co->callstack, &co->pc, &co->base, &co->pos, &co->stack, &co->frees);
return;
} else {
co->args[0] = _35cc1219;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1219;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
} else {
co->args[0] = _35cc1219;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2858(struct Cora* co) {
Obj _35cc1220 = makeNative(_35clofun2859, 0, 0);
Obj var = closureRef(co, 0);
Obj _35reg1398 = primIsCons(closureRef(co, 1));
if (True == _35reg1398) {
Obj _35reg1399 = primCar(closureRef(co, 1));
Obj __ = _35reg1399;
Obj _35reg1400 = primCdr(closureRef(co, 1));
Obj y = _35reg1400;
co->args[0] = globalRef(intern("cora/lib/toc/include.assq"));
co->args[1] = var;
co->args[2] = y;
co->nargs = 3;
if (nativeRequired(co->args[0]) == 2) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
} else {
co->args[0] = _35cc1220;
co->nargs = 1;
if (nativeRequired(co->args[0]) == 0) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}
}

void _35clofun2859(struct Cora* co) {
co->args[0] = globalRef(intern("error"));
co->args[1] = makeString1("no match-help found!");
co->nargs = 2;
if (nativeRequired(co->args[0]) == 1) {
co->pc = nativeFuncPtr(co->args[0]);
co->frees = nativeData(co->args[0]);
} else {
co->pc = coraCall;
}
return;
}

