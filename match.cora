

(defun extract-rules1 (input current result)
  (match input
    ()	(reverse result)
    (list-rest '=> act 'where pred remain)
    (let pat (cons 'list (reverse current))
      (extract-rules1 remain () (cons (list 'where pred act) (cons pat result))))
    (list-rest '=> act remain)
    (let pat (cons 'list (reverse current))
      (extract-rules1 remain () (cons act (cons pat result))))
    (cons x y)	(extract-rules1 y (cons x current) result)))

(defun extract-rules (input)
  (extract-rules1 input () ()))

(defun rules-patterns (res rules)
  (if (null? rules)
      (reverse res)
      (rules-patterns (cons (car rules) res) (cddr rules))))

;; (rules-patterns () '((list 0) 1 (list n)
;;                      (* n (fact (- n 1)))))

(defun rules-arg-count (rules)
  (let pats (rules-patterns () rules)
    len (lambda (x) (length (cdr x)))
    counts (map len pats)
    n (car counts)
    dif (lambda (x) (not (= n x)))
    (if (not (null? (filter dif (cdr counts))))
        (error "inconsistent func rule args count")
        n)))

;; (rules-arg-count '((list 0) 1 (list n)
;;                    (* n (fact (- n 1)))))

(defun gen-parameters (n)
  (if (= n 0)
      ()
      (cons (gensym) (gen-parameters (- n 1)))))

;; (func fact
;;       0 N => N
;;       X N => (fact (- X 1) (* X N)))

;; (func my-reverse
;;       res () => res
;;       res (cons a b) => (my-reverse (cons a res) b))
