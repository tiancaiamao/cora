(defun shen.yacc (V1235) (cond ((and (cons? V1235) (and (= defcc (hd V1235)) (cons? (tl V1235)))) (shen.yacc->shen (hd (tl V1235)) (tl (tl V1235)))) (true (shen.f_error shen.yacc))))

(defun shen.yacc->shen (V1238 V1239) (let CCRules (shen.split_cc_rules true V1239 ()) (let CCBody (map (lambda X (shen.cc_body X)) CCRules) (let YaccCases (shen.yacc_cases CCBody) (cons define (cons V1238 (cons Stream (cons -> (cons (shen.kill-code YaccCases) ())))))))))

(defun shen.kill-code (V1241) (cond ((> (occurrences kill V1241) 0) (cons trap-error (cons V1241 (cons (cons lambda (cons E (cons (cons shen.analyse-kill (cons E ())) ()))) ())))) (true V1241)))

(defun kill () (simple-error "yacc kill"))

(defun shen.analyse-kill (V1243) (let String (error-to-string V1243) (if (= String "yacc kill") (fail) V1243)))

(defun shen.split_cc_rules (V1249 V1250 V1251) (cond ((and (= () V1250) (= () V1251)) ()) ((= () V1250) (cons (shen.split_cc_rule V1249 (reverse V1251) ()) ())) ((and (cons? V1250) (= ; (hd V1250))) (cons (shen.split_cc_rule V1249 (reverse V1251) ()) (shen.split_cc_rules V1249 (tl V1250) ()))) ((cons? V1250) (shen.split_cc_rules V1249 (tl V1250) (cons (hd V1250) V1251))) (true (shen.f_error shen.split_cc_rules))))

(defun shen.split_cc_rule (V1259 V1260 V1261) (cond ((and (cons? V1260) (and (= := (hd V1260)) (and (cons? (tl V1260)) (= () (tl (tl V1260)))))) (cons (reverse V1261) (tl V1260))) ((and (cons? V1260) (and (= := (hd V1260)) (and (cons? (tl V1260)) (and (cons? (tl (tl V1260))) (and (= where (hd (tl (tl V1260)))) (and (cons? (tl (tl (tl V1260)))) (= () (tl (tl (tl (tl V1260))))))))))) (cons (reverse V1261) (cons (cons where (cons (hd (tl (tl (tl V1260)))) (cons (hd (tl V1260)) ()))) ()))) ((= () V1260) (do (shen.semantic-completion-warning V1259 V1261) (shen.split_cc_rule V1259 (cons := (cons (shen.default_semantics (reverse V1261)) ())) V1261))) ((cons? V1260) (shen.split_cc_rule V1259 (tl V1260) (cons (hd V1260) V1261))) (true (shen.f_error shen.split_cc_rule))))

(defun shen.semantic-completion-warning (V1272 V1273) (cond ((= true V1272) (do (shen.prhush "warning: " (stoutput)) (do (for-each (lambda X (shen.prhush (shen.app X " " shen.a) (stoutput))) (reverse V1273)) (shen.prhush "has no semantics.
" (stoutput))))) (true shen.skip)))

(defun shen.default_semantics (V1275) (cond ((= () V1275) ()) ((and (cons? V1275) (and (= () (tl V1275)) (shen.grammar_symbol? (hd V1275)))) (hd V1275)) ((and (cons? V1275) (shen.grammar_symbol? (hd V1275))) (cons append (cons (hd V1275) (cons (shen.default_semantics (tl V1275)) ())))) ((cons? V1275) (cons cons (cons (hd V1275) (cons (shen.default_semantics (tl V1275)) ())))) (true (shen.f_error shen.default_semantics))))

(defun shen.grammar_symbol? (V1277) (and (symbol? V1277) (let Cs (shen.strip-pathname (explode V1277)) (and (= (hd Cs) "<") (= (hd (reverse Cs)) ">")))))

(defun shen.yacc_cases (V1279) (cond ((and (cons? V1279) (= () (tl V1279))) (hd V1279)) ((cons? V1279) (let P YaccParse (cons let (cons P (cons (hd V1279) (cons (cons if (cons (cons = (cons P (cons (cons fail ()) ()))) (cons (shen.yacc_cases (tl V1279)) (cons P ())))) ())))))) (true (shen.f_error shen.yacc_cases))))

(defun shen.cc_body (V1281) (cond ((and (cons? V1281) (and (cons? (tl V1281)) (= () (tl (tl V1281))))) (shen.syntax (hd V1281) Stream (hd (tl V1281)))) (true (shen.f_error shen.cc_body))))

(defun shen.syntax (V1285 V1286 V1287) (cond ((and (= () V1285) (and (cons? V1287) (and (= where (hd V1287)) (and (cons? (tl V1287)) (and (cons? (tl (tl V1287))) (= () (tl (tl (tl V1287))))))))) (cons if (cons (shen.semantics (hd (tl V1287))) (cons (cons shen.pair (cons (cons hd (cons V1286 ())) (cons (shen.semantics (hd (tl (tl V1287)))) ()))) (cons (cons fail ()) ()))))) ((= () V1285) (cons shen.pair (cons (cons hd (cons V1286 ())) (cons (shen.semantics V1287) ())))) ((cons? V1285) (if (shen.grammar_symbol? (hd V1285)) (shen.recursive_descent V1285 V1286 V1287) (if (variable? (hd V1285)) (shen.variable-match V1285 V1286 V1287) (if (shen.jump_stream? (hd V1285)) (shen.jump_stream V1285 V1286 V1287) (if (shen.terminal? (hd V1285)) (shen.check_stream V1285 V1286 V1287) (if (cons? (hd V1285)) (shen.list-stream (shen.decons (hd V1285)) (tl V1285) V1286 V1287) (simple-error (shen.app (hd V1285) " is not legal syntax
" shen.a)))))))) (true (shen.f_error shen.syntax))))

(defun shen.list-stream (V1292 V1293 V1294 V1295) (let Test (cons and (cons (cons cons? (cons (cons hd (cons V1294 ())) ())) (cons (cons cons? (cons (cons hd (cons (cons hd (cons V1294 ())) ())) ())) ()))) (let Placeholder (gensym shen.place) (let RunOn (shen.syntax V1293 (cons shen.pair (cons (cons tl (cons (cons hd (cons V1294 ())) ())) (cons (cons hd (cons (cons tl (cons V1294 ())) ())) ()))) V1295) (let Action (shen.insert-runon RunOn Placeholder (shen.syntax V1292 (cons shen.pair (cons (cons hd (cons (cons hd (cons V1294 ())) ())) (cons (cons hd (cons (cons tl (cons V1294 ())) ())) ()))) Placeholder)) (cons if (cons Test (cons Action (cons (cons fail ()) ())))))))))

(defun shen.decons (V1297) (cond ((and (cons? V1297) (and (= cons (hd V1297)) (and (cons? (tl V1297)) (and (cons? (tl (tl V1297))) (and (= () (hd (tl (tl V1297)))) (= () (tl (tl (tl V1297))))))))) (cons (hd (tl V1297)) ())) ((and (cons? V1297) (and (= cons (hd V1297)) (and (cons? (tl V1297)) (and (cons? (tl (tl V1297))) (= () (tl (tl (tl V1297)))))))) (cons (hd (tl V1297)) (shen.decons (hd (tl (tl V1297)))))) (true V1297)))

(defun shen.insert-runon (V1312 V1313 V1314) (cond ((and (cons? V1314) (and (= shen.pair (hd V1314)) (and (cons? (tl V1314)) (and (cons? (tl (tl V1314))) (and (= () (tl (tl (tl V1314)))) (= (hd (tl (tl V1314))) V1313)))))) V1312) ((cons? V1314) (map (lambda Z (shen.insert-runon V1312 V1313 Z)) V1314)) (true V1314)))

(defun shen.strip-pathname (V1320) (cond ((not (element? "." V1320)) V1320) ((cons? V1320) (shen.strip-pathname (tl V1320))) (true (shen.f_error shen.strip-pathname))))

(defun shen.recursive_descent (V1324 V1325 V1326) (cond ((cons? V1324) (let Test (cons (hd V1324) (cons V1325 ())) (let Action (shen.syntax (tl V1324) (concat Parse_ (hd V1324)) V1326) (let Else (cons fail ()) (cons let (cons (concat Parse_ (hd V1324)) (cons Test (cons (cons if (cons (cons not (cons (cons = (cons (cons fail ()) (cons (concat Parse_ (hd V1324)) ()))) ())) (cons Action (cons Else ())))) ())))))))) (true (shen.f_error shen.recursive_descent))))

(defun shen.variable-match (V1330 V1331 V1332) (cond ((cons? V1330) (let Test (cons cons? (cons (cons hd (cons V1331 ())) ())) (let Action (cons let (cons (concat Parse_ (hd V1330)) (cons (cons hd (cons (cons hd (cons V1331 ())) ())) (cons (shen.syntax (tl V1330) (cons shen.pair (cons (cons tl (cons (cons hd (cons V1331 ())) ())) (cons (cons shen.hdtl (cons V1331 ())) ()))) V1332) ())))) (let Else (cons fail ()) (cons if (cons Test (cons Action (cons Else ())))))))) (true (shen.f_error shen.variable-match))))

(defun shen.terminal? (V1342) (cond ((cons? V1342) false) ((variable? V1342) false) (true true)))

(defun shen.jump_stream? (V1348) (cond ((= V1348 _) true) (true false)))

(defun shen.check_stream (V1352 V1353 V1354) (cond ((cons? V1352) (let Test (cons and (cons (cons cons? (cons (cons hd (cons V1353 ())) ())) (cons (cons = (cons (hd V1352) (cons (cons hd (cons (cons hd (cons V1353 ())) ())) ()))) ()))) (let Action (shen.syntax (tl V1352) (cons shen.pair (cons (cons tl (cons (cons hd (cons V1353 ())) ())) (cons (cons shen.hdtl (cons V1353 ())) ()))) V1354) (let Else (cons fail ()) (cons if (cons Test (cons Action (cons Else ())))))))) (true (shen.f_error shen.check_stream))))

(defun shen.jump_stream (V1358 V1359 V1360) (cond ((cons? V1358) (let Test (cons cons? (cons (cons hd (cons V1359 ())) ())) (let Action (shen.syntax (tl V1358) (cons shen.pair (cons (cons tl (cons (cons hd (cons V1359 ())) ())) (cons (cons shen.hdtl (cons V1359 ())) ()))) V1360) (let Else (cons fail ()) (cons if (cons Test (cons Action (cons Else ())))))))) (true (shen.f_error shen.jump_stream))))

(defun shen.semantics (V1362) (cond ((= () V1362) ()) ((shen.grammar_symbol? V1362) (cons shen.hdtl (cons (concat Parse_ V1362) ()))) ((variable? V1362) (concat Parse_ V1362)) ((cons? V1362) (map (lambda Z (shen.semantics Z)) V1362)) (true V1362)))

(defun shen.snd-or-fail (V1370) (cond ((and (cons? V1370) (and (cons? (tl V1370)) (= () (tl (tl V1370))))) (hd (tl V1370))) (true (fail))))

(defun fail () shen.fail!)(defun shen.pair (V1373 V1374) (cons V1373 (cons V1374 ())))

(defun shen.hdtl (V1376) (hd (tl V1376)))

(defun <!> (V1384) (cond ((and (cons? V1384) (and (cons? (tl V1384)) (= () (tl (tl V1384))))) (cons () (cons (hd V1384) ()))) (true (fail))))

(defun <e> (V1390) (cond ((and (cons? V1390) (and (cons? (tl V1390)) (= () (tl (tl V1390))))) (cons (hd V1390) (cons () ()))) (true (shen.f_error <e>))))

