(defun macroexpand (V1909) (let Y (shen.compose (value *macros*) V1909) (if (= V1909 Y) V1909 (shen.walk (lambda Z (macroexpand Z)) Y))))

(defun shen.error-macro (V1911) (cond ((and (cons? V1911) (and (= error (hd V1911)) (cons? (tl V1911)))) (cons simple-error (cons (shen.mkstr (hd (tl V1911)) (tl (tl V1911))) ()))) (true V1911)))

(defun shen.output-macro (V1913) (cond ((and (cons? V1913) (and (= output (hd V1913)) (cons? (tl V1913)))) (cons shen.prhush (cons (shen.mkstr (hd (tl V1913)) (tl (tl V1913))) (cons (cons stoutput ()) ())))) ((and (cons? V1913) (and (= pr (hd V1913)) (and (cons? (tl V1913)) (= () (tl (tl V1913)))))) (cons pr (cons (hd (tl V1913)) (cons (cons stoutput ()) ())))) (true V1913)))

(defun shen.make-string-macro (V1915) (cond ((and (cons? V1915) (and (= make-string (hd V1915)) (cons? (tl V1915)))) (shen.mkstr (hd (tl V1915)) (tl (tl V1915)))) (true V1915)))

(defun shen.input-macro (V1917) (cond ((and (cons? V1917) (and (= lineread (hd V1917)) (= () (tl V1917)))) (cons lineread (cons (cons stinput ()) ()))) ((and (cons? V1917) (and (= input (hd V1917)) (= () (tl V1917)))) (cons input (cons (cons stinput ()) ()))) ((and (cons? V1917) (and (= read (hd V1917)) (= () (tl V1917)))) (cons read (cons (cons stinput ()) ()))) ((and (cons? V1917) (and (= input+ (hd V1917)) (and (cons? (tl V1917)) (= () (tl (tl V1917)))))) (cons input+ (cons (hd (tl V1917)) (cons (cons stinput ()) ())))) ((and (cons? V1917) (and (= read-byte (hd V1917)) (= () (tl V1917)))) (cons read-byte (cons (cons stinput ()) ()))) ((and (cons? V1917) (and (= read-char-code (hd V1917)) (= () (tl V1917)))) (cons read-char-code (cons (cons stinput ()) ()))) (true V1917)))

(defun shen.compose (V1920 V1921) (cond ((= () V1920) V1921) ((cons? V1920) (shen.compose (tl V1920) ((hd V1920) V1921))) (true (shen.f_error shen.compose))))

(defun shen.compile-macro (V1923) (cond ((and (cons? V1923) (and (= compile (hd V1923)) (and (cons? (tl V1923)) (and (cons? (tl (tl V1923))) (= () (tl (tl (tl V1923)))))))) (cons compile (cons (hd (tl V1923)) (cons (hd (tl (tl V1923))) (cons (cons lambda (cons E (cons (cons if (cons (cons cons? (cons E ())) (cons (cons error (cons "parse error here: ~S~%" (cons E ()))) (cons (cons error (cons "parse error~%" ())) ())))) ()))) ()))))) (true V1923)))

(defun shen.prolog-macro (V1925) (cond ((and (cons? V1925) (= prolog? (hd V1925))) (let F (gensym shen.f) (let Receive (shen.receive-terms (tl V1925)) (let PrologDef (eval (append (cons defprolog (cons F ())) (append Receive (append (cons <-- ()) (append (shen.pass-literals (tl V1925)) (cons ; ())))))) (let Query (cons F (append Receive (cons (cons shen.start-new-prolog-process ()) (cons (cons freeze (cons true ())) ())))) Query))))) (true V1925)))

(defun shen.receive-terms (V1931) (cond ((= () V1931) ()) ((and (cons? V1931) (and (cons? (hd V1931)) (and (= receive (hd (hd V1931))) (and (cons? (tl (hd V1931))) (= () (tl (tl (hd V1931)))))))) (cons (hd (tl (hd V1931))) (shen.receive-terms (tl V1931)))) ((cons? V1931) (shen.receive-terms (tl V1931))) (true (shen.f_error shen.receive-terms))))

(defun shen.pass-literals (V1935) (cond ((= () V1935) ()) ((and (cons? V1935) (and (cons? (hd V1935)) (and (= receive (hd (hd V1935))) (and (cons? (tl (hd V1935))) (= () (tl (tl (hd V1935)))))))) (shen.pass-literals (tl V1935))) ((cons? V1935) (cons (hd V1935) (shen.pass-literals (tl V1935)))) (true (shen.f_error shen.pass-literals))))

(defun shen.defprolog-macro (V1937) (cond ((and (cons? V1937) (and (= defprolog (hd V1937)) (cons? (tl V1937)))) (compile (lambda Y (shen.<defprolog> Y)) (tl V1937) (lambda Y (shen.prolog-error (hd (tl V1937)) Y)))) (true V1937)))

(defun shen.datatype-macro (V1939) (cond ((and (cons? V1939) (and (= datatype (hd V1939)) (cons? (tl V1939)))) (cons shen.process-datatype (cons (shen.intern-type (hd (tl V1939))) (cons (cons compile (cons (cons lambda (cons X (cons (cons shen.<datatype-rules> (cons X ())) ()))) (cons (shen.rcons_form (tl (tl V1939))) (cons (cons function (cons shen.datatype-error ())) ())))) ())))) (true V1939)))

(defun shen.intern-type (V1941) (intern (cn "type#" (str V1941))))

(defun shen.@s-macro (V1943) (cond ((and (cons? V1943) (and (= @s (hd V1943)) (and (cons? (tl V1943)) (and (cons? (tl (tl V1943))) (cons? (tl (tl (tl V1943)))))))) (cons @s (cons (hd (tl V1943)) (cons (shen.@s-macro (cons @s (tl (tl V1943)))) ())))) ((and (cons? V1943) (and (= @s (hd V1943)) (and (cons? (tl V1943)) (and (cons? (tl (tl V1943))) (and (= () (tl (tl (tl V1943)))) (string? (hd (tl V1943)))))))) (let E (explode (hd (tl V1943))) (if (> (length E) 1) (shen.@s-macro (cons @s (append E (tl (tl V1943))))) V1943))) (true V1943)))

(defun shen.synonyms-macro (V1945) (cond ((and (cons? V1945) (= synonyms (hd V1945))) (cons shen.synonyms-help (cons (shen.rcons_form (shen.curry-synonyms (tl V1945))) ()))) (true V1945)))

(defun shen.curry-synonyms (V1947) (map (lambda X (shen.curry-type X)) V1947))

(defun shen.nl-macro (V1949) (cond ((and (cons? V1949) (and (= nl (hd V1949)) (= () (tl V1949)))) (cons nl (cons 1 ()))) (true V1949)))

(defun shen.assoc-macro (V1951) (cond ((and (cons? V1951) (and (cons? (tl V1951)) (and (cons? (tl (tl V1951))) (and (cons? (tl (tl (tl V1951)))) (element? (hd V1951) (cons @p (cons @v (cons append (cons and (cons or (cons + (cons * (cons do ()))))))))))))) (cons (hd V1951) (cons (hd (tl V1951)) (cons (shen.assoc-macro (cons (hd V1951) (tl (tl V1951)))) ())))) (true V1951)))

(defun shen.let-macro (V1953) (cond ((and (cons? V1953) (and (= let (hd V1953)) (and (cons? (tl V1953)) (and (cons? (tl (tl V1953))) (and (cons? (tl (tl (tl V1953)))) (cons? (tl (tl (tl (tl V1953)))))))))) (cons let (cons (hd (tl V1953)) (cons (hd (tl (tl V1953))) (cons (shen.let-macro (cons let (tl (tl (tl V1953))))) ()))))) (true V1953)))

(defun shen.abs-macro (V1955) (cond ((and (cons? V1955) (and (= /. (hd V1955)) (and (cons? (tl V1955)) (and (cons? (tl (tl V1955))) (cons? (tl (tl (tl V1955)))))))) (cons lambda (cons (hd (tl V1955)) (cons (shen.abs-macro (cons /. (tl (tl V1955)))) ())))) ((and (cons? V1955) (and (= /. (hd V1955)) (and (cons? (tl V1955)) (and (cons? (tl (tl V1955))) (= () (tl (tl (tl V1955)))))))) (cons lambda (tl V1955))) (true V1955)))

(defun shen.cases-macro (V1959) (cond ((and (cons? V1959) (and (= cases (hd V1959)) (and (cons? (tl V1959)) (and (= true (hd (tl V1959))) (cons? (tl (tl V1959))))))) (hd (tl (tl V1959)))) ((and (cons? V1959) (and (= cases (hd V1959)) (and (cons? (tl V1959)) (and (cons? (tl (tl V1959))) (= () (tl (tl (tl V1959)))))))) (cons if (cons (hd (tl V1959)) (cons (hd (tl (tl V1959))) (cons (cons simple-error (cons "error: cases exhausted" ())) ()))))) ((and (cons? V1959) (and (= cases (hd V1959)) (and (cons? (tl V1959)) (cons? (tl (tl V1959)))))) (cons if (cons (hd (tl V1959)) (cons (hd (tl (tl V1959))) (cons (shen.cases-macro (cons cases (tl (tl (tl V1959))))) ()))))) ((and (cons? V1959) (and (= cases (hd V1959)) (and (cons? (tl V1959)) (= () (tl (tl V1959)))))) (simple-error "error: odd number of case elements
")) (true V1959)))

(defun shen.timer-macro (V1961) (cond ((and (cons? V1961) (and (= time (hd V1961)) (and (cons? (tl V1961)) (= () (tl (tl V1961)))))) (shen.let-macro (cons let (cons Start (cons (cons get-time (cons run ())) (cons Result (cons (hd (tl V1961)) (cons Finish (cons (cons get-time (cons run ())) (cons Time (cons (cons - (cons Finish (cons Start ()))) (cons Message (cons (cons shen.prhush (cons (cons cn (cons "
run time: " (cons (cons cn (cons (cons str (cons Time ())) (cons " secs
" ()))) ()))) (cons (cons stoutput ()) ()))) (cons Result ())))))))))))))) (true V1961)))

(defun shen.tuple-up (V1963) (cond ((cons? V1963) (cons @p (cons (hd V1963) (cons (shen.tuple-up (tl V1963)) ())))) (true V1963)))

(defun shen.put/get-macro (V1965) (cond ((and (cons? V1965) (and (= put (hd V1965)) (and (cons? (tl V1965)) (and (cons? (tl (tl V1965))) (and (cons? (tl (tl (tl V1965)))) (= () (tl (tl (tl (tl V1965)))))))))) (cons put (cons (hd (tl V1965)) (cons (hd (tl (tl V1965))) (cons (hd (tl (tl (tl V1965)))) (cons (cons value (cons *property-vector* ())) ())))))) ((and (cons? V1965) (and (= get (hd V1965)) (and (cons? (tl V1965)) (and (cons? (tl (tl V1965))) (= () (tl (tl (tl V1965)))))))) (cons get (cons (hd (tl V1965)) (cons (hd (tl (tl V1965))) (cons (cons value (cons *property-vector* ())) ()))))) ((and (cons? V1965) (and (= get/or (hd V1965)) (and (cons? (tl V1965)) (and (cons? (tl (tl V1965))) (and (cons? (tl (tl (tl V1965)))) (= () (tl (tl (tl (tl V1965)))))))))) (cons get/or (cons (hd (tl V1965)) (cons (hd (tl (tl V1965))) (cons (hd (tl (tl (tl V1965)))) (cons (cons value (cons *property-vector* ())) ())))))) ((and (cons? V1965) (and (= unput (hd V1965)) (and (cons? (tl V1965)) (and (cons? (tl (tl V1965))) (= () (tl (tl (tl V1965)))))))) (cons unput (cons (hd (tl V1965)) (cons (hd (tl (tl V1965))) (cons (cons value (cons *property-vector* ())) ()))))) (true V1965)))

(defun shen.function-macro (V1967) (cond ((and (cons? V1967) (and (= function (hd V1967)) (and (cons? (tl V1967)) (= () (tl (tl V1967)))))) (shen.function-abstraction (hd (tl V1967)) (arity (hd (tl V1967))))) (true V1967)))

(defun shen.function-abstraction (V1970 V1971) (cond ((= 0 V1971) (simple-error (shen.app V1970 " has no lambda form
" shen.a))) ((= -1 V1971) (cons function (cons V1970 ()))) (true (shen.function-abstraction-help V1970 V1971 ()))))

(defun shen.function-abstraction-help (V1975 V1976 V1977) (cond ((= 0 V1976) (cons V1975 V1977)) (true (let X (gensym V) (cons /. (cons X (cons (shen.function-abstraction-help V1975 (- V1976 1) (append V1977 (cons X ()))) ())))))))

(defun undefmacro (V1979) (let MacroReg (value shen.*macroreg*) (let Pos (shen.findpos V1979 MacroReg) (let Remove1 (set shen.*macroreg* (remove V1979 MacroReg)) (let Remove2 (set *macros* (shen.remove-nth Pos (value *macros*))) V1979)))))

(defun shen.findpos (V1989 V1990) (cond ((= () V1990) (simple-error (shen.app V1989 " is not a macro
" shen.a))) ((and (cons? V1990) (= (hd V1990) V1989)) 1) ((cons? V1990) (+ 1 (shen.findpos V1989 (tl V1990)))) (true (shen.f_error shen.findpos))))

(defun shen.remove-nth (V1995 V1996) (cond ((and (= 1 V1995) (cons? V1996)) (tl V1996)) ((cons? V1996) (cons (hd V1996) (shen.remove-nth (- V1995 1) (tl V1996)))) (true (shen.f_error shen.remove-nth))))

