(defun macroexpand (V2994) (let Y (shen.compose (value *macros*) V2994) (if (= V2994 Y) V2994 (shen.walk (lambda Z (macroexpand Z)) Y))))

(defun shen.error-macro (V2996) (cond ((and (cons? V2996) (and (= error (hd V2996)) (cons? (tl V2996)))) (cons simple-error (cons (shen.mkstr (hd (tl V2996)) (tl (tl V2996))) ()))) (true V2996)))

(defun shen.output-macro (V2998) (cond ((and (cons? V2998) (and (= output (hd V2998)) (cons? (tl V2998)))) (cons shen.prhush (cons (shen.mkstr (hd (tl V2998)) (tl (tl V2998))) (cons (cons stoutput ()) ())))) ((and (cons? V2998) (and (= pr (hd V2998)) (and (cons? (tl V2998)) (= () (tl (tl V2998)))))) (cons pr (cons (hd (tl V2998)) (cons (cons stoutput ()) ())))) (true V2998)))

(defun shen.make-string-macro (V3000) (cond ((and (cons? V3000) (and (= make-string (hd V3000)) (cons? (tl V3000)))) (shen.mkstr (hd (tl V3000)) (tl (tl V3000)))) (true V3000)))

(defun shen.input-macro (V3002) (cond ((and (cons? V3002) (and (= lineread (hd V3002)) (= () (tl V3002)))) (cons lineread (cons (cons stinput ()) ()))) ((and (cons? V3002) (and (= input (hd V3002)) (= () (tl V3002)))) (cons input (cons (cons stinput ()) ()))) ((and (cons? V3002) (and (= read (hd V3002)) (= () (tl V3002)))) (cons read (cons (cons stinput ()) ()))) ((and (cons? V3002) (and (= input+ (hd V3002)) (and (cons? (tl V3002)) (= () (tl (tl V3002)))))) (cons input+ (cons (hd (tl V3002)) (cons (cons stinput ()) ())))) ((and (cons? V3002) (and (= read-byte (hd V3002)) (= () (tl V3002)))) (cons read-byte (cons (cons stinput ()) ()))) ((and (cons? V3002) (and (= read-char-code (hd V3002)) (= () (tl V3002)))) (cons read-char-code (cons (cons stinput ()) ()))) (true V3002)))

(defun shen.compose (V3005 V3006) (cond ((= () V3005) V3006) ((cons? V3005) (shen.compose (tl V3005) ((hd V3005) V3006))) (true (shen.f_error shen.compose))))

(defun shen.compile-macro (V3008) (cond ((and (cons? V3008) (and (= compile (hd V3008)) (and (cons? (tl V3008)) (and (cons? (tl (tl V3008))) (= () (tl (tl (tl V3008)))))))) (cons compile (cons (hd (tl V3008)) (cons (hd (tl (tl V3008))) (cons (cons lambda (cons E (cons (cons if (cons (cons cons? (cons E ())) (cons (cons error (cons "parse error here: ~S~%" (cons E ()))) (cons (cons error (cons "parse error~%" ())) ())))) ()))) ()))))) (true V3008)))

(defun shen.prolog-macro (V3010) (cond ((and (cons? V3010) (= prolog? (hd V3010))) (let F (gensym shen.f) (let Receive (shen.receive-terms (tl V3010)) (let PrologDef (eval (append (cons defprolog (cons F ())) (append Receive (append (cons <-- ()) (append (shen.pass-literals (tl V3010)) (cons ; ())))))) (let Query (cons F (append Receive (cons (cons shen.start-new-prolog-process ()) (cons (cons freeze (cons true ())) ())))) Query))))) (true V3010)))

(defun shen.receive-terms (V3016) (cond ((= () V3016) ()) ((and (cons? V3016) (and (cons? (hd V3016)) (and (= receive (hd (hd V3016))) (and (cons? (tl (hd V3016))) (= () (tl (tl (hd V3016)))))))) (cons (hd (tl (hd V3016))) (shen.receive-terms (tl V3016)))) ((cons? V3016) (shen.receive-terms (tl V3016))) (true (shen.f_error shen.receive-terms))))

(defun shen.pass-literals (V3020) (cond ((= () V3020) ()) ((and (cons? V3020) (and (cons? (hd V3020)) (and (= receive (hd (hd V3020))) (and (cons? (tl (hd V3020))) (= () (tl (tl (hd V3020)))))))) (shen.pass-literals (tl V3020))) ((cons? V3020) (cons (hd V3020) (shen.pass-literals (tl V3020)))) (true (shen.f_error shen.pass-literals))))

(defun shen.defprolog-macro (V3022) (cond ((and (cons? V3022) (and (= defprolog (hd V3022)) (cons? (tl V3022)))) (compile (lambda Y (shen.<defprolog> Y)) (tl V3022) (lambda Y (shen.prolog-error (hd (tl V3022)) Y)))) (true V3022)))

(defun shen.datatype-macro (V3024) (cond ((and (cons? V3024) (and (= datatype (hd V3024)) (cons? (tl V3024)))) (cons shen.process-datatype (cons (shen.intern-type (hd (tl V3024))) (cons (cons compile (cons (cons lambda (cons X (cons (cons shen.<datatype-rules> (cons X ())) ()))) (cons (shen.rcons_form (tl (tl V3024))) (cons (cons function (cons shen.datatype-error ())) ())))) ())))) (true V3024)))

(defun shen.intern-type (V3026) (intern (cn "type#" (str V3026))))

(defun shen.@s-macro (V3028) (cond ((and (cons? V3028) (and (= @s (hd V3028)) (and (cons? (tl V3028)) (and (cons? (tl (tl V3028))) (cons? (tl (tl (tl V3028)))))))) (cons @s (cons (hd (tl V3028)) (cons (shen.@s-macro (cons @s (tl (tl V3028)))) ())))) ((and (cons? V3028) (and (= @s (hd V3028)) (and (cons? (tl V3028)) (and (cons? (tl (tl V3028))) (and (= () (tl (tl (tl V3028)))) (string? (hd (tl V3028)))))))) (let E (explode (hd (tl V3028))) (if (> (length E) 1) (shen.@s-macro (cons @s (append E (tl (tl V3028))))) V3028))) (true V3028)))

(defun shen.synonyms-macro (V3030) (cond ((and (cons? V3030) (= synonyms (hd V3030))) (cons shen.synonyms-help (cons (shen.rcons_form (shen.curry-synonyms (tl V3030))) ()))) (true V3030)))

(defun shen.curry-synonyms (V3032) (map (lambda X (shen.curry-type X)) V3032))

(defun shen.nl-macro (V3034) (cond ((and (cons? V3034) (and (= nl (hd V3034)) (= () (tl V3034)))) (cons nl (cons 1 ()))) (true V3034)))

(defun shen.assoc-macro (V3036) (cond ((and (cons? V3036) (and (cons? (tl V3036)) (and (cons? (tl (tl V3036))) (and (cons? (tl (tl (tl V3036)))) (element? (hd V3036) (cons @p (cons @v (cons append (cons and (cons or (cons + (cons * (cons do ()))))))))))))) (cons (hd V3036) (cons (hd (tl V3036)) (cons (shen.assoc-macro (cons (hd V3036) (tl (tl V3036)))) ())))) (true V3036)))

(defun shen.let-macro (V3038) (cond ((and (cons? V3038) (and (= let (hd V3038)) (and (cons? (tl V3038)) (and (cons? (tl (tl V3038))) (and (cons? (tl (tl (tl V3038)))) (cons? (tl (tl (tl (tl V3038)))))))))) (cons let (cons (hd (tl V3038)) (cons (hd (tl (tl V3038))) (cons (shen.let-macro (cons let (tl (tl (tl V3038))))) ()))))) (true V3038)))

(defun shen.abs-macro (V3040) (cond ((and (cons? V3040) (and (= /. (hd V3040)) (and (cons? (tl V3040)) (and (cons? (tl (tl V3040))) (cons? (tl (tl (tl V3040)))))))) (cons lambda (cons (hd (tl V3040)) (cons (shen.abs-macro (cons /. (tl (tl V3040)))) ())))) ((and (cons? V3040) (and (= /. (hd V3040)) (and (cons? (tl V3040)) (and (cons? (tl (tl V3040))) (= () (tl (tl (tl V3040)))))))) (cons lambda (tl V3040))) (true V3040)))

(defun shen.cases-macro (V3044) (cond ((and (cons? V3044) (and (= cases (hd V3044)) (and (cons? (tl V3044)) (and (= true (hd (tl V3044))) (cons? (tl (tl V3044))))))) (hd (tl (tl V3044)))) ((and (cons? V3044) (and (= cases (hd V3044)) (and (cons? (tl V3044)) (and (cons? (tl (tl V3044))) (= () (tl (tl (tl V3044)))))))) (cons if (cons (hd (tl V3044)) (cons (hd (tl (tl V3044))) (cons (cons simple-error (cons "error: cases exhausted" ())) ()))))) ((and (cons? V3044) (and (= cases (hd V3044)) (and (cons? (tl V3044)) (cons? (tl (tl V3044)))))) (cons if (cons (hd (tl V3044)) (cons (hd (tl (tl V3044))) (cons (shen.cases-macro (cons cases (tl (tl (tl V3044))))) ()))))) ((and (cons? V3044) (and (= cases (hd V3044)) (and (cons? (tl V3044)) (= () (tl (tl V3044)))))) (simple-error "error: odd number of case elements
")) (true V3044)))

(defun shen.timer-macro (V3046) (cond ((and (cons? V3046) (and (= time (hd V3046)) (and (cons? (tl V3046)) (= () (tl (tl V3046)))))) (shen.let-macro (cons let (cons Start (cons (cons get-time (cons run ())) (cons Result (cons (hd (tl V3046)) (cons Finish (cons (cons get-time (cons run ())) (cons Time (cons (cons - (cons Finish (cons Start ()))) (cons Message (cons (cons shen.prhush (cons (cons cn (cons "
run time: " (cons (cons cn (cons (cons str (cons Time ())) (cons " secs
" ()))) ()))) (cons (cons stoutput ()) ()))) (cons Result ())))))))))))))) (true V3046)))

(defun shen.tuple-up (V3048) (cond ((cons? V3048) (cons @p (cons (hd V3048) (cons (shen.tuple-up (tl V3048)) ())))) (true V3048)))

(defun shen.put/get-macro (V3050) (cond ((and (cons? V3050) (and (= put (hd V3050)) (and (cons? (tl V3050)) (and (cons? (tl (tl V3050))) (and (cons? (tl (tl (tl V3050)))) (= () (tl (tl (tl (tl V3050)))))))))) (cons put (cons (hd (tl V3050)) (cons (hd (tl (tl V3050))) (cons (hd (tl (tl (tl V3050)))) (cons (cons value (cons *property-vector* ())) ())))))) ((and (cons? V3050) (and (= get (hd V3050)) (and (cons? (tl V3050)) (and (cons? (tl (tl V3050))) (= () (tl (tl (tl V3050)))))))) (cons get (cons (hd (tl V3050)) (cons (hd (tl (tl V3050))) (cons (cons value (cons *property-vector* ())) ()))))) ((and (cons? V3050) (and (= get/or (hd V3050)) (and (cons? (tl V3050)) (and (cons? (tl (tl V3050))) (and (cons? (tl (tl (tl V3050)))) (= () (tl (tl (tl (tl V3050)))))))))) (cons get/or (cons (hd (tl V3050)) (cons (hd (tl (tl V3050))) (cons (hd (tl (tl (tl V3050)))) (cons (cons value (cons *property-vector* ())) ())))))) ((and (cons? V3050) (and (= unput (hd V3050)) (and (cons? (tl V3050)) (and (cons? (tl (tl V3050))) (= () (tl (tl (tl V3050)))))))) (cons unput (cons (hd (tl V3050)) (cons (hd (tl (tl V3050))) (cons (cons value (cons *property-vector* ())) ()))))) (true V3050)))

(defun shen.function-macro (V3052) (cond ((and (cons? V3052) (and (= function (hd V3052)) (and (cons? (tl V3052)) (= () (tl (tl V3052)))))) (shen.function-abstraction (hd (tl V3052)) (arity (hd (tl V3052))))) (true V3052)))

(defun shen.function-abstraction (V3055 V3056) (cond ((= 0 V3056) (simple-error (shen.app V3055 " has no lambda form
" shen.a))) ((= -1 V3056) (cons function (cons V3055 ()))) (true (shen.function-abstraction-help V3055 V3056 ()))))

(defun shen.function-abstraction-help (V3060 V3061 V3062) (cond ((= 0 V3061) (cons V3060 V3062)) (true (let X (gensym V) (cons /. (cons X (cons (shen.function-abstraction-help V3060 (- V3061 1) (append V3062 (cons X ()))) ())))))))

(defun undefmacro (V3064) (let MacroReg (value shen.*macroreg*) (let Pos (shen.findpos V3064 MacroReg) (let Remove1 (set shen.*macroreg* (remove V3064 MacroReg)) (let Remove2 (set *macros* (shen.remove-nth Pos (value *macros*))) V3064)))))

(defun shen.findpos (V3074 V3075) (cond ((= () V3075) (simple-error (shen.app V3074 " is not a macro
" shen.a))) ((and (cons? V3075) (= (hd V3075) V3074)) 1) ((cons? V3075) (+ 1 (shen.findpos V3074 (tl V3075)))) (true (shen.f_error shen.findpos))))

(defun shen.remove-nth (V3080 V3081) (cond ((and (= 1 V3080) (cons? V3081)) (tl V3081)) ((cons? V3081) (cons (hd V3081) (shen.remove-nth (- V3080 1) (tl V3081)))) (true (shen.f_error shen.remove-nth))))



