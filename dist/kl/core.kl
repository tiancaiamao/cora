(defun shen.shen->kl (V1498 V1499) (compile (lambda X (shen.<define> X)) (cons V1498 V1499) (lambda X (shen.shen-syntax-error V1498 X))))

(defun shen.shen-syntax-error (V1506 V1507) (cond ((cons? V1507) (simple-error (cn "syntax error in " (shen.app V1506 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1507)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1506 "
" shen.a))))))

(defun shen.<define> (V1509) (let YaccParse (let Parse_shen.<name> (shen.<name> V1509) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1509) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1511) (if (cons? (hd V1511)) (let Parse_X (hd (hd V1511)) (shen.pair (hd (shen.pair (tl (hd V1511)) (shen.hdtl V1511))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1513) (element? V1513 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1515) (if (and (cons? (hd V1515)) (= { (hd (hd V1515)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1515)) (shen.hdtl V1515))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1517) (cond ((and (cons? V1517) (and (cons? (tl V1517)) (and (= --> (hd (tl V1517))) (and (cons? (tl (tl V1517))) (and (cons? (tl (tl (tl V1517)))) (= --> (hd (tl (tl (tl V1517)))))))))) (shen.curry-type (cons (hd V1517) (cons --> (cons (tl (tl V1517)) ()))))) ((and (cons? V1517) (and (cons? (tl V1517)) (and (= * (hd (tl V1517))) (and (cons? (tl (tl V1517))) (and (cons? (tl (tl (tl V1517)))) (= * (hd (tl (tl (tl V1517)))))))))) (shen.curry-type (cons (hd V1517) (cons * (cons (tl (tl V1517)) ()))))) ((cons? V1517) (map (lambda Z (shen.curry-type Z)) V1517)) (true V1517)))

(defun shen.<signature-help> (V1519) (let YaccParse (if (cons? (hd V1519)) (let Parse_X (hd (hd V1519)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1519)) (shen.hdtl V1519))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1519) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1521) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1521) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1521) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1523) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1523) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1523) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1523) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1523) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1526 V1527) (if (V1526 V1527) (fail) V1527))

(defun shen.succeeds? (V1533) (cond ((= V1533 (fail)) false) (true true)))

(defun shen.<patterns> (V1535) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1535) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1535) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1542) (let YaccParse (if (and (cons? (hd V1542)) (cons? (hd (hd V1542)))) (if (and (cons? (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (= @p (hd (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (shen.hdtl (shen.pair (hd (hd V1542)) (hd (tl V1542)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1542)) (hd (tl V1542)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1542)) (cons? (hd (hd V1542)))) (if (and (cons? (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (= cons (hd (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (shen.hdtl (shen.pair (hd (hd V1542)) (hd (tl V1542)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1542)) (hd (tl V1542)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1542)) (cons? (hd (hd V1542)))) (if (and (cons? (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (= @v (hd (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (shen.hdtl (shen.pair (hd (hd V1542)) (hd (tl V1542)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1542)) (hd (tl V1542)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1542)) (cons? (hd (hd V1542)))) (if (and (cons? (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (= @s (hd (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (shen.hdtl (shen.pair (hd (hd V1542)) (hd (tl V1542)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1542)) (hd (tl V1542)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1542)) (cons? (hd (hd V1542)))) (if (and (cons? (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (= vector (hd (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (shen.hdtl (shen.pair (hd (hd V1542)) (hd (tl V1542))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1542)) (hd (tl V1542))))) (shen.hdtl (shen.pair (hd (hd V1542)) (hd (tl V1542))))))))) (shen.pair (hd (shen.pair (tl (hd V1542)) (hd (tl V1542)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1542)) (let Parse_X (hd (hd V1542)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1542)) (shen.hdtl V1542))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1542) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1544) (simple-error (shen.app V1544 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1546) (let YaccParse (if (cons? (hd V1546)) (let Parse_X (hd (hd V1546)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1546)) (shen.hdtl V1546))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1546)) (let Parse_X (hd (hd V1546)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1546)) (shen.hdtl V1546))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1548) (let Parse_shen.<pattern> (shen.<pattern> V1548) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1550) (let Parse_shen.<pattern> (shen.<pattern> V1550) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1552) (if (cons? (hd V1552)) (let Parse_X (hd (hd V1552)) (shen.pair (hd (shen.pair (tl (hd V1552)) (shen.hdtl V1552))) Parse_X)) (fail)))

(defun shen.<guard> (V1554) (if (cons? (hd V1554)) (let Parse_X (hd (hd V1554)) (shen.pair (hd (shen.pair (tl (hd V1554)) (shen.hdtl V1554))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1557 V1558) (let Lambda+ (shen.compile_to_lambda+ V1557 V1558) (let KL (shen.compile_to_kl V1557 Lambda+) (let Record (shen.record-source V1557 KL) KL))))

(defun shen.record-source (V1563 V1564) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1563 shen.source V1564 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1567 V1568) (let Arity (shen.aritycheck V1567 V1568) (let UpDateSymbolTable (shen.update-symbol-table V1567 Arity) (let Free (for-each (lambda Rule (shen.free_variable_check V1567 Rule)) V1568) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1568) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1571 V1572) (cond ((= 0 V1572) shen.skip) (true (put V1571 shen.lambda-form (eval-kl (shen.lambda-form V1571 V1572)) (value *property-vector*)))))

(defun shen.free_variable_check (V1575 V1576) (cond ((and (cons? V1576) (and (cons? (tl V1576)) (= () (tl (tl V1576))))) (let Bound (shen.extract_vars (hd V1576)) (let Free (shen.extract_free_vars Bound (hd (tl V1576))) (shen.free_variable_warnings V1575 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1578) (cond ((variable? V1578) (cons V1578 ())) ((cons? V1578) (union (shen.extract_vars (hd V1578)) (shen.extract_vars (tl V1578)))) (true ())))

(defun shen.extract_free_vars (V1590 V1591) (cond ((and (cons? V1591) (and (cons? (tl V1591)) (and (= () (tl (tl V1591))) (= (hd V1591) protect)))) ()) ((and (variable? V1591) (not (element? V1591 V1590))) (cons V1591 ())) ((and (cons? V1591) (and (= lambda (hd V1591)) (and (cons? (tl V1591)) (and (cons? (tl (tl V1591))) (= () (tl (tl (tl V1591)))))))) (shen.extract_free_vars (cons (hd (tl V1591)) V1590) (hd (tl (tl V1591))))) ((and (cons? V1591) (and (= let (hd V1591)) (and (cons? (tl V1591)) (and (cons? (tl (tl V1591))) (and (cons? (tl (tl (tl V1591)))) (= () (tl (tl (tl (tl V1591)))))))))) (union (shen.extract_free_vars V1590 (hd (tl (tl V1591)))) (shen.extract_free_vars (cons (hd (tl V1591)) V1590) (hd (tl (tl (tl V1591))))))) ((cons? V1591) (union (shen.extract_free_vars V1590 (hd V1591)) (shen.extract_free_vars V1590 (tl V1591)))) (true ())))

(defun shen.free_variable_warnings (V1596 V1597) (cond ((= () V1597) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1596 (cn ": " (shen.app (shen.list_variables V1597) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1599) (cond ((and (cons? V1599) (= () (tl V1599))) (cn (str (hd V1599)) ".")) ((cons? V1599) (cn (str (hd V1599)) (cn ", " (shen.list_variables (tl V1599))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1601) (cond ((and (cons? V1601) (and (cons? (tl V1601)) (and (= () (tl (tl V1601))) (= (hd V1601) protect)))) (shen.strip-protect (hd (tl V1601)))) ((cons? V1601) (map (lambda Z (shen.strip-protect Z)) V1601)) (true V1601)))

(defun shen.linearise (V1603) (cond ((and (cons? V1603) (and (cons? (tl V1603)) (= () (tl (tl V1603))))) (shen.linearise_help (shen.flatten (hd V1603)) (hd V1603) (hd (tl V1603)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1605) (cond ((= () V1605) ()) ((cons? V1605) (append (shen.flatten (hd V1605)) (shen.flatten (tl V1605)))) (true (cons V1605 ()))))

(defun shen.linearise_help (V1609 V1610 V1611) (cond ((= () V1609) (cons V1610 (cons V1611 ()))) ((cons? V1609) (if (and (variable? (hd V1609)) (element? (hd V1609) (tl V1609))) (let Var (gensym (hd V1609)) (let NewAction (cons where (cons (cons = (cons (hd V1609) (cons Var ()))) (cons V1611 ()))) (let NewPatts (shen.linearise_X (hd V1609) Var V1610) (shen.linearise_help (tl V1609) NewPatts NewAction)))) (shen.linearise_help (tl V1609) V1610 V1611))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1624 V1625 V1626) (cond ((= V1626 V1624) V1625) ((cons? V1626) (let L (shen.linearise_X V1624 V1625 (hd V1626)) (if (= L (hd V1626)) (cons (hd V1626) (shen.linearise_X V1624 V1625 (tl V1626))) (cons L (tl V1626))))) (true V1626)))

(defun shen.aritycheck (V1629 V1630) (cond ((and (cons? V1630) (and (cons? (hd V1630)) (and (cons? (tl (hd V1630))) (and (= () (tl (tl (hd V1630)))) (= () (tl V1630)))))) (do (shen.aritycheck-action (hd (tl (hd V1630)))) (shen.aritycheck-name V1629 (arity V1629) (length (hd (hd V1630)))))) ((and (cons? V1630) (and (cons? (hd V1630)) (and (cons? (tl (hd V1630))) (and (= () (tl (tl (hd V1630)))) (and (cons? (tl V1630)) (and (cons? (hd (tl V1630))) (and (cons? (tl (hd (tl V1630)))) (= () (tl (tl (hd (tl V1630)))))))))))) (if (= (length (hd (hd V1630))) (length (hd (hd (tl V1630))))) (do (shen.aritycheck-action (hd (tl (hd V1630)))) (shen.aritycheck V1629 (tl V1630))) (simple-error (cn "arity error in " (shen.app V1629 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1643 V1644 V1645) (cond ((= -1 V1644) V1645) ((= V1645 V1644) V1645) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1643 " can cause errors.
" shen.a)) (stoutput)) V1645))))

(defun shen.aritycheck-action (V1651) (cond ((cons? V1651) (do (shen.aah (hd V1651) (tl V1651)) (for-each (lambda Y (shen.aritycheck-action Y)) V1651))) (true shen.skip)))

(defun shen.aah (V1654 V1655) (let Arity (arity V1654) (let Len (length V1655) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1654 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1657) (cond ((and (cons? V1657) (and (cons? (tl V1657)) (= () (tl (tl V1657))))) (shen.abstraction_build (hd V1657) (hd (tl V1657)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1660 V1661) (cond ((= () V1660) V1661) ((cons? V1660) (cons /. (cons (hd V1660) (cons (shen.abstraction_build (tl V1660) V1661) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1663) (cond ((= 0 V1663) ()) (true (cons (gensym V) (shen.parameters (- V1663 1))))))

(defun shen.application_build (V1666 V1667) (cond ((= () V1666) V1667) ((cons? V1666) (shen.application_build (tl V1666) (cons V1667 (cons (hd V1666) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1670 V1671) (cond ((and (cons? V1671) (and (cons? (tl V1671)) (= () (tl (tl V1671))))) (let Arity (shen.store-arity V1670 (length (hd V1671))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1671))) (let CondExpression (shen.cond-expression V1670 (hd V1671) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1670) (hd V1671)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1671) TypeTable CondExpression) CondExpression) (cons defun (cons V1670 (cons (hd V1671) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1677) (cond ((cons? V1677) shen.skip) (true (let FType (assoc V1677 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1688 V1689) (cond ((and (cons? V1688) (and (cons? (tl V1688)) (and (= --> (hd (tl V1688))) (and (cons? (tl (tl V1688))) (and (= () (tl (tl (tl V1688)))) (cons? V1689)))))) (if (variable? (hd V1688)) (shen.typextable (hd (tl (tl V1688))) (tl V1689)) (cons (cons (hd V1689) (hd V1688)) (shen.typextable (hd (tl (tl V1688))) (tl V1689))))) (true ())))

(defun shen.assign-types (V1693 V1694 V1695) (cond ((and (cons? V1695) (and (= let (hd V1695)) (and (cons? (tl V1695)) (and (cons? (tl (tl V1695))) (and (cons? (tl (tl (tl V1695)))) (= () (tl (tl (tl (tl V1695)))))))))) (cons let (cons (hd (tl V1695)) (cons (shen.assign-types V1693 V1694 (hd (tl (tl V1695)))) (cons (shen.assign-types (cons (hd (tl V1695)) V1693) V1694 (hd (tl (tl (tl V1695))))) ()))))) ((and (cons? V1695) (and (= lambda (hd V1695)) (and (cons? (tl V1695)) (and (cons? (tl (tl V1695))) (= () (tl (tl (tl V1695)))))))) (cons lambda (cons (hd (tl V1695)) (cons (shen.assign-types (cons (hd (tl V1695)) V1693) V1694 (hd (tl (tl V1695)))) ())))) ((and (cons? V1695) (= cond (hd V1695))) (cons cond (map (lambda Y (cons (shen.assign-types V1693 V1694 (hd Y)) (cons (shen.assign-types V1693 V1694 (hd (tl Y))) ()))) (tl V1695)))) ((cons? V1695) (let NewTable (shen.typextable (shen.get-type (hd V1695)) (tl V1695)) (cons (hd V1695) (map (lambda Y (shen.assign-types V1693 (append V1694 NewTable) Y)) (tl V1695))))) (true (let AtomType (assoc V1695 V1694) (if (cons? AtomType) (cons type (cons V1695 (cons (tl AtomType) ()))) (if (element? V1695 V1693) V1695 (shen.atom-type V1695)))))))

(defun shen.atom-type (V1697) (if (string? V1697) (cons type (cons V1697 (cons string ()))) (if (number? V1697) (cons type (cons V1697 (cons number ()))) (if (boolean? V1697) (cons type (cons V1697 (cons boolean ()))) (if (symbol? V1697) (cons type (cons V1697 (cons symbol ()))) V1697)))))

(defun shen.store-arity (V1702 V1703) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1702 arity V1703 (value *property-vector*)))))

(defun shen.reduce (V1705) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1705) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1707) (cond ((and (cons? V1707) (and (cons? (hd V1707)) (and (= /. (hd (hd V1707))) (and (cons? (tl (hd V1707))) (and (cons? (hd (tl (hd V1707)))) (and (= cons (hd (hd (tl (hd V1707))))) (and (cons? (tl (hd (tl (hd V1707))))) (and (cons? (tl (tl (hd (tl (hd V1707)))))) (and (= () (tl (tl (tl (hd (tl (hd V1707))))))) (and (cons? (tl (tl (hd V1707)))) (and (= () (tl (tl (tl (hd V1707))))) (and (cons? (tl V1707)) (= () (tl (tl V1707))))))))))))))) (do (shen.add_test (cons cons? (tl V1707))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1707))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1707)))))) (cons (shen.ebr (hd (tl V1707)) (hd (tl (hd V1707))) (hd (tl (tl (hd V1707))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1707)) ())) (cons (cons tl (tl V1707)) ())) (shen.reduce_help Application))))) ((and (cons? V1707) (and (cons? (hd V1707)) (and (= /. (hd (hd V1707))) (and (cons? (tl (hd V1707))) (and (cons? (hd (tl (hd V1707)))) (and (= @p (hd (hd (tl (hd V1707))))) (and (cons? (tl (hd (tl (hd V1707))))) (and (cons? (tl (tl (hd (tl (hd V1707)))))) (and (= () (tl (tl (tl (hd (tl (hd V1707))))))) (and (cons? (tl (tl (hd V1707)))) (and (= () (tl (tl (tl (hd V1707))))) (and (cons? (tl V1707)) (= () (tl (tl V1707))))))))))))))) (do (shen.add_test (cons tuple? (tl V1707))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1707))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1707)))))) (cons (shen.ebr (hd (tl V1707)) (hd (tl (hd V1707))) (hd (tl (tl (hd V1707))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1707)) ())) (cons (cons snd (tl V1707)) ())) (shen.reduce_help Application))))) ((and (cons? V1707) (and (cons? (hd V1707)) (and (= /. (hd (hd V1707))) (and (cons? (tl (hd V1707))) (and (cons? (hd (tl (hd V1707)))) (and (= @v (hd (hd (tl (hd V1707))))) (and (cons? (tl (hd (tl (hd V1707))))) (and (cons? (tl (tl (hd (tl (hd V1707)))))) (and (= () (tl (tl (tl (hd (tl (hd V1707))))))) (and (cons? (tl (tl (hd V1707)))) (and (= () (tl (tl (tl (hd V1707))))) (and (cons? (tl V1707)) (= () (tl (tl V1707))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1707))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1707))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1707)))))) (cons (shen.ebr (hd (tl V1707)) (hd (tl (hd V1707))) (hd (tl (tl (hd V1707))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1707)) ())) (cons (cons tlv (tl V1707)) ())) (shen.reduce_help Application))))) ((and (cons? V1707) (and (cons? (hd V1707)) (and (= /. (hd (hd V1707))) (and (cons? (tl (hd V1707))) (and (cons? (hd (tl (hd V1707)))) (and (= @s (hd (hd (tl (hd V1707))))) (and (cons? (tl (hd (tl (hd V1707))))) (and (cons? (tl (tl (hd (tl (hd V1707)))))) (and (= () (tl (tl (tl (hd (tl (hd V1707))))))) (and (cons? (tl (tl (hd V1707)))) (and (= () (tl (tl (tl (hd V1707))))) (and (cons? (tl V1707)) (= () (tl (tl V1707))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1707))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1707))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1707)))))) (cons (shen.ebr (hd (tl V1707)) (hd (tl (hd V1707))) (hd (tl (tl (hd V1707))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1707)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1707)) ())) (shen.reduce_help Application))))) ((and (cons? V1707) (and (cons? (hd V1707)) (and (= /. (hd (hd V1707))) (and (cons? (tl (hd V1707))) (and (cons? (tl (tl (hd V1707)))) (and (= () (tl (tl (tl (hd V1707))))) (and (cons? (tl V1707)) (and (= () (tl (tl V1707))) (not (variable? (hd (tl (hd V1707))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1707))) (tl V1707)))) (shen.reduce_help (hd (tl (tl (hd V1707))))))) ((and (cons? V1707) (and (cons? (hd V1707)) (and (= /. (hd (hd V1707))) (and (cons? (tl (hd V1707))) (and (cons? (tl (tl (hd V1707)))) (and (= () (tl (tl (tl (hd V1707))))) (and (cons? (tl V1707)) (= () (tl (tl V1707)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1707)) (hd (tl (hd V1707))) (hd (tl (tl (hd V1707))))))) ((and (cons? V1707) (and (= where (hd V1707)) (and (cons? (tl V1707)) (and (cons? (tl (tl V1707))) (= () (tl (tl (tl V1707)))))))) (do (shen.add_test (hd (tl V1707))) (shen.reduce_help (hd (tl (tl V1707)))))) ((and (cons? V1707) (and (cons? (tl V1707)) (= () (tl (tl V1707))))) (let Z (shen.reduce_help (hd V1707)) (if (= (hd V1707) Z) V1707 (shen.reduce_help (cons Z (tl V1707)))))) (true V1707)))

(defun shen.+string? (V1709) (cond ((= "" V1709) false) (true (string? V1709))))

(defun shen.+vector? (V1711) (and (absvector? V1711) (> (<-address V1711 0) 0)))

(defun shen.ebr (V1725 V1726 V1727) (cond ((= V1727 V1726) V1725) ((and (cons? V1727) (and (= /. (hd V1727)) (and (cons? (tl V1727)) (and (cons? (tl (tl V1727))) (and (= () (tl (tl (tl V1727)))) (> (occurrences V1726 (hd (tl V1727))) 0)))))) V1727) ((and (cons? V1727) (and (= lambda (hd V1727)) (and (cons? (tl V1727)) (and (cons? (tl (tl V1727))) (and (= () (tl (tl (tl V1727)))) (> (occurrences V1726 (hd (tl V1727))) 0)))))) V1727) ((and (cons? V1727) (and (= let (hd V1727)) (and (cons? (tl V1727)) (and (cons? (tl (tl V1727))) (and (cons? (tl (tl (tl V1727)))) (and (= () (tl (tl (tl (tl V1727))))) (= (hd (tl V1727)) V1726))))))) (cons let (cons (hd (tl V1727)) (cons (shen.ebr V1725 (hd (tl V1727)) (hd (tl (tl V1727)))) (tl (tl (tl V1727))))))) ((cons? V1727) (cons (shen.ebr V1725 V1726 (hd V1727)) (shen.ebr V1725 V1726 (tl V1727)))) (true V1727)))

(defun shen.add_test (V1729) (set shen.*teststack* (cons V1729 (value shen.*teststack*))))

(defun shen.cond-expression (V1733 V1734 V1735) (let Err (shen.err-condition V1733) (let Cases (shen.case-form V1735 Err) (let EncodeChoices (shen.encode-choices Cases V1733) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1739) (cond ((and (cons? V1739) (and (cons? (hd V1739)) (and (= true (hd (hd V1739))) (and (cons? (tl (hd V1739))) (= () (tl (tl (hd V1739)))))))) (hd (tl (hd V1739)))) (true (cons cond V1739))))

(defun shen.encode-choices (V1744 V1745) (cond ((= () V1744) ()) ((and (cons? V1744) (and (cons? (hd V1744)) (and (= true (hd (hd V1744))) (and (cons? (tl (hd V1744))) (and (cons? (hd (tl (hd V1744)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1744))))) (and (cons? (tl (hd (tl (hd V1744))))) (and (= () (tl (tl (hd (tl (hd V1744)))))) (and (= () (tl (tl (hd V1744)))) (= () (tl V1744))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1744))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1745 ())) (cons shen.f_error (cons V1745 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1744) (and (cons? (hd V1744)) (and (= true (hd (hd V1744))) (and (cons? (tl (hd V1744))) (and (cons? (hd (tl (hd V1744)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1744))))) (and (cons? (tl (hd (tl (hd V1744))))) (and (= () (tl (tl (hd (tl (hd V1744)))))) (= () (tl (tl (hd V1744)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1744))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1744) V1745)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1744) (and (cons? (hd V1744)) (and (cons? (tl (hd V1744))) (and (cons? (hd (tl (hd V1744)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1744))))) (and (cons? (tl (hd (tl (hd V1744))))) (and (= () (tl (tl (hd (tl (hd V1744)))))) (= () (tl (tl (hd V1744))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1744) V1745)) ())) (cons (cons if (cons (hd (hd V1744)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1744))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1744) (and (cons? (hd V1744)) (and (cons? (tl (hd V1744))) (= () (tl (tl (hd V1744))))))) (cons (hd V1744) (shen.encode-choices (tl V1744) V1745))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1752 V1753) (cond ((= () V1752) (cons V1753 ())) ((and (cons? V1752) (and (cons? (hd V1752)) (and (cons? (hd (hd V1752))) (and (= : (hd (hd (hd V1752)))) (and (cons? (tl (hd (hd V1752)))) (and (= shen.tests (hd (tl (hd (hd V1752))))) (and (= () (tl (tl (hd (hd V1752))))) (and (cons? (tl (hd V1752))) (and (cons? (hd (tl (hd V1752)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1752))))) (and (cons? (tl (hd (tl (hd V1752))))) (and (= () (tl (tl (hd (tl (hd V1752)))))) (= () (tl (tl (hd V1752)))))))))))))))) (cons (cons true (tl (hd V1752))) (shen.case-form (tl V1752) V1753))) ((and (cons? V1752) (and (cons? (hd V1752)) (and (cons? (hd (hd V1752))) (and (= : (hd (hd (hd V1752)))) (and (cons? (tl (hd (hd V1752)))) (and (= shen.tests (hd (tl (hd (hd V1752))))) (and (= () (tl (tl (hd (hd V1752))))) (and (cons? (tl (hd V1752))) (= () (tl (tl (hd V1752)))))))))))) (cons (cons true (tl (hd V1752))) ())) ((and (cons? V1752) (and (cons? (hd V1752)) (and (cons? (hd (hd V1752))) (and (= : (hd (hd (hd V1752)))) (and (cons? (tl (hd (hd V1752)))) (and (= shen.tests (hd (tl (hd (hd V1752))))) (and (cons? (tl (hd V1752))) (= () (tl (tl (hd V1752))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1752))))) (tl (hd V1752))) (shen.case-form (tl V1752) V1753))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1755) (cond ((and (cons? V1755) (= () (tl V1755))) (hd V1755)) ((cons? V1755) (cons and (cons (hd V1755) (cons (shen.embed-and (tl V1755)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1757) (cons true (cons (cons shen.f_error (cons V1757 ())) ())))

(defun shen.sys-error (V1759) (simple-error (cn "system function " (shen.app V1759 ": unexpected argument
" shen.a))))



