(defun thaw (V1761) (V1761))

(defun eval (V1763) (let Macroexpand (shen.walk (lambda Y (macroexpand Y)) V1763) (if (shen.packaged? Macroexpand) (map (lambda Z (shen.eval-without-macros Z)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.eval-without-macros (V1765) (eval-kl (shen.elim-def (shen.proc-input+ V1765))))

(defun shen.proc-input+ (V1767) (cond ((and (cons? V1767) (and (= input+ (hd V1767)) (and (cons? (tl V1767)) (and (cons? (tl (tl V1767))) (= () (tl (tl (tl V1767)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V1767))) (tl (tl V1767))))) ((and (cons? V1767) (and (= shen.read+ (hd V1767)) (and (cons? (tl V1767)) (and (cons? (tl (tl V1767))) (= () (tl (tl (tl V1767)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V1767))) (tl (tl V1767))))) ((cons? V1767) (map (lambda Z (shen.proc-input+ Z)) V1767)) (true V1767)))

(defun shen.elim-def (V1769) (cond ((and (cons? V1769) (and (= define (hd V1769)) (cons? (tl V1769)))) (shen.shen->kl (hd (tl V1769)) (tl (tl V1769)))) ((and (cons? V1769) (and (= defmacro (hd V1769)) (cons? (tl V1769)))) (let Default (cons X (cons -> (cons X ()))) (let Def (shen.elim-def (cons define (cons (hd (tl V1769)) (append (tl (tl V1769)) Default)))) (let MacroAdd (shen.add-macro (hd (tl V1769))) Def)))) ((and (cons? V1769) (and (= defcc (hd V1769)) (cons? (tl V1769)))) (shen.elim-def (shen.yacc V1769))) ((cons? V1769) (map (lambda Z (shen.elim-def Z)) V1769)) (true V1769)))

(defun shen.add-macro (V1771) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V1771 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (set *macros* (cons (function V1771) (value *macros*)))))))

(defun shen.packaged? (V1779) (cond ((and (cons? V1779) (and (= package (hd V1779)) (and (cons? (tl V1779)) (cons? (tl (tl V1779)))))) true) (true false)))

(defun external (V1781) (get/or V1781 shen.external-symbols (freeze (simple-error (cn "package " (shen.app V1781 " has not been used.
" shen.a)))) (value *property-vector*)))

(defun internal (V1783) (get/or V1783 shen.internal-symbols (freeze (simple-error (cn "package " (shen.app V1783 " has not been used.
" shen.a)))) (value *property-vector*)))

(defun shen.package-contents (V1787) (cond ((and (cons? V1787) (and (= package (hd V1787)) (and (cons? (tl V1787)) (and (= null (hd (tl V1787))) (cons? (tl (tl V1787))))))) (tl (tl (tl V1787)))) ((and (cons? V1787) (and (= package (hd V1787)) (and (cons? (tl V1787)) (cons? (tl (tl V1787)))))) (shen.packageh (hd (tl V1787)) (hd (tl (tl V1787))) (tl (tl (tl V1787))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V1790 V1791) (cond ((cons? V1791) (V1790 (map (lambda Z (shen.walk V1790 Z)) V1791))) (true (V1790 V1791))))

(defun compile (V1795 V1796 V1797) (let O (V1795 (cons V1796 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V1797 O) (shen.hdtl O))))

(defun fail-if (V1800 V1801) (if (V1800 V1801) (fail) V1801))

(defun @s (V1804 V1805) (cn V1804 V1805))

(defun tc? () (value shen.*tc*))

(defun ps (V1807) (get/or V1807 shen.source (freeze (simple-error (shen.app V1807 " not found.
" shen.a))) (value *property-vector*)))

(defun stinput () (value *stinput*))

(defun <-address/or (V1811 V1812 V1813) (trap-error (<-address V1811 V1812) (lambda E (thaw V1813))))

(defun value/or (V1816 V1817) (trap-error (value V1816) (lambda E (thaw V1817))))

(defun vector (V1819) (let Vector (absvector (+ V1819 1)) (let ZeroStamp (address-> Vector 0 V1819) (let Standard (if (= V1819 0) ZeroStamp (shen.fillvector ZeroStamp 1 V1819 (fail))) Standard))))

(defun shen.fillvector (V1825 V1826 V1827 V1828) (cond ((= V1827 V1826) (address-> V1825 V1827 V1828)) (true (shen.fillvector (address-> V1825 V1826 V1828) (+ 1 V1826) V1827 V1828))))

(defun vector? (V1830) (and (absvector? V1830) (let X (<-address/or V1830 0 (freeze -1)) (and (number? X) (>= X 0)))))

(defun vector-> (V1834 V1835 V1836) (if (= V1835 0) (simple-error "cannot access 0th element of a vector
") (address-> V1834 V1835 V1836)))

(defun <-vector (V1839 V1840) (if (= V1840 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V1839 V1840) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun <-vector/or (V1844 V1845 V1846) (if (= V1845 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address/or V1844 V1845 V1846) (if (= VectorElement (fail)) (thaw V1846) VectorElement))))

(defun shen.posint? (V1848) (and (integer? V1848) (>= V1848 0)))

(defun limit (V1850) (<-address V1850 0))

(defun shen.analyse-symbol? (V1852) (cond ((= "" V1852) false) ((shen.+string? V1852) (and (shen.alpha? (pos V1852 0)) (shen.alphanums? (tlstr V1852)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V1854) (element? V1854 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V1856) (cond ((= "" V1856) true) ((shen.+string? V1856) (and (shen.alphanum? (pos V1856 0)) (shen.alphanums? (tlstr V1856)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V1858) (or (shen.alpha? V1858) (shen.digit? V1858)))

(defun shen.digit? (V1860) (element? V1860 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V1862) (cond ((or (boolean? V1862) (or (number? V1862) (string? V1862))) false) (true (trap-error (let String (str V1862) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V1864) (cond ((shen.+string? V1864) (and (shen.uppercase? (pos V1864 0)) (shen.alphanums? (tlstr V1864)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V1866) (element? V1866 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V1868) (concat V1868 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V1871 V1872) (intern (cn (str V1871) (str V1872))))

(defun @p (V1875 V1876) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V1875) (let Snd (address-> Vector 2 V1876) Vector)))))

(defun fst (V1878) (<-address V1878 1))

(defun snd (V1880) (<-address V1880 2))

(defun tuple? (V1882) (and (absvector? V1882) (= shen.tuple (<-address/or V1882 0 (freeze shen.not-tuple)))))

(defun append (V1885 V1886) (cond ((= () V1885) V1886) ((cons? V1885) (cons (hd V1885) (append (tl V1885) V1886))) (true (shen.f_error append))))

(defun @v (V1889 V1890) (let Limit (limit V1890) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V1889) (if (= Limit 0) X+NewVector (shen.@v-help V1890 1 Limit X+NewVector))))))

(defun shen.@v-help (V1896 V1897 V1898 V1899) (cond ((= V1898 V1897) (shen.copyfromvector V1896 V1899 V1898 (+ V1898 1))) (true (shen.@v-help V1896 (+ V1897 1) V1898 (shen.copyfromvector V1896 V1899 V1897 (+ V1897 1))))))

(defun shen.copyfromvector (V1904 V1905 V1906 V1907) (trap-error (vector-> V1905 V1907 (<-vector V1904 V1906)) (lambda E V1905)))

(defun hdv (V1909) (<-vector/or V1909 1 (freeze (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V1909 "
" shen.s))))))

(defun tlv (V1911) (let Limit (limit V1911) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V1911 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V1917 V1918 V1919 V1920) (cond ((= V1919 V1918) (shen.copyfromvector V1917 V1920 V1919 (- V1919 1))) (true (shen.tlv-help V1917 (+ V1918 1) V1919 (shen.copyfromvector V1917 V1920 V1918 (- V1918 1))))))

(defun assoc (V1932 V1933) (cond ((= () V1933) ()) ((and (cons? V1933) (and (cons? (hd V1933)) (= (hd (hd V1933)) V1932))) (hd V1933)) ((cons? V1933) (assoc V1932 (tl V1933))) (true (shen.f_error assoc))))

(defun boolean? (V1939) (cond ((= true V1939) true) ((= false V1939) true) (true false)))

(defun nl (V1941) (cond ((= 0 V1941) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V1941 1))))))

(defun difference (V1946 V1947) (cond ((= () V1946) ()) ((cons? V1946) (if (element? (hd V1946) V1947) (difference (tl V1946) V1947) (cons (hd V1946) (difference (tl V1946) V1947)))) (true (shen.f_error difference))))

(defun do (V1950 V1951) V1951)

(defun element? (V1963 V1964) (cond ((= () V1964) false) ((and (cons? V1964) (= (hd V1964) V1963)) true) ((cons? V1964) (element? V1963 (tl V1964))) (true (shen.f_error element?))))

(defun empty? (V1970) (cond ((= () V1970) true) (true false)))

(defun fix (V1973 V1974) (shen.fix-help V1973 V1974 (V1973 V1974)))

(defun shen.fix-help (V1985 V1986 V1987) (cond ((= V1987 V1986) V1987) (true (shen.fix-help V1985 V1987 (V1985 V1987)))))

(defun dict (V1989) (let D (absvector (+ 3 V1989)) (let Tag (address-> D 0 shen.dictionary) (let Capacity (address-> D 1 V1989) (let Count (address-> D 2 0) (let Fill (shen.fillvector D 3 (+ 2 V1989) ()) D))))))

(defun dict? (V1991) (and (absvector? V1991) (= (<-address/or V1991 0 (freeze shen.not-dictionary)) shen.dictionary)))

(defun shen.dict-capacity (V1993) (<-address V1993 1))

(defun dict-count (V1995) (<-address V1995 2))

(defun shen.dict-count-> (V1998 V1999) (address-> V1998 2 V1999))

(defun shen.<-dict-bucket (V2002 V2003) (<-address V2002 (+ 3 V2003)))

(defun shen.dict-bucket-> (V2007 V2008 V2009) (address-> V2007 (+ 3 V2008) V2009))

(defun shen.set-key-entry-value (V2016 V2017 V2018) (cond ((= () V2018) (cons (cons V2016 V2017) ())) ((and (cons? V2018) (and (cons? (hd V2018)) (= (hd (hd V2018)) V2016))) (cons (cons (hd (hd V2018)) V2017) (tl V2018))) ((cons? V2018) (cons (hd V2018) (shen.set-key-entry-value V2016 V2017 (tl V2018)))) (true (shen.f_error shen.set-key-entry-value))))

(defun shen.remove-key-entry-value (V2024 V2025) (cond ((= () V2025) ()) ((and (cons? V2025) (and (cons? (hd V2025)) (= (hd (hd V2025)) V2024))) (tl V2025)) ((cons? V2025) (cons (hd V2025) (shen.remove-key-entry-value V2024 (tl V2025)))) (true (shen.f_error shen.remove-key-entry-value))))

(defun shen.dict-update-count (V2029 V2030 V2031) (let Diff (- (length V2031) (length V2030)) (shen.dict-count-> V2029 (+ Diff (dict-count V2029)))))

(defun dict-> (V2035 V2036 V2037) (let N (hash V2036 (shen.dict-capacity V2035)) (let Bucket (shen.<-dict-bucket V2035 N) (let NewBucket (shen.set-key-entry-value V2036 V2037 Bucket) (let Change (shen.dict-bucket-> V2035 N NewBucket) (let Count (shen.dict-update-count V2035 Bucket NewBucket) V2037))))))

(defun <-dict/or (V2041 V2042 V2043) (let N (hash V2042 (shen.dict-capacity V2041)) (let Bucket (shen.<-dict-bucket V2041 N) (let Result (assoc V2042 Bucket) (if (empty? Result) (thaw V2043) (tl Result))))))

(defun <-dict (V2046 V2047) (<-dict/or V2046 V2047 (freeze (simple-error "value not found
"))))

(defun dict-rm (V2050 V2051) (let N (hash V2051 (shen.dict-capacity V2050)) (let Bucket (shen.<-dict-bucket V2050 N) (let NewBucket (shen.remove-key-entry-value V2051 Bucket) (let Change (shen.dict-bucket-> V2050 N NewBucket) (let Count (shen.dict-update-count V2050 Bucket NewBucket) V2051))))))

(defun dict-fold (V2055 V2056 V2057) (let Limit (shen.dict-capacity V2056) (shen.dict-fold-h V2055 V2056 V2057 0 Limit)))

(defun shen.dict-fold-h (V2064 V2065 V2066 V2067 V2068) (cond ((= V2068 V2067) V2066) (true (let B (shen.<-dict-bucket V2065 V2067) (let Acc (shen.bucket-fold V2064 B V2066) (shen.dict-fold-h V2064 V2065 Acc (+ 1 V2067) V2068))))))

(defun shen.bucket-fold (V2072 V2073 V2074) (cond ((= () V2073) V2074) ((and (cons? V2073) (cons? (hd V2073))) (V2072 (hd (hd V2073)) (tl (hd V2073)) (shen.bucket-fold V2072 (tl V2073) V2074))) (true (shen.f_error shen.bucket-fold))))

(defun dict-keys (V2076) (dict-fold (lambda K (lambda _ (lambda Acc (cons K Acc)))) V2076 ()))

(defun dict-values (V2078) (dict-fold (lambda _ (lambda V (lambda Acc (cons V Acc)))) V2078 ()))

(defun put (V2083 V2084 V2085 V2086) (let Curr (<-dict/or V2086 V2083 (freeze ())) (let Added (shen.set-key-entry-value V2084 V2085 Curr) (let Update (dict-> V2086 V2083 Added) V2085))))

(defun unput (V2090 V2091 V2092) (let Curr (<-dict/or V2092 V2090 (freeze ())) (let Removed (shen.remove-key-entry-value V2091 Curr) (let Update (dict-> V2092 V2090 Removed) V2090))))

(defun get/or (V2097 V2098 V2099 V2100) (let Entry (<-dict/or V2100 V2097 (freeze ())) (let Result (assoc V2098 Entry) (if (empty? Result) (thaw V2099) (tl Result)))))

(defun get (V2104 V2105 V2106) (get/or V2104 V2105 (freeze (simple-error "value not found
")) V2106))

(defun hash (V2109 V2110) (shen.mod (sum (map (lambda X (string->n X)) (explode V2109))) V2110))

(defun shen.mod (V2113 V2114) (shen.modh V2113 (shen.multiples V2113 (cons V2114 ()))))

(defun shen.multiples (V2117 V2118) (cond ((and (cons? V2118) (> (hd V2118) V2117)) (tl V2118)) ((cons? V2118) (shen.multiples V2117 (cons (* 2 (hd V2118)) V2118))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V2123 V2124) (cond ((= 0 V2123) 0) ((= () V2124) V2123) ((and (cons? V2124) (> (hd V2124) V2123)) (if (empty? (tl V2124)) V2123 (shen.modh V2123 (tl V2124)))) ((cons? V2124) (shen.modh (- V2123 (hd V2124)) V2124)) (true (shen.f_error shen.modh))))

(defun sum (V2126) (cond ((= () V2126) 0) ((cons? V2126) (+ (hd V2126) (sum (tl V2126)))) (true (shen.f_error sum))))

(defun head (V2134) (cond ((cons? V2134) (hd V2134)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V2142) (cond ((cons? V2142) (tl V2142)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V2144) (pos V2144 0))

(defun intersection (V2149 V2150) (cond ((= () V2149) ()) ((cons? V2149) (if (element? (hd V2149) V2150) (cons (hd V2149) (intersection (tl V2149) V2150)) (intersection (tl V2149) V2150))) (true (shen.f_error intersection))))

(defun reverse (V2152) (shen.reverse_help V2152 ()))

(defun shen.reverse_help (V2155 V2156) (cond ((= () V2155) V2156) ((cons? V2155) (shen.reverse_help (tl V2155) (cons (hd V2155) V2156))) (true (shen.f_error shen.reverse_help))))

(defun union (V2159 V2160) (cond ((= () V2159) V2160) ((cons? V2159) (if (element? (hd V2159) V2160) (union (tl V2159) V2160) (cons (hd V2159) (union (tl V2159) V2160)))) (true (shen.f_error union))))

(defun y-or-n? (V2162) (let Message (shen.prhush (shen.proc-nl V2162) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V2162))))))))

(defun not (V2164) (if V2164 false true))

(defun subst (V2177 V2178 V2179) (cond ((= V2179 V2178) V2177) ((cons? V2179) (map (lambda W (subst V2177 V2178 W)) V2179)) (true V2179)))

(defun explode (V2181) (shen.explode-h (shen.app V2181 "" shen.a)))

(defun shen.explode-h (V2183) (cond ((= "" V2183) ()) ((shen.+string? V2183) (cons (pos V2183 0) (shen.explode-h (tlstr V2183)))) (true (shen.f_error shen.explode-h))))

(defun cd (V2185) (set *home-directory* (if (= V2185 "") "" (shen.app V2185 "/" shen.a))))

(defun for-each (V2188 V2189) (cond ((= () V2189) true) ((cons? V2189) (let _ (V2188 (hd V2189)) (for-each V2188 (tl V2189)))) (true (shen.f_error for-each))))

(defun fold-right (V2193 V2194 V2195) (cond ((= () V2194) V2195) ((cons? V2194) (V2193 (hd V2194) (fold-right V2193 (tl V2194) V2195))) (true (shen.f_error fold-right))))

(defun fold-left (V2199 V2200 V2201) (cond ((= () V2201) V2200) ((cons? V2201) (fold-left V2199 (V2199 V2200 (hd V2201)) (tl V2201))) (true (shen.f_error fold-left))))

(defun filter (V2204 V2205) (shen.filter-h V2204 () V2205))

(defun shen.filter-h (V2215 V2216 V2217) (cond ((= () V2217) (reverse V2216)) ((and (cons? V2217) (V2215 (hd V2217))) (shen.filter-h V2215 (cons (hd V2217) V2216) (tl V2217))) ((cons? V2217) (shen.filter-h V2215 V2216 (tl V2217))) (true (shen.f_error shen.filter-h))))

(defun map (V2220 V2221) (shen.map-h V2220 V2221 ()))

(defun shen.map-h (V2227 V2228 V2229) (cond ((= () V2228) (reverse V2229)) ((cons? V2228) (shen.map-h V2227 (tl V2228) (cons (V2227 (hd V2228)) V2229))) (true (shen.f_error shen.map-h))))

(defun length (V2231) (shen.length-h V2231 0))

(defun shen.length-h (V2234 V2235) (cond ((= () V2234) V2235) (true (shen.length-h (tl V2234) (+ V2235 1)))))

(defun occurrences (V2247 V2248) (cond ((= V2248 V2247) 1) ((cons? V2248) (+ (occurrences V2247 (hd V2248)) (occurrences V2247 (tl V2248)))) (true 0)))

(defun nth (V2257 V2258) (cond ((and (= 1 V2257) (cons? V2258)) (hd V2258)) ((cons? V2258) (nth (- V2257 1) (tl V2258))) (true (shen.f_error nth))))

(defun shen.abs (V2260) (if (> V2260 0) V2260 (- 0 V2260)))

(defun shen.magless (V2263 V2264) (let Nx2 (* V2264 2) (if (> Nx2 V2263) V2264 (shen.magless V2263 Nx2))))

(defun shen.integer-test? (V2270 V2271) (cond ((= 0 V2270) true) ((> 1 V2270) false) (true (let Abs-N (- V2270 V2271) (if (> 0 Abs-N) (integer? V2270) (shen.integer-test? Abs-N V2271))))))

(defun mapcan (V2276 V2277) (cond ((= () V2277) ()) ((cons? V2277) (append (V2276 (hd V2277)) (mapcan V2276 (tl V2277)))) (true (shen.f_error mapcan))))

(defun == (V2289 V2290) (cond ((= V2290 V2289) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V2292) (and (symbol? V2292) (let Val (value/or V2292 (freeze shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V2294) (cond ((= "" V2294) ()) (true (cons (string->n (pos V2294 0)) (shen.string->bytes (tlstr V2294))))))

(defun maxinferences (V2296) (set shen.*maxinferences* V2296))

(defun inferences () (value shen.*infs*))

(defun protect (V2298) V2298)

(defun stoutput () (value *stoutput*))

(defun sterror () (value *sterror*))

(defun string->symbol (V2300) (let Symbol (intern V2300) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V2300 " to a symbol" shen.s))))))

(defun optimise (V2306) (cond ((= + V2306) (set shen.*optimise* true)) ((= - V2306) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V2308) (trap-error (do (external V2308) true) (lambda E false)))

(defun function (V2310) (shen.lookup-func V2310))

(defun shen.lookup-func (V2312) (get/or V2312 shen.lambda-form (freeze (simple-error (shen.app V2312 " has no lambda expansion
" shen.a))) (value *property-vector*)))



