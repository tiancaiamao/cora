(defun thaw (V682) (V682))

(defun eval (V684) (let Macroexpand (shen.walk (lambda Y (macroexpand Y)) V684) (if (shen.packaged? Macroexpand) (map (lambda Z (shen.eval-without-macros Z)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.eval-without-macros (V686) (eval-kl (shen.elim-def (shen.proc-input+ V686))))

(defun shen.proc-input+ (V688) (cond ((and (cons? V688) (and (= input+ (hd V688)) (and (cons? (tl V688)) (and (cons? (tl (tl V688))) (= () (tl (tl (tl V688)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V688))) (tl (tl V688))))) ((and (cons? V688) (and (= shen.read+ (hd V688)) (and (cons? (tl V688)) (and (cons? (tl (tl V688))) (= () (tl (tl (tl V688)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V688))) (tl (tl V688))))) ((cons? V688) (map (lambda Z (shen.proc-input+ Z)) V688)) (true V688)))

(defun shen.elim-def (V690) (cond ((and (cons? V690) (and (= define (hd V690)) (cons? (tl V690)))) (shen.shen->kl (hd (tl V690)) (tl (tl V690)))) ((and (cons? V690) (and (= defmacro (hd V690)) (cons? (tl V690)))) (let Default (cons X (cons -> (cons X ()))) (let Def (shen.elim-def (cons define (cons (hd (tl V690)) (append (tl (tl V690)) Default)))) (let MacroAdd (shen.add-macro (hd (tl V690))) Def)))) ((and (cons? V690) (and (= defcc (hd V690)) (cons? (tl V690)))) (shen.elim-def (shen.yacc V690))) ((cons? V690) (map (lambda Z (shen.elim-def Z)) V690)) (true V690)))

(defun shen.add-macro (V692) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V692 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (set *macros* (cons (function V692) (value *macros*)))))))

(defun shen.packaged? (V700) (cond ((and (cons? V700) (and (= package (hd V700)) (and (cons? (tl V700)) (cons? (tl (tl V700)))))) true) (true false)))

(defun external (V702) (get/or V702 shen.external-symbols (freeze (simple-error (cn "package " (shen.app V702 " has not been used.
" shen.a)))) (value *property-vector*)))

(defun internal (V704) (get/or V704 shen.internal-symbols (freeze (simple-error (cn "package " (shen.app V704 " has not been used.
" shen.a)))) (value *property-vector*)))

(defun shen.package-contents (V708) (cond ((and (cons? V708) (and (= package (hd V708)) (and (cons? (tl V708)) (and (= null (hd (tl V708))) (cons? (tl (tl V708))))))) (tl (tl (tl V708)))) ((and (cons? V708) (and (= package (hd V708)) (and (cons? (tl V708)) (cons? (tl (tl V708)))))) (shen.packageh (hd (tl V708)) (hd (tl (tl V708))) (tl (tl (tl V708))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V711 V712) (cond ((cons? V712) (V711 (map (lambda Z (shen.walk V711 Z)) V712))) (true (V711 V712))))

(defun compile (V716 V717 V718) (let O (V716 (cons V717 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V718 O) (shen.hdtl O))))

(defun fail-if (V721 V722) (if (V721 V722) (fail) V722))

(defun @s (V725 V726) (cn V725 V726))

(defun tc? () (value shen.*tc*))

(defun ps (V728) (get/or V728 shen.source (freeze (simple-error (shen.app V728 " not found.
" shen.a))) (value *property-vector*)))

(defun stinput () (value *stinput*))

(defun <-address/or (V732 V733 V734) (trap-error (<-address V732 V733) (lambda E (thaw V734))))

(defun value/or (V737 V738) (trap-error (value V737) (lambda E (thaw V738))))

(defun vector (V740) (let Vector (absvector (+ V740 1)) (let ZeroStamp (address-> Vector 0 V740) (let Standard (if (= V740 0) ZeroStamp (shen.fillvector ZeroStamp 1 V740 (fail))) Standard))))

(defun shen.fillvector (V746 V747 V748 V749) (cond ((= V748 V747) (address-> V746 V748 V749)) (true (shen.fillvector (address-> V746 V747 V749) (+ 1 V747) V748 V749))))

(defun vector? (V751) (and (absvector? V751) (let X (<-address/or V751 0 (freeze -1)) (and (number? X) (>= X 0)))))

(defun vector-> (V755 V756 V757) (if (= V756 0) (simple-error "cannot access 0th element of a vector
") (address-> V755 V756 V757)))

(defun <-vector (V760 V761) (if (= V761 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V760 V761) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun <-vector/or (V765 V766 V767) (if (= V766 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address/or V765 V766 V767) (if (= VectorElement (fail)) (thaw V767) VectorElement))))

(defun shen.posint? (V769) (and (integer? V769) (>= V769 0)))

(defun limit (V771) (<-address V771 0))

(defun shen.analyse-symbol? (V773) (cond ((= "" V773) false) ((shen.+string? V773) (and (shen.alpha? (pos V773 0)) (shen.alphanums? (tlstr V773)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V775) (element? V775 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V777) (cond ((= "" V777) true) ((shen.+string? V777) (and (shen.alphanum? (pos V777 0)) (shen.alphanums? (tlstr V777)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V779) (or (shen.alpha? V779) (shen.digit? V779)))

(defun shen.digit? (V781) (element? V781 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V783) (cond ((or (boolean? V783) (or (number? V783) (string? V783))) false) (true (trap-error (let String (str V783) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V785) (cond ((shen.+string? V785) (and (shen.uppercase? (pos V785 0)) (shen.alphanums? (tlstr V785)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V787) (element? V787 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V789) (concat V789 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V792 V793) (intern (cn (str V792) (str V793))))

(defun @p (V796 V797) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V796) (let Snd (address-> Vector 2 V797) Vector)))))

(defun fst (V799) (<-address V799 1))

(defun snd (V801) (<-address V801 2))

(defun tuple? (V803) (and (absvector? V803) (= shen.tuple (<-address/or V803 0 (freeze shen.not-tuple)))))

(defun append (V806 V807) (cond ((= () V806) V807) ((cons? V806) (cons (hd V806) (append (tl V806) V807))) (true (shen.f_error append))))

(defun @v (V810 V811) (let Limit (limit V811) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V810) (if (= Limit 0) X+NewVector (shen.@v-help V811 1 Limit X+NewVector))))))

(defun shen.@v-help (V817 V818 V819 V820) (cond ((= V819 V818) (shen.copyfromvector V817 V820 V819 (+ V819 1))) (true (shen.@v-help V817 (+ V818 1) V819 (shen.copyfromvector V817 V820 V818 (+ V818 1))))))

(defun shen.copyfromvector (V825 V826 V827 V828) (trap-error (vector-> V826 V828 (<-vector V825 V827)) (lambda E V826)))

(defun hdv (V830) (<-vector/or V830 1 (freeze (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V830 "
" shen.s))))))

(defun tlv (V832) (let Limit (limit V832) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V832 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V838 V839 V840 V841) (cond ((= V840 V839) (shen.copyfromvector V838 V841 V840 (- V840 1))) (true (shen.tlv-help V838 (+ V839 1) V840 (shen.copyfromvector V838 V841 V839 (- V839 1))))))

(defun assoc (V853 V854) (cond ((= () V854) ()) ((and (cons? V854) (and (cons? (hd V854)) (= (hd (hd V854)) V853))) (hd V854)) ((cons? V854) (assoc V853 (tl V854))) (true (shen.f_error assoc))))

(defun boolean? (V860) (cond ((= true V860) true) ((= false V860) true) (true false)))

(defun nl (V862) (cond ((= 0 V862) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V862 1))))))

(defun difference (V867 V868) (cond ((= () V867) ()) ((cons? V867) (if (element? (hd V867) V868) (difference (tl V867) V868) (cons (hd V867) (difference (tl V867) V868)))) (true (shen.f_error difference))))

(defun do (V871 V872) V872)

(defun element? (V884 V885) (cond ((= () V885) false) ((and (cons? V885) (= (hd V885) V884)) true) ((cons? V885) (element? V884 (tl V885))) (true (shen.f_error element?))))

(defun empty? (V891) (cond ((= () V891) true) (true false)))

(defun fix (V894 V895) (shen.fix-help V894 V895 (V894 V895)))

(defun shen.fix-help (V906 V907 V908) (cond ((= V908 V907) V908) (true (shen.fix-help V906 V908 (V906 V908)))))

(defun dict (V910) (let D (absvector (+ 3 V910)) (let Tag (address-> D 0 shen.dictionary) (let Capacity (address-> D 1 V910) (let Count (address-> D 2 0) (let Fill (shen.fillvector D 3 (+ 2 V910) ()) D))))))

(defun dict? (V912) (and (absvector? V912) (= (<-address/or V912 0 (freeze shen.not-dictionary)) shen.dictionary)))

(defun shen.dict-capacity (V914) (<-address V914 1))

(defun dict-count (V916) (<-address V916 2))

(defun shen.dict-count-> (V919 V920) (address-> V919 2 V920))

(defun shen.<-dict-bucket (V923 V924) (<-address V923 (+ 3 V924)))

(defun shen.dict-bucket-> (V928 V929 V930) (address-> V928 (+ 3 V929) V930))

(defun shen.set-key-entry-value (V937 V938 V939) (cond ((= () V939) (cons (cons V937 V938) ())) ((and (cons? V939) (and (cons? (hd V939)) (= (hd (hd V939)) V937))) (cons (cons (hd (hd V939)) V938) (tl V939))) ((cons? V939) (cons (hd V939) (shen.set-key-entry-value V937 V938 (tl V939)))) (true (shen.f_error shen.set-key-entry-value))))

(defun shen.remove-key-entry-value (V945 V946) (cond ((= () V946) ()) ((and (cons? V946) (and (cons? (hd V946)) (= (hd (hd V946)) V945))) (tl V946)) ((cons? V946) (cons (hd V946) (shen.remove-key-entry-value V945 (tl V946)))) (true (shen.f_error shen.remove-key-entry-value))))

(defun shen.dict-update-count (V950 V951 V952) (let Diff (- (length V952) (length V951)) (shen.dict-count-> V950 (+ Diff (dict-count V950)))))

(defun dict-> (V956 V957 V958) (let N (hash V957 (shen.dict-capacity V956)) (let Bucket (shen.<-dict-bucket V956 N) (let NewBucket (shen.set-key-entry-value V957 V958 Bucket) (let Change (shen.dict-bucket-> V956 N NewBucket) (let Count (shen.dict-update-count V956 Bucket NewBucket) V958))))))

(defun <-dict/or (V962 V963 V964) (let N (hash V963 (shen.dict-capacity V962)) (let Bucket (shen.<-dict-bucket V962 N) (let Result (assoc V963 Bucket) (if (empty? Result) (thaw V964) (tl Result))))))

(defun <-dict (V967 V968) (<-dict/or V967 V968 (freeze (simple-error "value not found
"))))

(defun dict-rm (V971 V972) (let N (hash V972 (shen.dict-capacity V971)) (let Bucket (shen.<-dict-bucket V971 N) (let NewBucket (shen.remove-key-entry-value V972 Bucket) (let Change (shen.dict-bucket-> V971 N NewBucket) (let Count (shen.dict-update-count V971 Bucket NewBucket) V972))))))

(defun dict-fold (V976 V977 V978) (let Limit (shen.dict-capacity V977) (shen.dict-fold-h V976 V977 V978 0 Limit)))

(defun shen.dict-fold-h (V985 V986 V987 V988 V989) (cond ((= V989 V988) V987) (true (let B (shen.<-dict-bucket V986 V988) (let Acc (shen.bucket-fold V985 B V987) (shen.dict-fold-h V985 V986 Acc (+ 1 V988) V989))))))

(defun shen.bucket-fold (V993 V994 V995) (cond ((= () V994) V995) ((and (cons? V994) (cons? (hd V994))) (V993 (hd (hd V994)) (tl (hd V994)) (shen.bucket-fold V993 (tl V994) V995))) (true (shen.f_error shen.bucket-fold))))

(defun dict-keys (V997) (dict-fold (lambda K (lambda _ (lambda Acc (cons K Acc)))) V997 ()))

(defun dict-values (V999) (dict-fold (lambda _ (lambda V (lambda Acc (cons V Acc)))) V999 ()))

(defun put (V1004 V1005 V1006 V1007) (let Curr (<-dict/or V1007 V1004 (freeze ())) (let Added (shen.set-key-entry-value V1005 V1006 Curr) (let Update (dict-> V1007 V1004 Added) V1006))))

(defun unput (V1011 V1012 V1013) (let Curr (<-dict/or V1013 V1011 (freeze ())) (let Removed (shen.remove-key-entry-value V1012 Curr) (let Update (dict-> V1013 V1011 Removed) V1011))))

(defun get/or (V1018 V1019 V1020 V1021) (let Entry (<-dict/or V1021 V1018 (freeze ())) (let Result (assoc V1019 Entry) (if (empty? Result) (thaw V1020) (tl Result)))))

(defun get (V1025 V1026 V1027) (get/or V1025 V1026 (freeze (simple-error "value not found
")) V1027))

(defun hash (V1030 V1031) (shen.mod (sum (map (lambda X (string->n X)) (explode V1030))) V1031))

(defun shen.mod (V1034 V1035) (shen.modh V1034 (shen.multiples V1034 (cons V1035 ()))))

(defun shen.multiples (V1038 V1039) (cond ((and (cons? V1039) (> (hd V1039) V1038)) (tl V1039)) ((cons? V1039) (shen.multiples V1038 (cons (* 2 (hd V1039)) V1039))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V1044 V1045) (cond ((= 0 V1044) 0) ((= () V1045) V1044) ((and (cons? V1045) (> (hd V1045) V1044)) (if (empty? (tl V1045)) V1044 (shen.modh V1044 (tl V1045)))) ((cons? V1045) (shen.modh (- V1044 (hd V1045)) V1045)) (true (shen.f_error shen.modh))))

(defun sum (V1047) (cond ((= () V1047) 0) ((cons? V1047) (+ (hd V1047) (sum (tl V1047)))) (true (shen.f_error sum))))

(defun head (V1055) (cond ((cons? V1055) (hd V1055)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V1063) (cond ((cons? V1063) (tl V1063)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V1065) (pos V1065 0))

(defun intersection (V1070 V1071) (cond ((= () V1070) ()) ((cons? V1070) (if (element? (hd V1070) V1071) (cons (hd V1070) (intersection (tl V1070) V1071)) (intersection (tl V1070) V1071))) (true (shen.f_error intersection))))

(defun reverse (V1073) (shen.reverse_help V1073 ()))

(defun shen.reverse_help (V1076 V1077) (cond ((= () V1076) V1077) ((cons? V1076) (shen.reverse_help (tl V1076) (cons (hd V1076) V1077))) (true (shen.f_error shen.reverse_help))))

(defun union (V1080 V1081) (cond ((= () V1080) V1081) ((cons? V1080) (if (element? (hd V1080) V1081) (union (tl V1080) V1081) (cons (hd V1080) (union (tl V1080) V1081)))) (true (shen.f_error union))))

(defun y-or-n? (V1083) (let Message (shen.prhush (shen.proc-nl V1083) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V1083))))))))

(defun not (V1085) (if V1085 false true))

(defun subst (V1098 V1099 V1100) (cond ((= V1100 V1099) V1098) ((cons? V1100) (map (lambda W (subst V1098 V1099 W)) V1100)) (true V1100)))

(defun explode (V1102) (shen.explode-h (shen.app V1102 "" shen.a)))

(defun shen.explode-h (V1104) (cond ((= "" V1104) ()) ((shen.+string? V1104) (cons (pos V1104 0) (shen.explode-h (tlstr V1104)))) (true (shen.f_error shen.explode-h))))

(defun cd (V1106) (set *home-directory* (if (= V1106 "") "" (shen.app V1106 "/" shen.a))))

(defun for-each (V1109 V1110) (cond ((= () V1110) true) ((cons? V1110) (let _ (V1109 (hd V1110)) (for-each V1109 (tl V1110)))) (true (shen.f_error for-each))))

(defun fold-right (V1114 V1115 V1116) (cond ((= () V1115) V1116) ((cons? V1115) (V1114 (hd V1115) (fold-right V1114 (tl V1115) V1116))) (true (shen.f_error fold-right))))

(defun fold-left (V1120 V1121 V1122) (cond ((= () V1122) V1121) ((cons? V1122) (fold-left V1120 (V1120 V1121 (hd V1122)) (tl V1122))) (true (shen.f_error fold-left))))

(defun filter (V1125 V1126) (shen.filter-h V1125 () V1126))

(defun shen.filter-h (V1136 V1137 V1138) (cond ((= () V1138) (reverse V1137)) ((and (cons? V1138) (V1136 (hd V1138))) (shen.filter-h V1136 (cons (hd V1138) V1137) (tl V1138))) ((cons? V1138) (shen.filter-h V1136 V1137 (tl V1138))) (true (shen.f_error shen.filter-h))))

(defun map (V1141 V1142) (shen.map-h V1141 V1142 ()))

(defun shen.map-h (V1148 V1149 V1150) (cond ((= () V1149) (reverse V1150)) ((cons? V1149) (shen.map-h V1148 (tl V1149) (cons (V1148 (hd V1149)) V1150))) (true (shen.f_error shen.map-h))))

(defun length (V1152) (shen.length-h V1152 0))

(defun shen.length-h (V1155 V1156) (cond ((= () V1155) V1156) (true (shen.length-h (tl V1155) (+ V1156 1)))))

(defun occurrences (V1168 V1169) (cond ((= V1169 V1168) 1) ((cons? V1169) (+ (occurrences V1168 (hd V1169)) (occurrences V1168 (tl V1169)))) (true 0)))

(defun nth (V1178 V1179) (cond ((and (= 1 V1178) (cons? V1179)) (hd V1179)) ((cons? V1179) (nth (- V1178 1) (tl V1179))) (true (shen.f_error nth))))

(defun shen.abs (V1181) (if (> V1181 0) V1181 (- 0 V1181)))

(defun shen.magless (V1184 V1185) (let Nx2 (* V1185 2) (if (> Nx2 V1184) V1185 (shen.magless V1184 Nx2))))

(defun shen.integer-test? (V1191 V1192) (cond ((= 0 V1191) true) ((> 1 V1191) false) (true (let Abs-N (- V1191 V1192) (if (> 0 Abs-N) (integer? V1191) (shen.integer-test? Abs-N V1192))))))

(defun mapcan (V1197 V1198) (cond ((= () V1198) ()) ((cons? V1198) (append (V1197 (hd V1198)) (mapcan V1197 (tl V1198)))) (true (shen.f_error mapcan))))

(defun == (V1210 V1211) (cond ((= V1211 V1210) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V1213) (and (symbol? V1213) (let Val (value/or V1213 (freeze shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V1215) (cond ((= "" V1215) ()) (true (cons (string->n (pos V1215 0)) (shen.string->bytes (tlstr V1215))))))

(defun maxinferences (V1217) (set shen.*maxinferences* V1217))

(defun inferences () (value shen.*infs*))

(defun protect (V1219) V1219)

(defun stoutput () (value *stoutput*))

(defun sterror () (value *sterror*))

(defun string->symbol (V1221) (let Symbol (intern V1221) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V1221 " to a symbol" shen.s))))))

(defun optimise (V1227) (cond ((= + V1227) (set shen.*optimise* true)) ((= - V1227) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V1229) (trap-error (do (external V1229) true) (lambda E false)))

(defun function (V1231) (shen.lookup-func V1231))

(defun shen.lookup-func (V1233) (get/or V1233 shen.lambda-form (freeze (simple-error (shen.app V1233 " has no lambda expansion
" shen.a))) (value *property-vector*)))

